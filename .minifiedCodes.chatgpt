<"file: python/testpyfoil.py">import pyfoil
airfoil=pyfoil.Airfoil.compute_naca(3315).normalized()
airfoil2=pyfoil.Airfoil.import_from_dat("ClarkY.dat")
Result = airfoil2._repr_svg_()
with open("airfoil2.svg", 'w') as f:
    f.write(Result)
res = airfoil.xfoil_aoa(5, degree=True)
print(res.reynolds)
print(airfoil.xfoil_aoa(5, degree=True))
print(airfoil2.xfoil_aoa(5, degree=True))
</"file: python/testpyfoil.py">

<"file: python/testxfoil.py">import subprocess
import numpy as np
# import pyxfoil

from os import path, environ
path_ = path.dirname(path.realpath(__file__))


# pyxfoil.set_workdir(path_)
# x = pyxfoil.Xfoil('NACA 1112')
# x.points_from_dat('./airfoils/AG35.dat')
# x.set_ppar(300)

# al = [-2.0, 0.0, 4.0, 6.0]
# mach = 0.1
# re = 100000.0
# ax1 = x.plot_profile(ls='-')
# for ali in al:
#     rescase = x.run_result(ali, mach=mach, re=re)

def run_xfoil(airfoil, reynolds, alpha_start, alpha_end, alpha_step):
    res = path_ + "/res.txt"
    err = path_ + "/err.txt"
    # Prepare the commands to input to XFOIL
    commands = f"""
    NACA {airfoil}
    OPER
    VISC {reynolds}
    PACC
    {res}
    {err}
    ASEQ {alpha_start} {alpha_end} {alpha_step}
    QUIT
    """
    # Run XFOIL as a subprocess
    environ["DISPLAY"] = ":0"
    # Specify the path to the .exe application
    windows_exe_path = "c://xfoil//xfoil.exe"  # Adjust as needed

    # Launch the .exe using subprocess
    subprocess.run(["/mnt/c/Windows/System32/cmd.exe", "/c", windows_exe_path])
    # Launch the .exe using Popen
    process = subprocess.Popen(
        ["/mnt/c/Windows/System32/cmd.exe", "/c", windows_exe_path],
        stdout=subprocess.PIPE, 
        stderr=subprocess.PIPE,
        text=True  # Ensures output is in string format (Python 3.7+)
    )
    
    output, error = process.communicate(commands)

    # Capture output and error streams in real-time
    for line in process.stdout:
        print(line.strip())  # Print output as it appears

    # Wait for process to complete
    process.wait()
    

    process = subprocess.Popen(['xfoil'], stdin=subprocess.PIPE, \
                               stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    output, error = process.communicate(commands)

    with open("results.txt", 'w') as f:
        f.write(output)
    with open("errors.txt", 'w') as f:
        f.write(error)

    # Load the results from the output file
    try:
        data = np.loadtxt(res, skiprows=13)  # Skip XFOIL header rows
        alpha, cl, cd, cm = data[:, 0], data[:, 1], data[:, 2], data[:, 4]
        ld_ratio = cl / cd
        return alpha, cl, cd, ld_ratio
    except Exception as e:
        print(f"Error loading results: {e}")
        return None

# Example usage
alpha, cl, cd, ld_ratio = run_xfoil('2212', 3000000, 0, 10, 1)
for a, cl_val, cd_val, ld in zip(alpha, cl, cd, ld_ratio):
    print(f"Alpha: {a}, Cl: {cl_val}, Cd: {cd_val}, L/D: {ld}")
</"file: python/testxfoil.py">

<"file: python/app.py">import json
from flask import jsonify, request, send_file
from create_io import list_files_recursively
from utils import list_airfoils, get_airfoil_stl, get_airfoil_dat, \
                            get_airfoil_step, get_airfoil_screenshot, \
                            create_geometry, create_mesh, create_screenshot, get_airfoil_description
from airfoilGen.generator import naca as nacaFunction

# login stuff
from datetime import datetime, timedelta, timezone
from flask_jwt_extended import create_access_token,get_jwt,get_jwt_identity, \
                               unset_jwt_cookies, jwt_required, JWTManager

from configs import app, db

import io

# cur folder
from os import path
__my_dirname = path.dirname(path.realpath(__file__)) 

# adding login functionality
from flask import flash, request
from models import User, Project



#login for users
def _login_helper(avatar, password):
    user = User.query.filter_by(avatar=avatar).first()
    # Check if the user exists and the password is correct
    if user and user.check_password(password):
        access_token = create_access_token(identity=user.id, 
                                           additional_claims={"avatar": user.avatar, 
                                                              "firstname": user.first_name,
                                                              "email": user.email})
        response = {"access_token":access_token, "success": True, "user": {
            "lastname": user.last_name,
            "firstname": user.first_name,
            "email": user.email,
            "avatar": user.avatar
        }}
        return response
    return {"access_token":"", "success": False}

@app.route("/login", methods=["GET", "POST"])
def login():
    # if current_user.is_authenticated:
    #     return {
    #         "success": True,
    #         "message": "Already authenticated."
    #     }
    if request.method == "POST":
        avatar = request.json["avatar"]
        password = request.json["password"]
        
        return _login_helper(avatar, password)
    return {"success": False, "error": "invalid method"}

# Routes
@app.route("/register", methods=["GET", "POST"])
def register():
    # if current_user.is_authenticated:
    #     return {
    #         "success": True,
    #         "message": "Already authenticated."
    #     }
    if request.method == "POST":
        avatar = request.json["avatar"]
        lastname = request.json["lastname"]
        firstname = request.json["firstname"]
        password = request.json["password"]
        email = request.json["email"]

        # Check if username already exists
        if User.query.filter_by(avatar=avatar).first():
            if "firebase" in request.json:
                return _login_helper(avatar, password)
            flash("Username already taken!")
            return {"error": "avatar taken", "success": False}

        # Create a new user and save to database
        new_user = User(avatar=avatar, first_name=firstname, last_name=lastname, email=email)
        new_user.set_password(password)
        db.session.add(new_user)
        db.session.commit()
        import os
        if not os.path.exists(f'{__my_dirname}/users/{avatar}'):
            os.makedirs(f'{__my_dirname}/users/{avatar}')
        flash("Registered successfully!")
        if "firebase" in request.json:
            return _login_helper(avatar, password)
        return {"success": True}

    return {"error": "Post.", "success": False}

@app.after_request
def refresh_expiring_jwts(response):
    try:
        exp_timestamp = get_jwt()["exp"]
        now = datetime.now(timezone.utc)
        target_timestamp = datetime.timestamp(now + timedelta(minutes=30))
        if target_timestamp > exp_timestamp:
            access_token = create_access_token(identity=get_jwt_identity())
            data = response.get_json()
            if type(data) is dict:
                data["access_token"] = access_token 
                response.data = json.dumps(data)
        return response
    except (RuntimeError, KeyError):
        # Case where there is not a valid JWT. Just return the original respone
        return response


def getUser():
    claims = get_jwt()
    user = User.query.filter_by(avatar=claims.get("avatar")).first()
    return user

def get_project_by_name(user_id: int, project_name: str) -> Project:
    return db.session.query(Project).filter_by(user_id=user_id, name=project_name).first()

@app.route("/dashboard")
@jwt_required()
def dashboard():
    # Get additional claims if you stored any
    claims = get_jwt()
    id = get_jwt_identity()
    user = User.query.filter_by(avatar=claims.get("avatar")).first()
    return {"data": f"Hello, {user.first_name}! Welcome to your dashboard.", "success": True}

@app.route("/logout")
def logout():
    response = jsonify({"msg": "logout successful", "success": True})
    unset_jwt_cookies(response)
    return response

# # Teardown context to close database session
# @app.teardown_appcontext
# def shutdown_session(exception=None):
#     db.session.remove()  # Properly close and release any sessions
#     if db.engine:
#         db.engine.dispose()  # Dispose of engine connections if necessary

@app.route('/', methods=['GET'])
def home():
    """Home for all airfoils."""
    return jsonify("Home for all airfoils")

@app.route('/airfoils', methods=['GET'])
def get_airfoils():
    """List all airfoils."""
    airfoils = list_airfoils()
    return jsonify(airfoils)

@app.route('/airfoil/<string:airfoil>/stl', methods=['GET'])
def get_stl(airfoil):
    """Get the STL file content for a specific airfoil."""
    try:
        stl_content = get_airfoil_stl(airfoil)
        return send_file(
            io.BytesIO(stl_content),  # Use BytesIO to wrap the bytes
            mimetype='application/sla',
            as_attachment=True,
            download_name=f'{airfoil}.stl'
        )
    except FileNotFoundError:
        return jsonify({"error": "STL file not found"}), 404

@app.route('/airfoil/<string:airfoil>/dat', methods=['GET'])
def get_dat(airfoil):
    """Get the DAT file content for a specific airfoil."""
    try:
        dat_content = get_airfoil_dat(airfoil)
        return send_file(
            io.BytesIO(dat_content),  # Use BytesIO to wrap the bytes
            mimetype='application/text',
            as_attachment=True,
            download_name=f'{airfoil}.dat'
        )
    except FileNotFoundError:
        return jsonify({"error": "STL file not found"}), 404

@app.route('/airfoil/<string:airfoil>/step', methods=['GET'])
def get_step(airfoil):
    """Get the STEP file content for a specific airfoil."""
    try:
        step_content = get_airfoil_step(airfoil)
        return send_file(
            io.BytesIO(step_content),  # Use BytesIO to wrap the bytes
            mimetype='application/sla',
            as_attachment=True,
            download_name=f'{airfoil}.step'
        )
    except FileNotFoundError:
        return jsonify({"error": "STEP file not found"}), 404

@app.route('/airfoil/<string:airfoil>/screenshot', methods=['GET'])
def get_screenshot(airfoil):
    """Get the screenshot for a specific airfoil."""
    try:
        screenshot = get_airfoil_screenshot(airfoil)
        return send_file(
            io.BytesIO(screenshot),
            mimetype='image/png',
            as_attachment=True,
            download_name=f'{airfoil}.png'
        )
    except FileNotFoundError:
        return jsonify({"error": "Screenshot not found"}), 404

@app.route('/airfoil/<string:airfoil>/description', methods=['GET'])
def get_description(airfoil):
    """Get the description for a specific airfoil."""
    try:
        return jsonify({"description": get_airfoil_description(airfoil)})
    except Exception as e:
        return jsonify({"error": "Desc not found", "description": ""}), 404


@app.route('/airfoil/<string:airfoil>/geometry', methods=['POST'])
def create_geo(airfoil):
    """Create geometry for a specific airfoil."""
    method = request.json.get('method')
    wingspan = request.json.get('wingspan')
    params = request.json.get('params')

    if not method or not wingspan or not params:
        return jsonify({"error": "Invalid parameters"}), 400

    try:
        geometry = create_geometry(airfoil, method, wingspan, params)
        return jsonify({"message": "Geometry created"}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/airfoil/<string:airfoil>/mesh', methods=['POST'])
def create_airfoil_mesh(airfoil):
    """Create mesh for a specific airfoil."""
    try:
        mesh_success = create_mesh(airfoil)
        return jsonify({"message": "Mesh created", "success": mesh_success}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/airfoil/<string:airfoil>/screenshot/create', methods=['POST'])
def take_screenshot(airfoil):
    """Get the screenshot for a specific airfoil."""
    try:
        screenshot = get_airfoil_screenshot(airfoil)
        return send_file(
            io.BytesIO(screenshot),  # Use BytesIO to wrap the bytes
            mimetype='image/png',
            as_attachment=True,
            download_name=f'{airfoil}.png'
        )
    except FileNotFoundError:
        return jsonify({"error": "Screenshot not found"}), 404

@app.route('/user/<string:username>/dir', methods=['GET'])
def get_dir(username):
    """Will display dir of the user"""
    try:
        return jsonify(list_files_recursively(username))
    except Exception as e:
        return jsonify({"error": "Error in dir", "description": e}), 404 

@app.route('/naca/<string:naca>/<int:n>/txt', methods=['GET'])
@jwt_required()
def getNacaAirfoilTxt(naca, n):
    """
        Will generate and fetch the NACA dat file
    """
    try:
        try:
            dat = nacaFunction(naca, n, save=False)
        except Exception as e:
            return jsonify({"success": False, "message": "No naca function."})
        return jsonify({"success": True, "data": dat})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/naca/<string:naca>/<int:n>/dat', methods=['GET'])
def getNacaAirfoilDat(naca, n):
    """
        Will generate and fetch the NACA dat file
    """
    try:
        try:
            dat = nacaFunction(naca, n, save=False)
        except Exception as e:
            return jsonify({"success": False, "message": "No naca function."})
        dat_content = '\n'.join(f"{x}   {y}" for x, y in zip(dat[0],dat[1]))
        
        dat_io = io.BytesIO()
        dat_io.write(dat_content.encode('utf-8'))
        dat_io.seek(0)

        return send_file(
            dat_io,
            mimetype='application/txt',
            as_attachment=True,
            download_name=f'NACA_{naca}_{n}.dat'
        )
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/naca/<string:naca>/<int:n>/png', methods=['GET'])
def getNacaAirfoilImage(naca, n):
    """
        Will generate and fetch the NACA dat file
    """
    try:
        try:
            dat = nacaFunction(naca, n, save=False, uploadImage=True)
        except Exception as e:
            return jsonify({"success": False, "message": "No naca function."})
        dat.seek(0)
        return send_file(
            dat,
            mimetype='image/png',
            as_attachment=True,
            download_name=f'NACA_{naca}_{n}.png'
        )
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/airfoil/<string:airfoil>', methods=['POST'])
@jwt_required()
def setAirfoil(airfoil):
    """
        Will set airfoil for later exploitation
    """
    try:
        lines = []
        try:
            for line in airfoil.split('\n'):
                lines.push((line.split(' ')[0], lines.split(' ')[1]))
        except Exception as e:
            return jsonify({"success": False, "message": "Invalid airfoil."})
        


        # SETTING AIRFOIL FOR THIS USER

        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})


@app.route('/myprojects', methods=['GET'])
@jwt_required()
def getProjects():
    """
        Fetches the user's projects
    """
    try:
        lines = []
        current_user = getUser()
        try:
            for project in current_user.projects:
                lines.append({"name": project.name, "description": project.description})
        except Exception as e:
            return jsonify({"success": False, "message": "Invalid request or server error."})
        return jsonify({"success": True, "projects": lines})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/myprojects/new', methods=['POST'])
@jwt_required()
def newProject():
    """
        new project
    """
    try:
        json_ = request.json
        cur_user = getUser()
        p = Project()
        p.description = json_['description']
        p.name = json_['name']
        p.user_id = cur_user.id
        db.session.add(p)
        db.session.commit()
        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/myprojects/<string:project_name>/comms', methods=['POST'])
@jwt_required()
def comms(project_name):
    """
        Get data from react
    """
    try:
        user = getUser()
        j = request.json
        project_ = get_project_by_name(user.id, project_name)
        project_.intialize()
        project_.flightTime = j['flightTime']['expected']
        project_.weightExpected = j['weight']['expected']
        project_.speedExpected = j['speed']['expected']
        project_.payloadWeight = j['payloadWeight']
        project_.AirfoilLengthMax = j['wingSpanMax']
        project_.fuselageLengthMax = j['fuselageLengthMax']
        project_.streamVelocityX = j['streamVelocityX']
        project_.AOA = j['angleOfAttack']
        # project_.airfoilType = j['airfoilType']
        # project_.doneInitialSketch = j['doneInitialSketch']
        # project_.simulationType = j['simulationType']
        # project_.done = j['done']
        project_.flightPriorities.maneuverability = int(j['priorities']['maneuverability'])
        project_.flightPriorities.stability = int(j['priorities']['stability'])
        project_.flightPriorities.payload = int(j['priorities']['payload'])
        project_.flightPriorities.speed = int(j['priorities']['speed'])
        project_.flightPriorities.stall_behavior = int(j['priorities']['stallBehavior'])
        project_.flightPriorities.manufacturability = int(j['priorities']['manufacturability'])
        project_.flightPriorities.endurance = int(j['priorities']['endurance'])
        project_.refresh()
        # print(project_.flightPriorities.speed)
        db.session.commit()

        # print(project_)
        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/myprojects/<string:project_name>/airfoilData', methods=['POST'])
@jwt_required()
def setAirfoilData(project_name):
    """
        Get data from react
    """
    try:
        user = getUser()
        j = request.json
        project_ = get_project_by_name(user.id, project_name)
        project_.intialize()
        project_.airfoilData = '$'.join(j['airfoilData'].split('\n'))
        project_.refresh()
        db.session.commit()
        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/myprojects/<string:project_name>/summary', methods=['GET'])
@jwt_required()
def summary(project_name):
    """
        Get data from react
    """
    try:
        user = getUser()
        project_ = get_project_by_name(user.id, project_name)
        project_.intialize()
        # print(project_)
        return jsonify({"success": True, "summary": project_.computeDetails()})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
</"file: python/app.py">

<"file: python/models.py">from werkzeug.security import generate_password_hash, check_password_hash
from configs import db
import numpy as np
from airfoilGen import generator
from sqlalchemy import MetaData, ForeignKey
import sqlalchemy as sa
from sqlalchemy.orm import mapped_column, Mapped, relationship
from datetime import datetime
# from flask_login import current_user

from configs import db
from math import pow
from typing import List

DENSITY_AIR = 1.225
VISCOSITY_AIR = 1.81 * pow(10, -5)
GRAVITY = 9.81

COST_MANOEUVRABILITY_ON_SPEED = 0.12
COST_PAYLOAD_ON_SPEED = 0.2
COST_SPEED_ON_SPEED = 0.4

ASPECT_RATIO_LOW = 5
ASPECT_RATIO_HIGH = 50

# cur folder
from os import path
my_root = path.dirname(path.realpath(__file__)) 

def abs(n):
    if n < 0:
        return -n
    return n
# db = app.db

def kmh_ms(_speed_):
    return _speed_ / 3.6
def ms_kmh(_speed_):
    return _speed_ * 3.6
def format_large_number(number):
    # Format the number with commas
    return (f"{number:,}")

class AircraftPriorities(db.Model):
    __tablename__ = "aircraft_priorities"
    
    id: Mapped[int] = mapped_column(db.Integer, primary_key=True)
    maneuverability: Mapped[int] = mapped_column(db.Integer, nullable=False)
    stability: Mapped[int] = mapped_column(db.Integer, nullable=False)
    payload: Mapped[int] = mapped_column(db.Integer, nullable=False)
    speed: Mapped[int] = mapped_column(db.Integer, nullable=False)
    endurance: Mapped[int] = mapped_column(db.Integer, nullable=False)
    stall_behavior: Mapped[int] = mapped_column(db.Integer, nullable=False)
    manufacturability: Mapped[int] = mapped_column(db.Integer, nullable=False)

    project_id: Mapped[int]= mapped_column(ForeignKey("projects.id"))

    def __init__(self) -> None:
        super().__init__()
        self.maneuverability = 3
        self.stability = 3
        self.payload = 3
        self.speed = 3
        self.endurance = 3
        self.stall_behavior = 3
        self.manufacturability = 3

class interval:
    def __init__(self, a, b, minMaxFlag=False) -> None:
        if not minMaxFlag:
            self.val = a
            self.margins = b
        else:
            self.val = a + abs(b - a) / 2
            self.margins = abs(b - a) / 2
    def max(self):
        return self.val + self.margins
    def min(self):
        if self.val == 0:
            return 0
        if (self.margins > self.val):
            return 0
        mar_ = self.margins
        val_ = self.val - mar_
        while val_ <= 0:
            mar_ /= 1.2
            val_ = self.val - mar_
        return val_
    def __repr__(self) -> str:
        return f'min: {format_large_number(self.min())} -- max: {format_large_number(self.max())}'

class User(db.Model):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(db.Integer, primary_key=True)
    last_name: Mapped[str] = mapped_column(nullable=False)
    first_name: Mapped[str] = mapped_column(nullable=False)
    email: Mapped[str]  = mapped_column(nullable=False, default="example@email.com")
    pass_hash: Mapped[str]  = mapped_column(nullable=False)
    avatar: Mapped[str]  = mapped_column(nullable=False)
    
    projects: Mapped[List["Project"]] = relationship()

    def is_authenticated(self):
        return True

    def set_password(self, password):
        self.pass_hash = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.pass_hash, password)
    
    def __repr__(self):
        return f'<User {self.avatar}>'

# Define Project model
class Project(db.Model):
    # __tablename__ = 'projects'
    # metadata = MetaData()

    # if not metadata.tables.get('projects'):
    __tablename__ = "projects"
    
    id: Mapped[int]= mapped_column(primary_key=True)
    name: Mapped[int]= mapped_column(nullable=False, unique=True)
    description: Mapped[int]= mapped_column()
    foldername: Mapped[int]= mapped_column()    

    # Foreign key linking to the User model
    user_id: Mapped[int]= mapped_column(ForeignKey("users.id"))

    flightTime: Mapped[int]= mapped_column(server_default='0', nullable=False) 
    weightExpected: Mapped[int]= mapped_column(server_default='0', nullable=False) 
    weightMargins: Mapped[int]= mapped_column(server_default='0', nullable=False)
    payloadWeight: Mapped[int]= mapped_column(server_default='0', nullable=False)
    speedExpected: Mapped[int]= mapped_column(server_default='0', nullable=False) 
    speedMargins: Mapped[int]= mapped_column(server_default='0', nullable=False)
    fuselageLengthMax: Mapped[int]= mapped_column(server_default='0', nullable=False) 
    AirfoilLengthMax: Mapped[int]= mapped_column(server_default='0', nullable=False)
    streamVelocityX: Mapped[int]= mapped_column(server_default='0', nullable=False) 
    AOA: Mapped[int]= mapped_column(server_default='0', nullable=False)
    simulationType: Mapped[int]= mapped_column(server_default='0', nullable=False)
    material: Mapped[int]= mapped_column(server_default='0', nullable=False) 
    density: Mapped[int]= mapped_column(server_default='0', nullable=False)
    selectedAirfoil: Mapped[int]= mapped_column(server_default='0', nullable=False)
    meshQuality: Mapped[int]= mapped_column(server_default='0', nullable=False)
    chordLength: Mapped[int]= mapped_column(server_default='0', nullable=False) # in mm

    flightPriorities: Mapped[AircraftPriorities]= relationship()

    airfoilData: Mapped[str] = mapped_column(nullable=True)

    initialized: bool = False

    def __init__(self) -> None:
        super().__init__()
        self.intialize()

    def intialize(self):
        if self.initialized:
            return
        self.foldername = f'{my_root}/users/user_sample'

        self.flightTime = self.flightTime if self.flightTime is not None else 0  
        self.weightExpected = self.weightExpected if self.weightExpected is not None else 0  
        self.weightMargins = self.weightMargins if self.weightMargins is not None else 0 
        self.payloadWeight = self.payloadWeight if self.payloadWeight is not None else 0 
        self.speedExpected = self.speedExpected if self.speedExpected is not None else 0  
        self.speedMargins = self.speedMargins if self.speedMargins is not None else 0 
        self.fuselageLengthMax = self.fuselageLengthMax if self.fuselageLengthMax is not None else 0  
        self.AirfoilLengthMax = self.AirfoilLengthMax if self.AirfoilLengthMax is not None else 0 
        self.streamVelocityX = self.streamVelocityX if self.streamVelocityX is not None else 0  
        self.AOA = self.AOA if self.AOA is not None else 0 
        self.simulationType = self.simulationType if self.simulationType is not None else 0 
        self.material = self.material if self.material is not None else 0  
        self.density = self.density if self.density is not None else 0 
        self.selectedAirfoil = self.selectedAirfoil if self.selectedAirfoil is not None else 0 
        self.meshQuality = self.meshQuality if self.meshQuality is not None else 0 
        self.chordLength = self.chordLength if self.chordLength is not None else 1 # mm 

        if self.flightPriorities == None:
            f = AircraftPriorities()
            self.flightPriorities = f
            db.session.add(f)
            db.session.commit()
        self.refresh()
        self.initialized = True

    def refresh(self):
        # refresh parameters
        if self.speedExpected > 0:
            a = self.flightPriorities.maneuverability * COST_MANOEUVRABILITY_ON_SPEED \
                 + self.flightPriorities.speed * COST_SPEED_ON_SPEED
            b = self.flightPriorities.payload * COST_PAYLOAD_ON_SPEED
            self.speed = interval(
                    kmh_ms(self.speedExpected - b * self.speedExpected / 5), 
                    kmh_ms(self.speedExpected + a * self.speedExpected / 10),
                    True
                )
        else:
            self.speed = interval(kmh_ms(self.speedExpected), kmh_ms(self.speedMargins))
        self.weight = interval(self.weightExpected, self.weightMargins)
        self.updateCritical()

    def computeReynoldsUnitArea(self):
        # return pow(self.streamVelocityX, 2) * DENSITY_AIR * self.chordLength / VISCOSITY_AIR
        return  interval(
                pow(self.speed.min(), 2) * DENSITY_AIR * (self._chordLength.min() / 100) / VISCOSITY_AIR
                ,
                pow(self.speed.max(), 2) * DENSITY_AIR * (self._chordLength.max() / 100) / VISCOSITY_AIR
                ,
                True
        )

    def computeDetails(self):
        return f"""
        -------------| AIRFOIL INFORMATION  | ------------
        User information:
        Folder: {self.foldername}
        Last updated: {datetime.now().ctime()}

        [GEOMETRY - FIXED WING] 
        - Max wingspan: {self.AirfoilLengthMax}
        - Max fuselage length: {self.fuselageLengthMax}
        - Suggested airfoil: {self.selectedAirfoil}
        - Suggested chord length: {self.chordLength}

        [FLIGHT PARAMETERS]
        - Weight: min ({self.weight.min()}) Kg; max ({self.weight.max()}) Kg
        - Payload weight (max): {self.payloadWeight} Kg
        - Endurance: about ({self.flightTime}) minutes
        - Speed: min ({ms_kmh(self.speed.min())}) km/h; max ({ms_kmh(self.speed.max())}) km/h

        [CONSTRUCTION]
        - Material: {self.material}
        - Density: {self.density}

        [PRIORITIES]
        - maneuverability: {self.flightPriorities.maneuverability} pts
        - stability: {self.flightPriorities.stability} pts
        - payload: {self.flightPriorities.payload} pts
        - speed: {self.flightPriorities.speed} pts
        - endurance: {self.flightPriorities.endurance} pts
        - stall_behavior: {self.flightPriorities.stall_behavior} pts
        - manufacturability: {self.flightPriorities.manufacturability} pts

        --------------------------------------------------

        [COMPUTED]
        - Reynolds Number: {self._reynolds}
        - Required lift force: {self._liftForceRequired} Newtons
        - CL Required per area: {self._CLRequiredForWeightPerArea}
        - Aspect Ratio (AR): {self._aspectRatio}
        - Chord length : {self._chordLength} cm
        """

    def updateCritical(self):
        self._reynolds = -1
        self._liftForceRequired = interval(-1, -1)
        self._CLRequiredForWeightPerArea = interval(-1, -1)
        self._aspectRatio = interval(-1, -1)
        self._chordLength = interval(-1, -1)

        if self.speed.min() == 0:
            return
        # update the critical parameters
        self._liftForceRequired = interval(self.weight.min() * GRAVITY, self.weight.max() * GRAVITY, True)
        self._CLRequiredForWeightPerArea = interval( \
                                                    self._liftForceRequired.min() / (0.5 * pow(self.speed.max() , 2) * DENSITY_AIR), \
                                                    self._liftForceRequired.max() / (0.5 * pow(self.speed.min() , 2) * DENSITY_AIR),
                                                    True
                                                )
        # aspect ratio calculations


        
        a = self.flightPriorities.endurance - self.flightPriorities.maneuverability
        self._aspectRatio = \
                interval( \
                ASPECT_RATIO_LOW + (ASPECT_RATIO_HIGH - ASPECT_RATIO_LOW) * (a + 5) * 0.8 / 10 \
                ,
                ASPECT_RATIO_LOW + (ASPECT_RATIO_HIGH - ASPECT_RATIO_LOW) * (a + 5) * 1.25 / 10, True)
        # For a constant-chord wing of chord c and span b, the aspect ratio is given by b/c
        self._chordLength = interval(
            self.AirfoilLengthMax / self._aspectRatio.max(),
            self.AirfoilLengthMax / self._aspectRatio.min(), True
        )
        self._reynolds = self.computeReynoldsUnitArea()

        # self._forceProduce

    def computeAirfoilInfo(self):
        return f"""
            -------------| AIRFOIL INFORMATION  | ------------
        * User information:
        * Folder: {self.foldername}
        * Last updated: {datetime.now().ctime()}
        ------------------------------------------------------
        
        """</"file: python/models.py">

<"file: python/migrations/versions/3279f3e0f96b_first.py">"""first

Revision ID: 3279f3e0f96b
Revises: 
Create Date: 2024-10-29 17:38:41.583185

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '3279f3e0f96b'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('projects', schema=None) as batch_op:
        batch_op.add_column(sa.Column('airfoilData', sa.String(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('projects', schema=None) as batch_op:
        batch_op.drop_column('airfoilData')

    # ### end Alembic commands ###
</"file: python/migrations/versions/3279f3e0f96b_first.py">

<"file: python/migrations/env.py">import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</"file: python/migrations/env.py">

<"file: python/configs.py">
from flask import Flask
from my_secrets.secret_key_ import my_secret_key
from datetime import timedelta
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager
from flask_migrate import Migrate
from flask_cors import CORS

app = Flask(__name__)

# sql alchemy stuff
app.secret_key = my_secret_key #TO BE MODIFIED
app.config["JWT_SECRET_KEY"] = my_secret_key
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///dynamicas.db'  # Use SQLite for simplicity
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)
db = SQLAlchemy(app)
jwt = JWTManager(app)
migrate = Migrate(app, db, render_as_batch=True)

# Enable CORS for all origins
# CORS(app, origins="http://localhost:3000")
CORS(app)
app.config['CORS_HEADERS'] = 'Content-Type'</"file: python/configs.py">

<"file: python/airfoilData.py"># import numpy as np
# from airfoilGen import generator
# from sqlalchemy import MetaData
# # from flask_login import current_user

# from configs import db
# from math import pow

# from python.models import User

# DENSITY_AIR = 1.225
# VISCOSITY_AIR = 1.81 * pow(10, -5)
# GRAVITY = 9.81

# # cur folder
# from os import path
# __my_root = path.dirname(path.realpath(__file__)) 

# def abs(n):
#     if n < 0:
#         return -n
#     return n
# # db = app.db

# class interval:
#     def __init__(self, a, b, minMaxFlag) -> None:
#         if not minMaxFlag:
#             self.val = a
#             self.margins = b
#         else:
#             self.val = a + abs(b - a) / 2
#             self.margins = abs(b - a)
#     def max(self):
#         self.val + self.margins
#     def min(self):
#         self.val - self.margins

# # Define Project model
# class Project(db.Model):
#     # __tablename__ = 'projects'
#     metadata = MetaData()

#     if not metadata.tables.get('projects'):
#         __tablename__ = "projects"
    
#     id = db.Column(db.Integer, primary_key=True)
#     name = db.Column(db.String(100), nullable=False)
#     description = db.Column(db.String(500))
#     foldername = db.Column(db.String(100))    
#     # Foreign key linking to the User model
#     user_id = db.Column(db.Integer, db.ForeignKey(User.id), nullable=False)

#     flightTime = db.Column(db.Integer) 
#     weightExpected = db.Column(db.Integer) 
#     weightMargins = db.Column(db.Integer)
#     payloadWeight = db.Column(db.Integer)
#     speedExpected = db.Column(db.Integer) 
#     speedMargins = db.Column(db.Integer)
#     fuselageLengthMax = db.Column(db.Integer) 
#     AirfoilLengthMax = db.Column(db.Integer)
#     streamVelocityX = db.Column(db.Integer) 
#     AOA = db.Column(db.Integer)
#     simulationType = db.Column(db.Integer)
#     material = db.Column(db.Integer) 
#     density = db.Column(db.Integer)
#     selectedAirfoil = db.Column(db.Integer)
#     meshQuality = db.Column(db.Integer)
#     chordLength = db.Column(db.Integer)


#     def __init__(self) -> None:
#         super().__init__()
#         self.speed = interval(self.speedExpected, self.speedMargins)
#         self.weight = interval(self.weightExpected, self.weightMargins)
#         self.updateCritical()

#     def computeReynoldsUnitArea(self):
#         return self.streamVelocityX ^ 2 * DENSITY_AIR * self.chordLength / VISCOSITY_AIR

#     def updateCritical(self):
#         # update the critical parameters
#         self._reynolds = self.computeReynoldsUnitArea()
#         self._liftForceRequired = interval(self.weight.min() * GRAVITY, self.weight.max() * GRAVITY, True)
#         self._CLRequiredForWeightPerArea = interval( \
#                                                     self._liftForce.min() / (0.5 * (self.speed.max() ^ 2) * DENSITY_AIR), \
#                                                     self._liftForce.max() / (0.5 * (self.speed.min() ^ 2) * DENSITY_AIR)
#                                                 )
#         self._forceProduce


# current_user = ""

# class airfoil_data:
    
#     def __init__(self, source="", naca="", pts=[], n_points=200) -> bool: #success?
#         self.source = source
#         self.n_points = n_points
#         if source == "naca":
#             self.naca = naca
#         elif source == "data":
#             self.pts = np.array(pts)
#         else:
#             return False
#         # what about scaling for a chordlength

#         return True

#     def initializePtsFromNACA(self) -> bool:
#         # will take a naca and generate some points
#         if self.naca == "" or len(self.naca) not in [4,5]:
#             return False
#         naca = generator.naca(self.naca, self.n_points)
#         with open(f'{__my_root}\{current_user}', 'w') as f:
#             f.write(naca)
#         self.pts = np.array(naca)

# # Fixed wing project
# # class FWProject:

# #     def __init__(self,
# #                  _flightTime, 
# #                  _weightExpected, _weightMargins,
# #                  _payloadWeight,
# #                  _speedExpected, _speedMargins,
# #                  _fuselageLengthMax, _AirfoilLengthMax,
# #                  _streamVelocityX, _AOA,
# #                  _simulationType,
# #                  _material, _density,
# #                  _selectedAirfoil,
# #                  _meshQuality,
# #                  _chordLength
# #                  ) -> None:
# #         self.flightTime = _flightTime
# #         self.weight: interval = interval(_weightExpected, _weightMargins)
# #         self.speed: interval = interval(_speedExpected, _speedMargins)
# #         self.fuselageMaxLength = _fuselageLengthMax
# #         self.streamVelocityX = _streamVelocityX
# #         self.material = _material
# #         self.density = _density
# #         self.meshQuality = _meshQuality
# #         self.selectedAirfoil = _selectedAirfoil
# #         self.simulationType = _simulationType
# #         self.payloadWeight = _payloadWeight
# #         self.chordLength = _chordLength

# #         self._reynolds = self.computeReynoldsUnitArea()

# #     def computeReynoldsUnitArea(self):
# #         return self.streamVelocityX ^ 2 * DENSITY_AIR * self.chordLength / VISCOSITY_AIR

</"file: python/airfoilData.py">

<"file: python/__init__.py">from . import app
from . import airfoilData</"file: python/__init__.py">

<"file: python/utils.py">import os
from create_geo_airfoil import create_geometry_from_file
from create_mesh import generate_mesh_from_step
from create_view import create_screenshot as cs
from typing import List

# Specify the folder path
from os import path
folder_path = path.dirname(path.realpath(__file__)) + '/airfoils/'

def list_airfoils() -> List[str]:
    # List all .dat files in the folder
    dat_files = [f.split('.')[0] for f in os.listdir(folder_path) if f.endswith('.dat')]
    return dat_files

def get_airfoil_stl(airfoil: str) -> bytes:
    path_ = folder_path + airfoil + ".dat.stl"
    with open(path_, "rb") as f:
        return f.read()

def get_airfoil_dat(airfoil: str) -> bytes:
    path_ = folder_path + airfoil + ".dat"
    with open(path_, "rb") as f:
        return f.read()

def get_airfoil_step(airfoil: str) -> bytes:
    path_ = folder_path + airfoil + ".dat.step"
    with open(path_, "rb") as f:
        return f.read()

def get_airfoil_screenshot(airfoil: str) -> bytes:
    path_ = folder_path + airfoil + ".dat.stl.png"
    with open(path_, "rb") as f:
        return f.read()
     

def create_geometry(airfoil: str, method: str, wingspan: float, params: List[float]):
    from base import airfoilFile
    a = airfoilFile("airfoils/" + airfoil + ".dat")
    a.recenterX(-0.5)
    a.scale(1000)
    return create_geometry_from_file(a, wingspan, method, [], airfoil)

def create_mesh(airfoil_file: str):
    # def generate_mesh_from_step(step_file: str, mesh_file: str):
    generate_mesh_from_step(airfoil_file, airfoil_file + ".mesh")
    return True

def create_screenshot(airfoil_file: str):
    cs(airfoil_file)
    return True

def get_airfoil_description(airfoil: str) -> str:
    descriptions = {
        "NACA_23012": (
            "The NACA 23012 is a symmetrical airfoil with a maximum camber of 2% located at 30% of the chord length. "
            "It is commonly used in general aviation applications, particularly in aircraft wings where moderate lift "
            "and drag characteristics are needed. Its performance is suitable for aerobatic aircraft, providing good "
            "control and maneuverability."
        ),
        "ClarkY": (
            "The Clark Y airfoil is a popular cambered airfoil known for its simplicity and effectiveness in providing lift. "
            "It is frequently used in light aircraft and gliders due to its favorable lift-to-drag ratio and stall "
            "characteristics. It is also often employed in model aircraft due to its forgiving nature and ease of construction."
        ),
        "test": (
            "The term 'test' likely refers to an experimental or specific test airfoil with unique characteristics, "
            "often used in research and development settings. Such airfoils are typically used in wind tunnel testing "
            "or computational fluid dynamics (CFD) simulations to analyze various performance characteristics, allowing "
            "engineers to refine designs for efficiency or performance."
        ),
        "AG35": (
            "The AG35 airfoil is designed for agricultural aircraft, offering a good balance of lift and drag. This airfoil "
            "is commonly used in agricultural applications, such as crop dusters, where low-speed performance and stability "
            "are crucial for effective spraying and maneuverability in tight spaces."
        ),
        "MH32": (
            "The MH32 airfoil is known for its good lift-to-drag ratio and efficient performance at various angles of attack. "
            "It is used in sailplanes and other gliders for its excellent aerodynamic characteristics, allowing for long "
            "gliding distances and stable flight at low speeds. It can also be found in some UAV designs where efficiency is paramount."
        ),
        "E387": (
            "The E387 airfoil is a modified version of the Eppler airfoils, designed for low drag and high lift at low Reynolds numbers. "
            "This airfoil is often utilized in small UAVs, model aircraft, and slow-flying vehicles, where low-speed performance is critical. "
            "Its design helps improve lift during slow flight conditions, making it suitable for applications like aerial photography and surveillance."
        ),
        "RG15": (
            "The RG15 airfoil has a moderate camber and is known for its efficient lift characteristics at low to moderate speeds. "
            "It is commonly used in general aviation and UAV applications where stability and control are essential. "
            "The RG15 provides good performance in gliders, offering a good lift-to-drag ratio during slow flight."
        ),
        "NACA_2412": (
            "The NACA 2412 is a cambered airfoil with a maximum camber of 2% located at 40% of the chord length, designed for improved lift characteristics. "
            "This airfoil is widely used in general aviation aircraft, particularly in trainers and light aircraft. Its design offers good stall "
            "characteristics and predictable performance, making it ideal for flight training and recreational flying."
        ),
        "SELIG_S1223": (
            "The SELIG S1223 is a modern airfoil developed for high lift and low drag, featuring a supercritical design. "
            "This airfoil is commonly found in sailplanes and high-performance gliders, where maximizing lift at low speeds is essential. "
            "Its aerodynamic efficiency makes it ideal for long-distance gliding and competition flying."
        ),
    }
    
    return descriptions.get(airfoil, "Description not available for the given airfoil.")
</"file: python/utils.py">

<"file: python/create_io.py">import os

def list_files_by_folder(directory):
    """
    This function takes a directory path as input and returns a dictionary where each folder in the 
    directory is a key and its files are the values. Files directly in the root directory will be listed under 'root_files'.
    
    :param directory: Path to the directory (str)
    :return: A dictionary with folders as keys and lists of files as values
    """
    result = {"root_files": []}

    directory = os.getcwd() + "/" + directory
    
    # Check if the directory exists
    if os.path.exists(directory):
        # Iterate over the contents of the directory
        for item in os.listdir(directory):
            item_path = os.path.join(directory, item)
            
            # If it's a directory, create a key and list its files
            if os.path.isdir(item_path):
                result[item] = []
                for sub_item in os.listdir(item_path):
                    sub_item_path = os.path.join(item_path, sub_item)
                    if os.path.isfile(sub_item_path):
                        result[item].append(sub_item)
            
            # If it's a file in the root directory, add it to 'root_files'
            elif os.path.isfile(item_path):
                result["root_files"].append(item)
    else:
        return f"The directory '{directory}' does not exist."

    return result

def list_files_recursively(directory):
    """
    This function takes a directory path as input and returns a dictionary where each folder (including subdirectories)
    is a key, and its files are the values. It traverses all subdirectories recursively.
    
    :param directory: Path to the directory (str)
    :return: A dictionary with folders (and their subdirectories) as keys and lists of files as values
    """
    result = {}

    directory = os.getcwd() + "/users/" + directory

    # Check if the directory exists
    if os.path.exists(directory):
        # Walk through the directory and its subdirectories
        for root, dirs, files in os.walk(directory):
            # For each directory, get the relative path and its files
            relative_path = os.path.relpath(root, directory)
            if relative_path == '.':  # Root directory case
                result["root"] = files
            else:
                result[relative_path] = files
    else:
        return f"The directory '{directory}' does not exist."

    return result

if __name__ == "__main__":
    # Example usage
    directory = 'user001'  # Provide the path to the "user001" folder here
    print(list_files_by_folder(directory))
</"file: python/create_io.py">

<"file: python/users/younessf31/app.py">from flask import Flask, jsonify, request, send_file
from flask_cors import CORS
from create_io import list_files_by_folder, list_files_recursively
from utils import list_airfoils, get_airfoil_stl, get_airfoil_dat, get_airfoil_step, get_airfoil_screenshot, create_geometry, create_mesh, create_screenshot, get_airfoil_description
from airfoilGen.generator import naca as nacaFunction

# login stuff
from my_secrets.secret_key_ import my_secret_key
from flask_login import LoginManager
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin, LoginManager, login_user, logout_user, login_required

from flask_migrate import Migrate

import io

app = Flask(__name__)


# sql alchemy stuff
app.secret_key = my_secret_key #TO BE MODIFIED
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///dynamicas.db'  # Use SQLite for simplicity
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
migrate = Migrate(app, db)

# cur folder
from os import path
__my_dirname = path.dirname(path.realpath(__file__)) 


# adding login functionality
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = "login"

# Enable CORS for all origins
CORS(app, origins="http://localhost:3000")




from flask import flash, request
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin, login_required, logout_user, current_user

from werkzeug.security import generate_password_hash, check_password_hash

# Define Project model
class Project(db.Model):
    __tablename__ = 'projects'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(500))
    foldername = db.Column(db.String(100))
    
    # Foreign key linking to the User model
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

class User(UserMixin, db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    last_name = db.Column(db.String(120), nullable=False)
    first_name = db.Column(db.String(120), nullable=False)
    email = db.Column(db.String(120), nullable=False, default="example@email.com")
    pass_hash = db.Column(db.String(120), nullable=False)
    avatar = db.Column(db.String(120), unique=True, nullable=False)
    
    projects = db.relationship('Project', backref='owner', lazy=True)

    def set_password(self, password):
        self.pass_hash = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.pass_hash, password)
    
    def __repr__(self):
        return f'<User {self.avatar}>'


#login for users
@login_manager.user_loader
def load_user(userid):
    # hardcoded for now
    # print(User.query.get(user.id))
    return User.query.get(userid)

def _login_helper(avatar, password):
    user = User.query.filter_by(avatar=avatar).first()
    # Check if the user exists and the password is correct
    if user and user.check_password(password):
        # load_user(user)
        login_user(user)
        return True
    return False

# Routes
@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        avatar = request.json["avatar"]
        lastname = request.json["lastname"]
        firstname = request.json["firstname"]
        password = request.json["password"]
        email = request.json["email"]

        # Check if username already exists
        if User.query.filter_by(avatar=avatar).first():
            if "firebase" in request.json:
                if _login_helper(avatar, password):
                    return {"success": True}
            flash("Username already taken!")
            return {"error": "avatar taken", "success": False}

        # Create a new user and save to database
        new_user = User(avatar=avatar, first_name=firstname, last_name=lastname, email=email)
        new_user.set_password(password)
        db.session.add(new_user)
        db.session.commit()
        import os
        if not os.path.exists(f'{__my_dirname}/users/{avatar}'):
            os.makedirs(f'{__my_dirname}/users/{avatar}')
        flash("Registered successfully!")
        if "firebase" in request.json:
            _login_helper(avatar, password)
        return {"success": True}

    return {"error": "Post.", "success": False}



@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        avatar = request.json["avatar"]
        password = request.json["password"]
        
        if _login_helper(avatar, password):
            flash("Logged in successfully!")
            return {"success": True}
        else:
            flash("Invalid username or password")
            return {"success": False, "error": "invalid coordinates"}
    return {"success": False, "error": "invalid method"}

@app.route("/dashboard")
@login_required
def dashboard():
    return f"Hello, {current_user.last_name}! Welcome to your dashboard."

@app.route("/logout")
@login_required
def logout():
    logout_user()
    flash("You have been logged out.")
    return {"success": True}

# Teardown context to close database session
@app.teardown_appcontext
def shutdown_session(exception=None):
    db.session.remove()  # Properly close and release any sessions
    if db.engine:
        db.engine.dispose()  # Dispose of engine connections if necessary

@app.route('/', methods=['GET'])
def home():
    """Home for all airfoils."""
    return jsonify("Home for all airfoils")

@app.route('/airfoils', methods=['GET'])
def get_airfoils():
    """List all airfoils."""
    airfoils = list_airfoils()
    return jsonify(airfoils)

@app.route('/airfoil/<string:airfoil>/stl', methods=['GET'])
def get_stl(airfoil):
    """Get the STL file content for a specific airfoil."""
    try:
        stl_content = get_airfoil_stl(airfoil)
        return send_file(
            io.BytesIO(stl_content),  # Use BytesIO to wrap the bytes
            mimetype='application/sla',
            as_attachment=True,
            download_name=f'{airfoil}.stl'
        )
    except FileNotFoundError:
        return jsonify({"error": "STL file not found"}), 404

@app.route('/airfoil/<string:airfoil>/dat', methods=['GET'])
def get_dat(airfoil):
    """Get the DAT file content for a specific airfoil."""
    try:
        dat_content = get_airfoil_dat(airfoil)
        return send_file(
            io.BytesIO(dat_content),  # Use BytesIO to wrap the bytes
            mimetype='application/text',
            as_attachment=True,
            download_name=f'{airfoil}.dat'
        )
    except FileNotFoundError:
        return jsonify({"error": "STL file not found"}), 404

@app.route('/airfoil/<string:airfoil>/step', methods=['GET'])
def get_step(airfoil):
    """Get the STEP file content for a specific airfoil."""
    try:
        step_content = get_airfoil_step(airfoil)
        return send_file(
            io.BytesIO(step_content),  # Use BytesIO to wrap the bytes
            mimetype='application/sla',
            as_attachment=True,
            download_name=f'{airfoil}.step'
        )
    except FileNotFoundError:
        return jsonify({"error": "STEP file not found"}), 404

@app.route('/airfoil/<string:airfoil>/screenshot', methods=['GET'])
def get_screenshot(airfoil):
    """Get the screenshot for a specific airfoil."""
    try:
        screenshot = get_airfoil_screenshot(airfoil)
        return send_file(
            io.BytesIO(screenshot),
            mimetype='image/png',
            as_attachment=True,
            download_name=f'{airfoil}.png'
        )
    except FileNotFoundError:
        return jsonify({"error": "Screenshot not found"}), 404

@app.route('/airfoil/<string:airfoil>/description', methods=['GET'])
def get_description(airfoil):
    """Get the description for a specific airfoil."""
    try:
        return jsonify({"description": get_airfoil_description(airfoil)})
    except Exception as e:
        return jsonify({"error": "Desc not found", "description": ""}), 404


@app.route('/airfoil/<string:airfoil>/geometry', methods=['POST'])
def create_geo(airfoil):
    """Create geometry for a specific airfoil."""
    method = request.json.get('method')
    wingspan = request.json.get('wingspan')
    params = request.json.get('params')

    if not method or not wingspan or not params:
        return jsonify({"error": "Invalid parameters"}), 400

    try:
        geometry = create_geometry(airfoil, method, wingspan, params)
        return jsonify({"message": "Geometry created"}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/airfoil/<string:airfoil>/mesh', methods=['POST'])
def create_airfoil_mesh(airfoil):
    """Create mesh for a specific airfoil."""
    try:
        mesh_success = create_mesh(airfoil)
        return jsonify({"message": "Mesh created", "success": mesh_success}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/airfoil/<string:airfoil>/screenshot/create', methods=['POST'])
def take_screenshot(airfoil):
    """Get the screenshot for a specific airfoil."""
    try:
        screenshot = get_airfoil_screenshot(airfoil)
        return send_file(
            io.BytesIO(screenshot),  # Use BytesIO to wrap the bytes
            mimetype='image/png',
            as_attachment=True,
            download_name=f'{airfoil}.png'
        )
    except FileNotFoundError:
        return jsonify({"error": "Screenshot not found"}), 404

@app.route('/user/<string:username>/dir', methods=['GET'])
def get_dir(username):
    """Will display dir of the user"""
    try:
        return jsonify(list_files_recursively(username))
    except Exception as e:
        return jsonify({"error": "Error in dir", "description": e}), 404 

@app.route('/naca/<string:naca>/<int:n>/txt', methods=['GET'])
@login_required
def getNacaAirfoilTxt(naca, n):
    """
        Will generate and fetch the NACA dat file
    """
    try:
        try:
            dat = nacaFunction(naca, n, save=False)
        except Exception as e:
            return jsonify({"success": False, "message": "No naca function."})
        return jsonify({"success": True, "data": dat})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/naca/<string:naca>/<int:n>/dat', methods=['GET'])
def getNacaAirfoilDat(naca, n):
    """
        Will generate and fetch the NACA dat file
    """
    try:
        try:
            dat = nacaFunction(naca, n, save=False)
        except Exception as e:
            return jsonify({"success": False, "message": "No naca function."})
        dat_content = '\n'.join(f"{x}   {y}" for x, y in zip(dat[0],dat[1]))
        
        dat_io = io.BytesIO()
        dat_io.write(dat_content.encode('utf-8'))
        dat_io.seek(0)

        return send_file(
            dat_io,
            mimetype='application/txt',
            as_attachment=True,
            download_name=f'NACA_{naca}_{n}.dat'
        )
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@app.route('/naca/<string:naca>/<int:n>/png', methods=['GET'])
def getNacaAirfoilImage(naca, n):
    """
        Will generate and fetch the NACA dat file
    """
    try:
        try:
            dat = nacaFunction(naca, n, save=False, uploadImage=True)
        except Exception as e:
            return jsonify({"success": False, "message": "No naca function."})
        dat.seek(0)
        return send_file(
            dat,
            mimetype='image/png',
            as_attachment=True,
            download_name=f'NACA_{naca}_{n}.png'
        )
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

@login_required
@app.route('/airfoil/<string:airfoil>', methods=['POST'])
def setAirfoil(airfoil):
    """
        Will set airfoil for later exploitation
    """
    try:
        lines = []
        try:
            for line in airfoil.split('\n'):
                lines.push((line.split(' ')[0], lines.split(' ')[1]))
        except Exception as e:
            return jsonify({"success": False, "message": "Invalid airfoil."})
        


        # SETTING AIRFOIL FOR THIS USER

        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "message": e.args[0]})

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
</"file: python/users/younessf31/app.py">

<"file: python/users/younessf31/user.py"># from flask import flash, request
# from flask_sqlalchemy import SQLAlchemy
# from flask_login import UserMixin, login_required, logout_user, current_user
# from app import db, login_manager, app
# from werkzeug.security import generate_password_hash, check_password_hash

# class User(UserMixin):
#     __tablename__ = "users"
#     id = db.Column(db.Integer, primary_key=True)
#     last_name = db.Column(db.String(120), nullable=False)
#     first_name = db.Column(db.String(120), nullable=False)
#     pass_hash = db.Column(db.String(120), nullable=False)
#     avatar = db.Column(db.String(120), unique=True, nullable=False)

#     def set_password(self, password):
#         self.pass_hash = generate_password_hash(password)
    
#     def check_password(self, password):
#         return check_password_hash(self.pass_hash, password)
    
#     def __repr__(self):
#         return f'<User {self.avatar}>'


# #login for users
# @login_manager.user_loader
# def load_user(user_id):
#     # hardcoded for now
#     return User.query.get(int(user_id))

# # Routes
# @app.route("/register", methods=["GET", "POST"])
# def register():
#     if request.method == "POST":
#         avatar = request.form.get("avatar")
#         lastname = request.form.get("lastname")
#         firstname = request.form.get("firstname")
#         password = request.form.get("password")
        
#         # Check if username already exists
#         if User.query.filter_by(avatar=avatar).first():
#             flash("Username already taken!")
#             return {"error": "avatar taken", "success": False}

#         # Create a new user and save to database
#         new_user = User(avatar=avatar, firstname=firstname, lastname=lastname)
#         new_user.set_password(password)
#         db.session.add(new_user)
#         db.session.commit()
#         flash("Registered successfully!")
#         return {"success": True}

#     return {"error": "Post.", "success": False}

# @app.route("/login", methods=["GET", "POST"])
# def login():
#     if request.method == "POST":
#         avatar = request.form.get("avatar")
#         lastname = request.form.get("lastname")
#         firstname = request.form.get("firstname")
#         password = request.form.get("password")
        
#         user = User.query.filter_by(avatar=avatar).first()

#         # Check if the user exists and the password is correct
#         if user and user.check_password(password):
#             load_user(user)
#             flash("Logged in successfully!")
#             return {"success": True}
#         flash("Invalid username or password")
#         return {"success": False, "error": "invalid coordinates"}
        
#     return {"success": False, "error": "invalid method"}

# @app.route("/dashboard")
# @login_required
# def dashboard():
#     return f"Hello, {current_user.username}! Welcome to your dashboard."

# @app.route("/logout")
# @login_required
# def logout():
#     logout_user()
#     flash("You have been logged out.")
#     return {"success": True}
</"file: python/users/younessf31/user.py">

<"file: python/airfoilGen/generator.py">"""
Python 2 and 3 code to generate 4 and 5 digit NACA profiles

The NACA airfoils are airfoil shapes for aircraft wings developed
by the National Advisory Committee for Aeronautics (NACA).
The shape of the NACA airfoils is described using a series of
digits following the word "NACA". The parameters in the numerical
code can be entered into equations to precisely generate the
cross-section of the airfoil and calculate its properties.
    https://en.wikipedia.org/wiki/NACA_airfoil

Pots of the Matlab code available here:
    http://www.mathworks.com/matlabcentral/fileexchange/19915-naca-4-digit-airfoil-generator
    http://www.mathworks.com/matlabcentral/fileexchange/23241-naca-5-digit-airfoil-generator

Copyright (C) 2011 by Dirk Gorissen <dgorissen@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

from math import cos, sin, tan, radians
from math import atan
from math import pi
from math import pow
from math import sqrt

def correctPath(scriptfile, file):
    from os.path import dirname, realpath
    file_name = dirname(realpath(scriptfile)) + '/' + file
    return file_name

def linspace(start,stop,np):
    """
    Emulate Matlab linspace
    """
    return [start+(stop-start)*i/(np-1) for i in range(np)]

def interpolate(xa,ya,queryPoints):
    """
    A cubic spline interpolation on a given set of points (x,y)
    Recalculates everything on every call which is far from efficient but does the job for now
    should eventually be replaced by an external helper class
    """

    # PreCompute() from Paint Mono which in turn adapted:
    # NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING
    # ISBN 0-521-43108-5, page 113, section 3.3.
    # http://paint-mono.googlecode.com/svn/trunk/src/PdnLib/SplineInterpolator.cs

    #number of points
    n = len(xa)
    u, y2 = [0]*n, [0]*n

    for i in range(1,n-1):

        # This is the decomposition loop of the tridiagonal algorithm.
        # y2 and u are used for temporary storage of the decomposed factors.

        wx = xa[i + 1] - xa[i - 1]
        sig = (xa[i] - xa[i - 1]) / wx
        p = sig * y2[i - 1] + 2.0

        y2[i] = (sig - 1.0) / p

        ddydx = (ya[i + 1] - ya[i]) / (xa[i + 1] - xa[i]) - (ya[i] - ya[i - 1]) / (xa[i] - xa[i - 1])

        u[i] = (6.0 * ddydx / wx - sig * u[i - 1]) / p


    y2[n - 1] = 0

    # This is the backsubstitution loop of the tridiagonal algorithm
    #((int i = n - 2; i >= 0; --i):
    for i in range(n-2,-1,-1):
        y2[i] = y2[i] * y2[i + 1] + u[i]

    # interpolate() adapted from Paint Mono which in turn adapted:
    # NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING
    # ISBN 0-521-43108-5, page 113, section 3.3.
    # http://paint-mono.googlecode.com/svn/trunk/src/PdnLib/SplineInterpolator.cs

    results = [0]*n

    #loop over all query points
    for i in range(len(queryPoints)):
        # bisection. This is optimal if sequential calls to this
        # routine are at random values of x. If sequential calls
        # are in order, and closely spaced, one would do better
        # to store previous values of klo and khi and test if

        klo = 0
        khi = n - 1

        while (khi - klo > 1):
            k = (khi + klo) >> 1
            if (xa[k] > queryPoints[i]):
                khi = k
            else:
                klo = k

        h = xa[khi] - xa[klo]
        a = (xa[khi] - queryPoints[i]) / h
        b = (queryPoints[i] - xa[klo]) / h

        # Cubic spline polynomial is now evaluated.
        results[i] = a * ya[klo] + b * ya[khi] + ((a * a * a - a) * y2[klo] + (b * b * b - b) * y2[khi]) * (h * h) / 6.0

    return results

class Display(object):    
    def __init__(self, number="2412"):
        self.number = number
        import matplotlib.pyplot as plt
        self.plt = plt
        self.h = []
        self.label = []
        self.fig, self.ax = self.plt.subplots()
        self.plt.axis('equal')
        self.plt.xlabel('x')
        self.plt.ylabel('y')
        self.ax.grid(True)
    def plot(self, X, Y,label=''):
        h, = self.plt.plot(X, Y, '-', linewidth = 1)
        self.h.append(h)
        self.label.append(label)
    def show(self):
        # self.plt.axis((-0.1,1.1) + self.plt.axis()[2:])
        self.plt.axis([0, 1, -0.4, 0.4])
        # self.plt.axis((-0.1,1.1) + (0.4))
        self.plt.title("NACA " + self.number)
        self.ax.legend(self.h, self.label)
        # self.plt.show()
    def save(self):
        save_path = correctPath(__file__ , "NACA" + self.number + ".png")
        # Save the plot as an image
        self.plt.savefig(save_path, format='png', dpi=300)
        self.plt.close()
    def tobytes(self):
        from io import BytesIO
        img_io = BytesIO()
        self.plt.savefig(img_io, format='png', dpi=300)
        return img_io

def naca4(number, n, finite_TE = False, \
          half_cosine_spacing = False):
    """
    Returns 2*n+1 points in [0 1] for the given 4 digit NACA number string
    """

    m = float(number[0])/100.0
    p = float(number[1])/10.0
    t = float(number[2:])/100.0

    a0 = +0.2969
    a1 = -0.1260
    a2 = -0.3516
    a3 = +0.2843

    if finite_TE:
        a4 = -0.1015 # For finite thick TE
    else:
        a4 = -0.1036 # For zero thick TE

    if half_cosine_spacing:
        beta = linspace(0.0,pi,n+1)
        x = [(0.5*(1.0-cos(xx))) for xx in beta]  # Half cosine based spacing
    else:
        x = linspace(0.0,1.0,n+1)

    yt = [5*t*(a0*sqrt(xx)+a1*xx+a2*pow(xx,2)+a3*pow(xx,3)+a4*pow(xx,4)) for xx in x]

    xc1 = [xx for xx in x if xx <= p]
    xc2 = [xx for xx in x if xx > p]

    if p == 0:
        xu = x
        yu = yt

        xl = x
        yl = [-xx for xx in yt]

        xc = xc1 + xc2
        zc = [0]*len(xc)
    else:
        yc1 = [m/pow(p,2)*xx*(2*p-xx) for xx in xc1]
        yc2 = [m/pow(1-p,2)*(1-2*p+xx)*(1-xx) for xx in xc2]
        zc = yc1 + yc2

        dyc1_dx = [m/pow(p,2)*(2*p-2*xx) for xx in xc1]
        dyc2_dx = [m/pow(1-p,2)*(2*p-2*xx) for xx in xc2]
        dyc_dx = dyc1_dx + dyc2_dx

        theta = [atan(xx) for xx in dyc_dx]

        xu = [xx - yy * sin(zz) for xx,yy,zz in zip(x,yt,theta)]
        yu = [xx + yy * cos(zz) for xx,yy,zz in zip(zc,yt,theta)]

        xl = [xx + yy * sin(zz) for xx,yy,zz in zip(x,yt,theta)]
        yl = [xx - yy * cos(zz) for xx,yy,zz in zip(zc,yt,theta)]

    X = xu[::-1] + xl[1:]
    Z = yu[::-1] + yl[1:]
    
    # print(f"Generated {file_name} with {len(X)} coordinates.")

    return X,Z

def naca5(number, n, finite_TE = False, half_cosine_spacing = False, \
          ):
    """
    Returns 2*n+1 points in [0 1] for the given 5 digit NACA number string
    """

    naca1 = int(number[0])
    naca23 = int(number[1:3])
    naca45 = int(number[3:])

    cld = naca1*(3.0/2.0)/10.0
    p = 0.5*naca23/100.0
    t = naca45/100.0

    a0 = +0.2969
    a1 = -0.1260
    a2 = -0.3516
    a3 = +0.2843

    if finite_TE:
        a4 = -0.1015 # For finite thickness trailing edge
    else:
        a4 = -0.1036  # For zero thickness trailing edge

    if half_cosine_spacing:
        beta = linspace(0.0,pi,n+1)
        x = [(0.5*(1.0-cos(x))) for x in beta]  # Half cosine based spacing
    else:
        x = linspace(0.0,1.0,n+1)

    yt = [5*t*(a0*sqrt(xx)+a1*xx+a2*pow(xx,2)+a3*pow(xx,3)+a4*pow(xx,4)) for xx in x]

    P = [0.05,0.1,0.15,0.2,0.25]
    M = [0.0580,0.1260,0.2025,0.2900,0.3910]
    K = [361.4,51.64,15.957,6.643,3.230]

    m = interpolate(P,M,[p])[0]
    k1 = interpolate(M,K,[m])[0]

    xc1 = [xx for xx in x if xx <= p]
    xc2 = [xx for xx in x if xx > p]
    xc = xc1 + xc2

    if p == 0:
        xu = x
        yu = yt

        xl = x
        yl = [-x for x in yt]

        zc = [0]*len(xc)
    else:
        yc1 = [k1/6.0*(pow(xx,3)-3*m*pow(xx,2)+ pow(m,2)*(3-m)*xx) for xx in xc1]
        yc2 = [k1/6.0*pow(m,3)*(1-xx) for xx in xc2]
        zc  = [cld/0.3 * xx for xx in yc1 + yc2]

        dyc1_dx = [cld/0.3*(1.0/6.0)*k1*(3*pow(xx,2)-6*m*xx+pow(m,2)*(3-m)) for xx in xc1]
        dyc2_dx = [cld/0.3*-(1.0/6.0)*k1*pow(m,3)]*len(xc2)

        dyc_dx = dyc1_dx + dyc2_dx
        theta = [atan(xx) for xx in dyc_dx]

        xu = [xx - yy * sin(zz) for xx,yy,zz in zip(x,yt,theta)]
        yu = [xx + yy * cos(zz) for xx,yy,zz in zip(zc,yt,theta)]

        xl = [xx + yy * sin(zz) for xx,yy,zz in zip(x,yt,theta)]
        yl = [xx - yy * cos(zz) for xx,yy,zz in zip(zc,yt,theta)]


    X = xu[::-1] + xl[1:]
    Z = yu[::-1] + yl[1:]

    return X,Z


def rotate_points(p, angle_deg):
    x = p[0]
    y = p[1]
    angle_deg = -angle_deg
    angle_rad = radians(angle_deg)
    center_x = sum(x) / len(x)
    center_y = sum(y) / len(y)
    
    rotated_x = []
    rotated_y = []

    for i in range(len(x)):
        translated_x = x[i] - center_x
        translated_y = y[i] - center_y
        
        rotated_x_val = translated_x * cos(angle_rad) - translated_y * sin(angle_rad)
        rotated_y_val = translated_x * sin(angle_rad) + translated_y * cos(angle_rad)
        
        final_x = rotated_x_val + center_x
        final_y = rotated_y_val + center_y
        
        rotated_x.append(final_x)
        rotated_y.append(final_y)
    
    return rotated_x, rotated_y

def naca(number, n, finite_TE = False, half_cosine_spacing = False, rotation = 0,\
            file_name = "", save=False, uploadImage=False):
    if len(number) in [4, 5]:
        points = naca4(number, n, finite_TE, half_cosine_spacing) \
            if len(number) == 4 else \
                naca5(number, n, finite_TE, half_cosine_spacing)
        if rotation != 0:
            points = rotate_points(points, rotation)
        # file_name = "", save=False, uploadImage=False
        naca_code = number
        X,Z = points
        if save:
            # Set the file name if not provided
            if not file_name:
                file_name = f"NACA_{naca_code}.dat"

            file_name = correctPath(__file__, file_name)

            # Write to .dat file
            with open(file_name, 'w') as f:
                f.write(f"# NACA {naca_code} airfoil coordinates\n")
                for x, y in zip(X, Z):
                    f.write(f"{x:.6f} {y:.6f}\n")
        if uploadImage:
            d = Display(number=number)
            d.plot(X, Z, f"NACA {number}({n} points)")
            d.show()
            return d.tobytes()
        return points
    else:
        raise Exception

def demo(profNaca = ['0009', '2414', '6409'], nPoints = 240, finite_TE = False, half_cosine_spacing = False):
    #profNaca = ['0009', '0012', '2414', '2415', '6409' , '0006', '0008', '0010', '0012', '0015']
    for i,p in enumerate(profNaca):
        d = Display(p)
        X,Y = naca(p, nPoints, finite_TE, half_cosine_spacing)
        d.plot(X, Y, p)
        d.show()
        d.save()
    d.show()

def main():
    import os
    from argparse import ArgumentParser, RawDescriptionHelpFormatter
    from textwrap import dedent
    parser = ArgumentParser( \
        formatter_class = RawDescriptionHelpFormatter, \
        description = dedent('''\
            Script to create NACA4 and NACA5 profiles
            If no argument is provided, a demo is displayed.
            '''), \
        epilog = dedent('''\
            Examples:
                Get help
                    python {0} -h
                Generate points for NACA profile 2412
                    python {0} -p 2412
                Generate points for NACA profile 2412 with 300 points
                    python {0} -p 2412 -n 300
                Generate points for NACA profile 2412 and display the result
                    python {0} -p 2412 -d
                Generate points for NACA profile 2412 with smooth points spacing and display the result
                    python {0} -p 2412 -d -s
                Generate points for several profiles
                    python {0} -p "2412 23112" -d -s     
                Generate points and rotate with respect to an attack angle
                    python {0} -p "2412 23112" -d -s -r 20
            '''.format(os.path.basename(__file__))))
    parser.add_argument('-p','--profile', type = str, \
                        help = 'Profile name or set of profiles names separated by spaces. Example: "0009", "0009 2414 6409"')
    parser.add_argument('-n','--nbPoints', type = int, default = 120, \
                        help = 'Number of points used to discretize chord. Profile will have 2*nbPoints+1 dots. Default is 120.')
    parser.add_argument('-s','--half_cosine_spacing', action = 'store_true', \
                        help = 'Half cosine based spacing, instead of a linear spacing of chord. '\
                               'This option is recommended to have a smooth leading edge.')
    parser.add_argument('-f','--finite_TE', action = 'store_true', \
                        help = 'Finite thickness trailing edge. Default is False, corresponding to zero thickness trailing edge.')
    parser.add_argument('-d','--display', action = 'store_true', \
                        help = 'Flag used to display the profile(s).')
    parser.add_argument('-r','--rotate', type = int, default = 0,\
                        help = 'Adds an angle of attack rotation.')
    args = parser.parse_args()
    if args.profile is None:
        demo(nPoints = args.nbPoints, finite_TE = args.finite_TE, half_cosine_spacing = args.half_cosine_spacing)
    else:
        if args.display:
            d = Display()
            for p in args.profile.split(' '):
                X,Y = naca(p, args.nbPoints, args.finite_TE, args.half_cosine_spacing, args.rotate)
                d.plot(X, Y, p)
            d.show()
        else:
            for p in args.profile.split(' '):
                X,Y = naca(p, args.nbPoints, args.finite_TE, args.half_cosine_spacing, args.rotate)
                for x,y in zip(X,Y):
                    print(x,y)

if __name__ == "__main__":
    main()</"file: python/airfoilGen/generator.py">

<"file: python/my_secrets/secret_key_.py">my_secret_key = "MY_SECRET_KEY"</"file: python/my_secrets/secret_key_.py">

<"file: python/my_secrets/__init__.py"></"file: python/my_secrets/__init__.py">

<"file: python/create_geo_airfoil.py">from base import point, airfoilFile
from typing import List
# import cadquery as cq
import numpy as np

cq = 0

def create_geometry_from_file(points_: airfoilFile, wingspan: float, profiling_method: str, params: List[float], output: str = "airfoil_extruded"):
    # points_geo = [pt.to_point() for pt in points]
    points : List[tuple] = points_.arr

    # Create a wire (outline) from the 2D points
    airfoil_wire = cq.Workplane("XY").spline(points).close()

    if profiling_method == "simple_extrusion":
        # Extrude the 2D wire along the z-axis to create a 3D shape
        airfoil_3d = airfoil_wire.extrude(wingspan)
    
    elif profiling_method == "polynomial_sweep":
        # Define a polynomial path for sweeping the airfoil along
        # Example: y = ax^2 + bx + c
        # a, b, c = params  # Polynomial coefficients passed in 'params'
        # num_points = 100  # Number of points on the sweep path
        # path_points = [(x, a*x**(1/2)) for x in np.linspace(0, wingspan, num_points)]
        
        # Create the path from the calculated polynomial points
        # path_wire = cq.Workplane("XZ").spline(path_points)

        # Sweep the 2D airfoil wire along the polynomial path
        # airfoil_3d = airfoil_wire.sweep(path_wire)
        
        points_.scale(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_straight_trailing":
        points_.scaleAndRecenterAtTrailingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "straight_leading_tappered_trailing":
        points_.scaleAndRecenterAtLeadingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_tappered_trailing":
        points_.scaleAndRecenterAtBothEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)



    # Export the 3D model to an STL file
    path_wire_far.val().exportStl(output + ".stl")
    path_wire_far.val().exportStep(output + ".step")

    print("STL file created: airfoil_extruded.stl")

    return path_wire_far


if __name__ == "__main__":
    from airfoil_shape import vectors
    from base import airfoilFile
    a = airfoilFile("naca2412.dat")
    a.recenterX(-0.5)
    a.scale(1000)

    # create_geometry_from_file(a, 1000, "simple_extrusion", [])
    a_ = 100
    b = 0.02
    c = 0.01
    #res = create_geometry_from_file(a, 10000, "polynomial_sweep", [])
    # res = create_geometry_from_file(a, 5000, "tappered_leading_tappered_trailing", [])
</"file: python/create_geo_airfoil.py">

<"file: python/users/younessf31/create_geo_airfoil.py">from base import point, airfoilFile
from typing import List
# import cadquery as cq
import numpy as np

cq = 0

def create_geometry_from_file(points_: airfoilFile, wingspan: float, profiling_method: str, params: List[float], output: str = "airfoil_extruded"):
    # points_geo = [pt.to_point() for pt in points]
    points : List[tuple] = points_.arr

    # Create a wire (outline) from the 2D points
    airfoil_wire = cq.Workplane("XY").spline(points).close()

    if profiling_method == "simple_extrusion":
        # Extrude the 2D wire along the z-axis to create a 3D shape
        airfoil_3d = airfoil_wire.extrude(wingspan)
    
    elif profiling_method == "polynomial_sweep":
        # Define a polynomial path for sweeping the airfoil along
        # Example: y = ax^2 + bx + c
        # a, b, c = params  # Polynomial coefficients passed in 'params'
        # num_points = 100  # Number of points on the sweep path
        # path_points = [(x, a*x**(1/2)) for x in np.linspace(0, wingspan, num_points)]
        
        # Create the path from the calculated polynomial points
        # path_wire = cq.Workplane("XZ").spline(path_points)

        # Sweep the 2D airfoil wire along the polynomial path
        # airfoil_3d = airfoil_wire.sweep(path_wire)
        
        points_.scale(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_straight_trailing":
        points_.scaleAndRecenterAtTrailingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "straight_leading_tappered_trailing":
        points_.scaleAndRecenterAtLeadingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_tappered_trailing":
        points_.scaleAndRecenterAtBothEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)



    # Export the 3D model to an STL file
    path_wire_far.val().exportStl(output + ".stl")
    path_wire_far.val().exportStep(output + ".step")

    print("STL file created: airfoil_extruded.stl")

    return path_wire_far


if __name__ == "__main__":
    from airfoil_shape import vectors
    from base import airfoilFile
    a = airfoilFile("naca2412.dat")
    a.recenterX(-0.5)
    a.scale(1000)

    # create_geometry_from_file(a, 1000, "simple_extrusion", [])
    a_ = 100
    b = 0.02
    c = 0.01
    #res = create_geometry_from_file(a, 10000, "polynomial_sweep", [])
    # res = create_geometry_from_file(a, 5000, "tappered_leading_tappered_trailing", [])
</"file: python/users/younessf31/create_geo_airfoil.py">

<"file: python/create_geo_airfoil_test.py">from base import point, airfoilFile
from typing import List
# import cadquery as cq
import numpy as np

cq = 0

def create_geometry_from_file(points_: airfoilFile, wingspan: float, profiling_method: str, params: List[float]):
    # points_geo = [pt.to_point() for pt in points]
    points : List[tuple] = points_.arr

    # Create a wire (outline) from the 2D points
    airfoil_wire = cq.Workplane("XY").spline(points).close()
    
    path_wire_far = None

    if profiling_method == "simple_extrusion":
        # Extrude the 2D wire along the z-axis to create a 3D shape
        airfoil_3d = airfoil_wire.extrude(wingspan)
    
    elif profiling_method == "polynomial_sweep":
        # Define a polynomial path for sweeping the airfoil along
        # Example: y = ax^2 + bx + c
        # a, b, c = params  # Polynomial coefficients passed in 'params'
        # num_points = 100  # Number of points on the sweep path
        # path_points = [(x, a*x**(1/2)) for x in np.linspace(0, wingspan, num_points)]
        
        # Create the path from the calculated polynomial points
        # path_wire = cq.Workplane("XZ").spline(path_points)

        # Sweep the 2D airfoil wire along the polynomial path
        # airfoil_3d = airfoil_wire.sweep(path_wire)
        
        points_.scale(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_straight_trailing":
        points_.scaleAndRecenterAtTrailingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "straight_leading_tappered_trailing":
        points_.scaleAndRecenterAtLeadingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_tappered_trailing":
        points_.scaleAndRecenterAtBothEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    print("STL file created: airfoil_extruded.stl")

    return path_wire_far



from airfoil_shape import vectors
from base import airfoilFile
a = airfoilFile("naca2412.dat")
a.recenterX(-0.5)
a.scale(1000)

# create_geometry_from_file(a, 1000, "simple_extrusion", [])
a_ = 100
b = 0.02
c = 0.01
#res = create_geometry_from_file(a, 10000, "polynomial_sweep", [])
res = create_geometry_from_file(a, 5000, "tappered_leading_tappered_trailing", [])
</"file: python/create_geo_airfoil_test.py">

<"file: python/users/younessf31/create_geo_airfoil_test.py">from base import point, airfoilFile
from typing import List
# import cadquery as cq
import numpy as np

cq = 0

def create_geometry_from_file(points_: airfoilFile, wingspan: float, profiling_method: str, params: List[float]):
    # points_geo = [pt.to_point() for pt in points]
    points : List[tuple] = points_.arr

    # Create a wire (outline) from the 2D points
    airfoil_wire = cq.Workplane("XY").spline(points).close()
    
    path_wire_far = None

    if profiling_method == "simple_extrusion":
        # Extrude the 2D wire along the z-axis to create a 3D shape
        airfoil_3d = airfoil_wire.extrude(wingspan)
    
    elif profiling_method == "polynomial_sweep":
        # Define a polynomial path for sweeping the airfoil along
        # Example: y = ax^2 + bx + c
        # a, b, c = params  # Polynomial coefficients passed in 'params'
        # num_points = 100  # Number of points on the sweep path
        # path_points = [(x, a*x**(1/2)) for x in np.linspace(0, wingspan, num_points)]
        
        # Create the path from the calculated polynomial points
        # path_wire = cq.Workplane("XZ").spline(path_points)

        # Sweep the 2D airfoil wire along the polynomial path
        # airfoil_3d = airfoil_wire.sweep(path_wire)
        
        points_.scale(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_straight_trailing":
        points_.scaleAndRecenterAtTrailingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "straight_leading_tappered_trailing":
        points_.scaleAndRecenterAtLeadingEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    elif profiling_method == "tappered_leading_tappered_trailing":
        points_.scaleAndRecenterAtBothEdge(0.7)
        path_wire_far = cq.Workplane("XZ").spline(points).close() \
                            .workplane(offset=wingspan).spline(points_.arr).close() \
                            .loft(combine=True)
    print("STL file created: airfoil_extruded.stl")

    return path_wire_far



from airfoil_shape import vectors
from base import airfoilFile
a = airfoilFile("naca2412.dat")
a.recenterX(-0.5)
a.scale(1000)

# create_geometry_from_file(a, 1000, "simple_extrusion", [])
a_ = 100
b = 0.02
c = 0.01
#res = create_geometry_from_file(a, 10000, "polynomial_sweep", [])
res = create_geometry_from_file(a, 5000, "tappered_leading_tappered_trailing", [])
</"file: python/users/younessf31/create_geo_airfoil_test.py">

<"file: python/AirfoilDatabase/airfoil_db/__init__.py">from .airfoil import Airfoil
from .exceptions import DatabaseBoundsError, CamberSolverNotConvergedError</"file: python/AirfoilDatabase/airfoil_db/__init__.py">

<"file: python/AirfoilDatabase/airfoil_db/airfoil.py">"""A class defining an airfoil."""

import math
import json
import copy
import os
import operator
import warnings

import matplotlib.pyplot as plt
import scipy.interpolate as interp
import subprocess as sp
import numpy as np

from .poly_fits import multivariablePolynomialFit, multivariablePolynomialFunction, autoPolyFit, multivariableRMS, multivariableR2
from .exceptions import DatabaseBoundsError, CamberSolverNotConvergedError, PolyFitBoundsError


class Airfoil:
    """A class defining an airfoil. If the airfoil geometry is defined using outline
    points, then when this class is initialized, a solver will be automatically
    run to determine the camber line and thickness distribution of the airfoil.
    The parameters "camber_relaxation", "le_loc", and "camber_termination_tol" then
    have bearing on this solver.

    When using the member methods get_CL, get_CD, get_Cm, get_CLa, get_CLM, get_CLRe,
    and get_aL0, the default parameters are dependent upon the type of airfoil.

    For all airfoil types except 'functional', 'alpha', 'trailing_flap_deflection',
    and 'trailing_flap_fraction' default to 0.0.

    For 'functional' airfoils, the defaults are specified by the user.

    For 'linear' airfoils, 'Mach' and 'Rey' have no effect on computations.

    For 'database' airfoils, 'Mach' and 'Rey' default to the average value in the database,
    if the database is dependent on that variable. Otherwise, they default to the value
    specified as constant when the database was generated.

    For 'poly_fit' airfoils, 'Mach' and 'Rey' default to the values given in the fit file.
    If export_polynomial_fits() is used, these values are the same as those for the 
    'database' type.

    Parameters
    ----------
    name : str
        Name of the airfoil.

    airfoil_input : dict or str
        Dictionary or path to JSON object describing the airfoil.

    verbose : bool, optional
        Whether to display information on the progress of parameterizing the geometry
        for an airfoil defined by a set of outline points. Defaults to False.

    camber_relaxation : float, optional
        A value between 0.0 and 1.0 that defines how much of the update at each
        iteration of the camber line solver should be accepted. Helpful for some
        poorly behaved cases. Defaults to 1.0 (full update).
    
    le_loc : list, optional
        Gives the location of the leading edge relative to the given points for an airfoil
        defined by a set of outline points. If this is given, the camber line will be forced
        to intersect this point. THIS POINT SHOULD LIE ON THE AIRFOIL OUTLINE. If not given,
        the camber line solver will try to iteratively find the leading edge (the point where
        the camber line intersects the front of the profile).

    camber_termination_tol : float, optional
        The tolerance below which the maximum approximate error in the camber line estimate
        must fall in order for the camber line solver to terminate. Defaults to 1e-10.

    max_iterations : int, optional
        Maximum number of iterations for the camber line solver. Defaults to 100.
    """

    def __init__(self, name, airfoil_input, **kwargs):
        
        self.name = name
        self._load_params(airfoil_input)
        if "camber_solver_kwargs" in list(self._input_dict.keys()):
            kwarg_dict = self._input_dict["camber_solver_kwargs"]
            self._verbose = kwarg_dict.get("verbose", False)
            self._camber_relaxation = kwarg_dict.get("camber_relaxation", 1.0)
            self._le_loc = kwarg_dict.get("le_loc", None)
            self._camber_termination_tol = kwarg_dict.get("camber_termination_tol", 1e-10)
            self._max_iterations = kwarg_dict.get("max_iterations", 100)
        else:
            self._verbose = kwargs.get("verbose", False)
            self._camber_relaxation = kwargs.get("camber_relaxation", 1.0)
            self._le_loc = kwargs.get("le_loc", None)
            self._camber_termination_tol = kwargs.get("camber_termination_tol", 1e-10)
            self._max_iterations = kwargs.get("max_iterations", 100)

        # Load flaps
        self._load_flaps()

        # Store undeformed outlines
        self._initialize_geometry()

        # Specify database DOF parameters
        self._allowable_dofs = ["alpha", "Rey", "Mach", "trailing_flap_deflection", "trailing_flap_fraction"]
        self._dof_defaults = {
            "alpha" : 0.0,
            "Rey" : 1e6,
            "Mach" : 0.0,
            "trailing_flap_deflection" : 0.0,
            "trailing_flap_fraction" : 0.0
        }

        # Load input file
        input_file = self._input_dict.get("input_file", None)
        if input_file is not None:
            if self._type == "database":
                self.import_database(filename=input_file)
            elif self._type == "poly_fit":
                self.import_polynomial_fits(filename=input_file)


        self._raise_poly_bounds_error = True


    def set_err_state(self, **kwargs):
        """Sets the error state for the airfoil. Each may be specified as 'raise' or 'ignore'.

        Parameters
        ----------
        poly_fit_bounds : str, optional
            How to handle PolyFitBoundsError. Defaults to 'raise'.
        """

        # Polynomial fit bounds
        if kwargs.get("poly_fit_bounds", "raise") == "raise":
            self._raise_poly_bounds_error = True
        else:
            self._raise_poly_bounds_error = False


    def set_verbosity(self, verbosity):
        """Sets the verbosity of the airfoil."""
        self._verbose = verbosity


    def set_type(self, database_type):
        """Determines how the aerodynamic coefficients will be calculated.

        Parameters
        ----------
        database_type: str
            "linear", "functional", "database", or "poly_fit". Airfoil
            will automatically check if it has the necessary to perform
            the given type of computation and throw a warning if it does not.

        """

        # Check for proper type spec
        if database_type not in ["linear", "database", "poly_fit", "functional"]:
            raise IOError("{0} is not a valid type specification.".format(database_type))

        # Check for linear data
        if database_type == "linear":
            if not hasattr(self, "_CLa"):
                raise RuntimeWarning("Airfoil {0} does not have linear coefficients specified. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type

        # Check for database
        if database_type == "database":
            if not hasattr(self, "_data"):
                raise RuntimeWarning("Airfoil {0} does not have a database of coefficients. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type

            # Set up data normalization
            self._data_norms = np.zeros((1,self._num_dofs))
            for i in range(self._num_dofs):
                self._data_norms[0,i] = np.max(np.abs(self._data[:,i]))

            # Make sure we don't divide by zero
            self._data_norms[np.where(self._data_norms==0.0)] = 1.0

            # Normalize independent vars
            self._normed_ind_vars = self._data[:,:self._num_dofs]/self._data_norms

            # Determine default Mach and Reynolds number
            if "Rey" in list(self._dof_db_cols.keys()):
                i = self._dof_db_cols["Rey"]
                Re_min = np.min(self._data[:,i])
                Re_max = np.max(self._data[:,i])
                self._dof_defaults["Rey"] = 0.5*(Re_max+Re_min)

            if "Mach" in list(self._dof_db_cols.keys()):
                i = self._dof_db_cols["Mach"]
                M_min = np.min(self._data[:,i])
                M_max = np.max(self._data[:,i])
                self._dof_defaults["Mach"] = 0.5*(M_max+M_min)

        # Check for polynomial fits
        if database_type == "poly_fit":
            if not hasattr(self, "_CL_poly_coefs"):
                raise RuntimeWarning("Airfoil {0} does not have a set of polynomial fits. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type

        # Check for functional definition
        if database_type == "functional":
            if not hasattr(self, "_CL"):
                raise RuntimeWarning("Airfoil {0} does not have functional definitions of coefficients. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type


    def _load_params(self, airfoil_input):

        # Load input dict
        if isinstance(airfoil_input, str):
            # Load JSON object
            with open(airfoil_input, 'r') as json_handle:
                self._input_dict = json.load(json_handle)
        elif isinstance(airfoil_input, dict):
            self._input_dict = airfoil_input
        else:
            raise IOError("{0} is not an allowed airfoil definition. Must be path or dictionary.".format(airfoil_input))

        # Store type
        self._type = self._input_dict.get("type", "linear")

        # If linear, store coefficients
        if self._type == "linear":
            self._aL0 = self._input_dict.get("aL0", 0.0)
            self._CLa = self._input_dict.get("CLa", 2*np.pi)
            self._Cma = self._input_dict.get("Cma", 0.0)
            self._CD0 = self._input_dict.get("CD0", 0.0)
            self._CD1 = self._input_dict.get("CD1", 0.0)
            self._CD2 = self._input_dict.get("CD2", 0.0)
            self._CL_max = self._input_dict.get("CL_max", np.inf)
            if abs(self._CL_max) < 1e-10:
                warnings.warn("You have specified a maximum lift coefficient of 0. Are you sure you want to do this?...")
            self._CmL0 = self._input_dict.get("CmL0", 0.0)

        # For functional, store functions
        elif self._type == "functional":
            self._CL = self._input_dict["CL"]
            self._CD = self._input_dict["CD"]
            self._Cm = self._input_dict["Cm"]


    def _load_flaps(self):
        # Loads flaps based on the input dict
        self._trailing_flap_type = self._input_dict.get("trailing_flap_type", None)
        self._trailing_flap_hinge_height = self._input_dict.get("trailing_flap_hinge_height", 0.0)


    def _initialize_geometry(self):
        # Initialize geometry based on whether points or a NACA designation were given

        # Check that there's only one geometry definition
        geom_dict = self._input_dict.get("geometry", {})
        outline_points = geom_dict.get("outline_points", None)
        NACA = geom_dict.get("NACA", None)
        if outline_points is not None and NACA is not None:
            raise IOError("Outline points and a NACA designation may not be both specified for airfoil {0}.".format(self.name))

        # Check for user-given points
        if outline_points is not None:
            self.geom_specification = "points"

            # Array given
            if isinstance(outline_points, np.ndarray):
                self._raw_outline = outline_points

            # 2D list given
            elif isinstance(outline_points, list):
                self._raw_outline = np.array(outline_points)
            
            # File
            else:

                # Import
                with open(outline_points, 'r') as input_handle:
                    self._raw_outline = np.genfromtxt(input_handle)

                # Check for comma-delimited
                if np.isnan(self._raw_outline).any():
                    with open(outline_points, 'r') as input_handle:
                        self._raw_outline = np.genfromtxt(input_handle, delimiter=',')

            # Get number of points
            self._N_orig = self._raw_outline.shape[0]

            # Rearrange the coordinates if necessary to be top first then bottom
            top_ind = np.argmax(self._raw_outline[:,1])
            bot_ind = np.argmin(self._raw_outline[:,1])
            if bot_ind < top_ind: # Bottom came first
                self._raw_outline = self._raw_outline[::-1]

            # Calculate camber line and thickness
            self._calc_geometry_from_points()

        # NACA definition
        elif NACA is not None:
            self.geom_specification = "NACA"
            self._naca_closed_te = geom_dict.get("NACA_closed_te", False)
            self._naca_des = NACA

            self._calc_geometry_from_NACA()

        # No geometry given
        else:
            self.geom_specification = "none"
            self._max_camber = geom_dict.get("max_camber", 0.0)
            self._max_thickness = geom_dict.get("max_thickness", 0.0)
            return

    
    def _calc_geometry_from_NACA(self):
        # Creates thickness, camber, camber derivative, and outline splines base on the NACA equations

        # 4-digit series
        if len(self._naca_des) == 4:

            # Stores the camber and thickness getters based on the NACA designation of the airfoil
            self._m = float(self._naca_des[0])/100
            self._p = float(self._naca_des[1])/10
            self._t = float(self._naca_des[2:])/100
            self._max_camber = self._m
            self._max_thickness = self._t

            # Camber line
            def camber(x):
                if self._p != 0.0:
                    return np.where(x<self._p, self._m/(self._p*self._p)*(2*self._p*x-x*x), self._m/((1-self._p)*(1-self._p))*(1-2*self._p+2*self._p*x-x*x))
                else:
                    return np.zeros_like(x)

            self._camber_line = camber

            # Camber line derivative
            def camber_deriv(x):
                if abs(self._m)<1e-10 or abs(self._p)<1e-10: # Symmetric
                    return np.zeros_like(x)
                else:
                    return np.where(x<self._p, 2*self._m/(self._p*self._p)*(self._p-x), 2*self._m/((1-self._p)*(1-self._p))*(self._p-x))

            self._camber_deriv = camber_deriv

            # Thickness
            def thickness(x):
                if self._naca_closed_te:
                    return 5.0*self._t*(0.2969*np.sqrt(x)-0.1260*x-0.3516*x*x+0.2843*x*x*x-0.1036*x*x*x*x)
                else:
                    return 5.0*self._t*(0.2969*np.sqrt(x)-0.1260*x-0.3516*x*x+0.2843*x*x*x-0.1015*x*x*x*x)

            self._thickness = thickness

        else:
            raise IOError("Only 4-digit NACA specifications may be given. {0} is not 4-digit.".format(self._naca_des))

        # Cosine distribution of chord locations
        theta = np.linspace(-np.pi, np.pi, 200)
        x = 0.5*(1-np.cos(theta))

        y_c = self._camber_line(x)
        dy_c_dx = self._camber_deriv(x)
        t = self._thickness(x)

        # Outline points
        X = x-t*np.sin(np.arctan(dy_c_dx))*np.sign(theta)
        Y = y_c+t*np.cos(np.arctan(dy_c_dx))*np.sign(theta)

        outline_points = np.concatenate([X[:,np.newaxis], Y[:,np.newaxis]], axis=1)

        # Create splines defining the outline
        self._x_outline, self._y_outline = self._create_splines_of_s(outline_points)
        _,_,self._s_le = self._get_intersection_point(0.0, 0.0, dy_c_dx[0], "leading_edge")


    def _create_splines_of_s(self, outline_points):
        # Creates x and y coordinate splines which are a function of the normalized distance along the outline

        # Calculate distances
        x_diff = np.diff(outline_points[:,0])
        y_diff = np.diff(outline_points[:,1])
        ds = np.sqrt(x_diff*x_diff+y_diff*y_diff)
        ds = np.insert(ds, 0, 0.0)

        # Create s distribution
        s = np.cumsum(ds)
        s_normed = s/s[-1]

        # Create splines
        x_outline = interp.UnivariateSpline(s_normed, outline_points[:,0], k=5, s=1e-10)
        y_outline = interp.UnivariateSpline(s_normed, outline_points[:,1], k=5, s=1e-10)

        return x_outline, y_outline


    def _calc_geometry_from_points(self):
        # Calculates the camber line and thickness distribution from the outline points.
        # Also scales the airfoil, places the leading edge at the origin, and rotates it so it is at zero angle of attack.
        if self._verbose:
            print("Calculating camber line...")
            print("{0:<20}{1:<20}".format("Iteration", "Max Approx Error"))
            print("".join(["-"]*40))

        # Camber line estimate parameters
        num_camber_points = self._N_orig//5 # As recommended by Cody Cummings to avoid discontinuities in dyc/dx
        camber_deriv_edge_order = 2

        # Create splines defining the outline
        self._x_outline, self._y_outline = self._create_splines_of_s(self._raw_outline)

        # Get distribution of x locations
        le_ind = np.argmin(np.abs(self._raw_outline[:,0]))
        te = (self._raw_outline[0]+self._raw_outline[-1])*0.5
        if self._le_loc is None:
            x_tip = np.min(self._raw_outline[:,0])
            x_c = np.linspace(x_tip+0.0001, te[0], num_camber_points)
        else:
            x_c = np.linspace(self._le_loc[0], te[0], num_camber_points)

        # Get initial estimate for the camber line
        y_t = np.interp(x_c, self._raw_outline[le_ind::-1,0], self._raw_outline[le_ind::-1,1])
        y_b = np.interp(x_c, self._raw_outline[le_ind:,0], self._raw_outline[le_ind:,1])
        y_c = 0.5*(y_t+y_b)
        if self._le_loc is not None:
            y_c[0] = self._le_loc[1]

        # A useful distribution
        x_space = np.linspace(0.0, 1.0, 1000)

        # Show
        if self._verbose:
            plt.figure()
            plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Outline Data')
            plt.plot(self._x_outline(x_space), self._y_outline(x_space), 'k--', label='Outline Spline')
            plt.plot(x_c, y_c, 'r--', label='Initial Camber Line Estimate')
            plt.plot(x_c, np.gradient(y_c, x_c, edge_order=camber_deriv_edge_order), 'g--', label='Camber Line Derivative')
            plt.legend()
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()

        # Initialize
        x_t = np.zeros(num_camber_points)
        x_b = np.zeros(num_camber_points)
        x_c_new = np.zeros(num_camber_points)
        y_c_new = np.zeros(num_camber_points)

        # Check for symmetric airfoil
        if np.allclose(y_c, 0.0):
            camber_error = 0.0
        else:
            camber_error = 1.0

        # Iterate until convergence
        iteration = 0
        while camber_error > self._camber_termination_tol:
            iteration += 1

            # Determine camber line slope
            dyc_dx = np.gradient(y_c, x_c, edge_order=camber_deriv_edge_order)
            
            # Determine slope of lines perpendicular to the camber
            with np.errstate(divide="ignore"):
                b = -1.0/dyc_dx

            # Loop through points on the camber line to find where their normal intersects the outline
            for i in range(num_camber_points):
                if self._le_loc is not None and i == 0:
                    continue

                # Get point information
                xc = x_c[i]
                yc = y_c[i]
                bi = b[i]

                # Estimate the intersection points
                x_t[i], y_t[i], _ = self._get_intersection_point(xc, yc, bi, "top")
                x_b[i], y_b[i], _ = self._get_intersection_point(xc, yc, bi, "bottom")

            # Calculate new camber line points
            x_c_new = 0.5*(x_t+x_b)
            y_c_new = 0.5*(y_t+y_b)
            if self._le_loc is not None:
                x_c_new[0] = self._le_loc[0]
                y_c_new[0] = self._le_loc[1]

            # Plot new and old estimate
            if False:
                plt.figure()
                plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Outline Data')
                plt.plot(x_c, y_c, 'r--', label='Old Camber Line Estimate')
                plt.plot(x_c_new, y_c_new, 'g--', label='New Camber Line Estimate')
                plt.plot(x_t, y_t, 'rx')
                plt.plot(x_b, y_b, 'ro')
                plt.legend()
                plt.gca().set_aspect('equal', adjustable='box')
                plt.show()

            # Approximate error
            x_diff = x_c_new-x_c
            y_diff = y_c_new-y_c
            camber_error = np.max(np.sqrt(x_diff*x_diff+y_diff*y_diff))
            if self._verbose:
                print("{0:<20}{1:<20}".format(iteration, camber_error))

            # Sort, just in case things got messed up
            sorted_ind = np.argsort(x_c_new)
            x_c_new = x_c_new[sorted_ind]
            y_c_new = y_c_new[sorted_ind]

            # Update for next iteration
            x_c = self._camber_relaxation*x_c_new+(1.0-self._camber_relaxation)*x_c
            y_c = self._camber_relaxation*y_c_new+(1.0-self._camber_relaxation)*y_c

            # Check iteration limit
            if iteration == self._max_iterations:
                raise CamberSolverNotConvergedError(self.name, camber_error)

        if self._verbose: print("Camber line solver converged.")

        # Calculate where the camber line intersects the outline to find the leading edge
        if self._le_loc is None:
            dyc_dx = np.gradient(y_c, x_c, edge_order=2)
            b = dyc_dx[0]
            x_le, y_le, self._s_le = self._get_intersection_point(x_c[0], y_c[0], b, "leading_edge")
            le = np.array([x_le, y_le])
            x_c = np.insert(x_c, 0, le[0])
            y_c = np.insert(y_c, 0, le[1])
        else:
            le = self._le_loc

        if self._verbose: print("Leading edge: {0}".format(le))

        if self._verbose:
            # Plot
            plt.figure()
            plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Outline Data')
            plt.plot(x_c, y_c, 'g--', label='Final Camber Line Estimate')
            plt.legend()
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()

        # Get trailing edge
        te = (self._raw_outline[0]+self._raw_outline[-1])*0.5
        if self._verbose: print("Trailing edge: {0}".format(te))

        # Renormalize using new leading and trailing edge
        self._normalize_points(self._raw_outline, le, te)
        self._x_outline, self._y_outline = self._create_splines_of_s(self._raw_outline)

        # Normalize camber line points
        camber_points = np.concatenate([x_c[:,np.newaxis], y_c[:,np.newaxis]], axis=1)
        self._normalize_points(camber_points, le, te)

        # Store camber and max camber
        self._camber_line = interp.UnivariateSpline(camber_points[:,0], camber_points[:,1], k=5, s=1e-10)
        self._max_camber = np.max(camber_points[:,1])

        # Store camber line derivative
        y_c = self._camber_line(x_space)
        dyc_dx= np.gradient(y_c, x_space)
        self._camber_deriv = interp.UnivariateSpline(x_space, dyc_dx, k=5, s=1e-10)
        with np.errstate(divide="ignore"):
            b = -1.0/dyc_dx

        # Find points on the surface to determine the thickness
        if self._verbose: print("Calculating thickness distribution...", end="")
        x_t_t = np.zeros_like(x_space)
        x_b_t = np.zeros_like(x_space)
        y_t_t = np.zeros_like(x_space)
        y_b_t = np.zeros_like(x_space)
        for i, xc in enumerate(x_space):
            if i == 0: continue # This point intersects the outline by definition and so will have zero thickness
            yc = y_c[i]
            bi = b[i]

            x_t_t[i], y_t_t[i],_ = self._get_intersection_point(xc, yc, bi, "top")
            x_b_t[i], y_b_t[i],_ = self._get_intersection_point(xc, yc, bi, "bottom")

        # Store thickness distribution
        t = 0.5*np.sqrt((x_t_t-x_b_t)*(x_t_t-x_b_t)+(y_t_t-y_b_t)*(y_t_t-y_b_t))
        self._thickness = interp.UnivariateSpline(x_space, t, k=5, s=1e-10)
        self._max_thickness = np.max(t)
        if self._verbose: print("Done")

        # Calculate estimated top and bottom points
        y_c_pred = self._camber_line(x_space)
        dyc_dx = np.gradient(y_c_pred, x_space)
        t_pred = self._thickness(x_space)
        theta = np.arctan(dyc_dx)
        S_theta = np.sin(theta)
        C_theta = np.cos(theta)

        x_b = x_space+t_pred*S_theta
        y_b = y_c_pred-t_pred*C_theta
        x_t = x_space-t_pred*S_theta
        y_t = y_c_pred+t_pred*C_theta
        
        # Plot
        if self._verbose:
            plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Original Data')
            plt.plot(x_t, y_t, 'r--', label='Top Fit')
            plt.plot(x_b, y_b, 'r--', label='Bottom Fit')
            plt.legend()
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()


    def _normalize_points(self, points, le_coords, te_coords):
        # Takes the given points, translates them to the origin, rotates them to be at zero angle of attack, and scales so the chord length is unity

        # Translate
        points[:,0] -= le_coords[0]
        points[:,1] -= le_coords[1]

        # Rotate
        x_diff = te_coords[0]-le_coords[0]
        y_diff = te_coords[1]-le_coords[1]
        theta = -np.arctan2(y_diff, x_diff)
        R = np.array([[np.cos(theta), -np.sin(theta)],
                      [np.sin(theta),  np.cos(theta)]])
        points = np.matmul(R, points.T)

        #Scale
        c_unscaled = np.sqrt(x_diff*x_diff+y_diff*y_diff)
        points = points/c_unscaled


    def _get_intersection_point(self, xc, yc, b, surface, plot=False):
        # Calculates the point on the surface where the line extending from (xc, yc) with slope of b intersects
        # Uses the secant method to converge in s

        # Start s in the middle of the respective surface
        if surface == "top":
            s0 = 0.24
            s1 = 0.26
        elif surface == "bottom":
            s0 = 0.74
            s1 = 0.76
        elif surface == "leading_edge":
            s0 = 0.49
            s1 = 0.51

        # Initial points on outline
        x0 = self._x_outline(s0)
        y0 = self._y_outline(s0)
        x1 = self._x_outline(s1)
        y1 = self._y_outline(s1)

        # Initial distances
        d0 = self._distance(x0, y0, xc, yc, b)
        d1 = self._distance(x1, y1, xc, yc, b)

        # Secant method
        while abs(d1) > 1e-10:
            
            # Get new estimate in s
            if d1 > 0.2 or (s1 > 0.35 and s1 < 0.65): # Apply some relaxation when we're far away or near the leading edge (to keep from shooting to the other surface)
                s2 = s1-0.2*d1*(s0-s1)/(d0-d1)
            else:
                s2 = s1-d1*(s0-s1)/(d0-d1)

            # Make sure we're in bounds
            if s2 > 1.1:
                s2 = 1-0.01*s2
            if s2 < -0.1:
                s2 = -0.01*s2

            # Get new point
            x2 = self._x_outline(s2)
            y2 = self._y_outline(s2)

            # Get new distance
            d2 = self._distance(x2, y2, xc, yc, b)

            # Plot
            if plot:
                plt.figure()
                s_space = np.linspace(0.0, 1.0, 10000)
                plt.plot(self._x_outline(s_space), self._y_outline(s_space), 'b')
                plt.plot(xc, yc, 'or')
                plt.plot(x0, y0, 'bx')
                plt.plot(x1, y1, 'gx')
                plt.plot(x2, y2, 'rx')
                plt.gca().set_aspect('equal', adjustable='box')
                plt.show()

            # Update for next iteration
            s0 = s1
            d0 = d1
            x0 = x1
            y0 = y1

            s1 = s2
            d1 = d2
            x1 = x2
            y1 = y2

        return x1, y1, s1


    def _distance(self, x0, y0, x, y, b):
        if not np.isnan(b) and not np.isinf(b):
            return (-b*x0+y0+b*x-y)/np.sqrt(b*b+1)
        else:
            return abs(x0-x)


    def check_against_NACA(self, naca_des):
        """Checks the error in the camber and thickness against that predicted by the NACA equations. This is recommended as a check for the user
        if unusual geometries are being imported. Checks against the open trailing edge formulation of the NACA equations.

        Parameters
        ----------
        naca_des : str
            NACA designation of the airfoil to compare against as a string. May only be 4-digit series.
        """

        print("Checking estimated thickness and camber against NACA equations for NACA {0}...".format(naca_des))

        # 4-digit series
        if len(naca_des) == 4:

            # Generate true coordinates
            x_space = np.linspace(0.0, 1.0, 10000)
            m = float(naca_des[0])/100
            p = float(naca_des[1])/10
            if p != 0.0:
                y_c_true = np.where(x_space<p, m/p**2*(2*p*x_space-x_space**2), m/(1-p)**2*(1-2*p+2*p*x_space-x_space**2))
            else:
                y_c_true = np.zeros_like(x_space)

            # True thickness
            t = float(naca_des[2:])/100
            t_true = 5*t*(0.2969*np.sqrt(x_space)-0.1260*x_space-0.3516*x_space**2+0.2843*x_space**3-0.1015*x_space**4)

        else:
            raise IOError("Can only compare to NACA 4-digit series. Cannot be {0}.".format(naca_des))

        # Estimate camber
        y_c_est = self._camber_line(x_space)

        # Plot camber
        plt.figure()
        plt.plot(x_space, y_c_true, 'g--', label='True Camber')
        plt.plot(x_space, y_c_est, 'r--', label='Estimated Camber')
        plt.legend()
        plt.gca().set_aspect('equal', adjustable='box')
        plt.show()

        # Estimate thickness
        t_est = self._thickness(x_space)

        # Plot thickness
        plt.figure()
        plt.plot(x_space, t_true, 'g--', label='True Thickness')
        plt.plot(x_space, t_est, 'r--', label='Estimated Thickness')
        plt.legend()
        plt.gca().set_aspect('equal', adjustable='box')
        plt.show()

        with np.errstate(divide='ignore', invalid='ignore'):
            # Camber error
            camber_error = np.abs((y_c_est-y_c_true)/y_c_true)
            max_camber_error = np.max(np.where(np.isfinite(camber_error), camber_error, 0.0))
            print("Max camber error: {0:.5f}%".format(max_camber_error*100))

            # Thickness error
            thickness_error = np.abs((t_est-t_true)/t_true)
            max_thickness_error = np.max(np.where(np.isfinite(thickness_error), thickness_error, 0.0))
            print("Max thickness error: {0:.5f}%".format(max_thickness_error*100))


    def _get_flap_influence(self, c_f, d_f):
        # Returns the influence of the flap on the effective angle of attack
        # From Phillips *Mechanics of Flight* Ch. 1, Sec. 7
        theta_f = np.arccos(2.0*c_f-1.0)
        eps_flap_ideal = 1.0-(theta_f-np.sin(theta_f))/np.pi
        hinge_eff = 3.9598*np.arctan((c_f+0.006527)*89.2574+4.898015)-5.18786
        flap_eff = np.where(np.abs(d_f)>0.19198621771937624, -0.4995016675499485*np.abs(d_f)+1.09589743589744, 1.0)
        return hinge_eff*flap_eff*eps_flap_ideal*d_f


    def _get_database_data(self, data_index, **kwargs):
        # Returns an interpolated data point from the database.
        # data_index: 0 = CL, 1 = CD, 2 = Cm

        # Determine size of query
        max_size = 1
        for dof in self._dof_db_order:
            param = kwargs.get(dof, self._dof_defaults[dof])
            if isinstance(param, np.ndarray):
                max_size = max(max_size, param.shape[0])

        # Get params
        param_vals = np.zeros((max_size,self._num_dofs))
        for i, dof in enumerate(self._dof_db_order):
            param_vals[:,i] = kwargs.get(dof, self._dof_defaults[dof])

        # Interpolate
        return_val = interp.griddata(self._normed_ind_vars, self._data[:,self._num_dofs+data_index].flatten(), param_vals/self._data_norms, method='linear').flatten()
        #return_val = interp.griddata(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+data_index].flatten(), param_vals, method='linear').flatten()

        # Check for going out of bounds
        if np.isnan(return_val).any():
            raise DatabaseBoundsError(self.name, np.argwhere(np.isnan(return_val)).flatten(), kwargs)

        # Return
        if max_size == 1:
            return return_val.item()
        else:
            return return_val


    def get_CL(self, **kwargs):
        """Returns the coefficient of lift. Note: all parameters can be given as numpy arrays, in which case a numpy array of the coefficient will be returned.
        To do this, all parameter arrays must have only one dimension and must have the same length.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float or ndarray
            Lift coefficient
        """
        
        # Linearized model
        if self._type == "linear":

            # Get params
            alpha = kwargs.get("alpha", 0.0)
            d_f = kwargs.get("trailing_flap_deflection", 0.0)
            c_f = kwargs.get("trailing_flap_fraction", 0.0)

            # Calculate lift coefficient
            if np.array(d_f == 0.0).all() or np.array(c_f == 0.0).all():
                CL = self._CLa*(alpha-self._aL0)
            else:
                delta_a_d_f = self._get_flap_influence(c_f, d_f)
                CL = self._CLa*(alpha-self._aL0+delta_a_d_f)
            
            # Saturate
            with np.errstate(invalid='ignore'):
                if isinstance(CL, np.ndarray):
                    CL = np.where((CL > self._CL_max) | (CL < -self._CL_max), np.sign(CL)*self._CL_max, CL)
                elif CL > self._CL_max or CL < -self._CL_max:
                    CL = np.sign(CL)*self._CL_max

        # Functional model
        elif self._type == "functional":
            CL = self._CL(**kwargs)

        # Generated/imported database
        elif self._type == "database":
            CL = self._get_database_data(0, **kwargs)

        # Fits
        elif self._type == "poly_fit":
            CL = self._get_polynomial_data(0, **kwargs)

        return CL


    def get_CD(self, **kwargs):
        """Returns the coefficient of drag. note: all parameters can be given as numpy arrays, in which case a numpy array of the coefficient will be returned.
        to do this, all parameter arrays must have only one dimension and must have the same length.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float or ndarray
            Drag coefficient
        """

        # Linear type
        if self._type == "linear":
            d_f = kwargs.pop("trailing_flap_deflection", 0.0)
            CL = self.get_CL(**kwargs)
            CD_flap = 0.002*np.abs(np.degrees(d_f)) # A *very* rough estimate for flaps
            CD = self._CD0+self._CD1*CL+self._CD2*CL**2+CD_flap

        # Functional model
        elif self._type == "functional":
            CD = self._CD(**kwargs)

        # Generated/imported database
        elif self._type == "database":
            CD = self._get_database_data(1, **kwargs)

        # Fits
        elif self._type == "poly_fit":
            CD = self._get_polynomial_data(1, **kwargs)

        return CD


    def get_Cm(self, **kwargs):
        """Returns the moment coefficient. note: all parameters can be given as numpy arrays, in which case a numpy array of the coefficient will be returned.
        to do this, all parameter arrays must have only one dimension and must have the same length.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_moment_deriv : float or ndarray, optional
            Change in section moment with respect to trailing flap deflection. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float or ndarray
            Moment coefficient
        """

        # Linear type
        if self._type == "linear":

            # Get parameters
            alpha = kwargs.get("alpha", 0.0)
            d_f = kwargs.get("trailing_flap_deflection", 0.0)
            c_f = kwargs.get("trailing_flap_fraction", 0.0)

            # No control deflection
            if np.array(d_f == 0.0).all() or np.array(c_f == 0.0).all():
                Cm = self._CmL0+self._Cma*(alpha-self._aL0)
            else:
                theta_f = np.arccos(2.0*c_f-1.0)
                Cm_df = 0.25*(np.sin(2.0*theta_f)-2.0*np.sin(theta_f))
                Cm = self._CmL0+self._Cma*(alpha-self._aL0)+Cm_df*d_f

        # Functional model
        elif self._type == "functional":
            Cm = self._Cm(**kwargs)

        # Generated/imported database
        elif self._type == "database":
            Cm = self._get_database_data(2, **kwargs)

        # Fits
        elif self._type == "poly_fit":
            Cm = self._get_polynomial_data(2, **kwargs)

        return Cm


    def get_aL0(self, **kwargs):
        """Returns the zero-lift angle of attack, taking flap deflection into account.

        Parameters
        ----------
        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float
            Zero-lift angle of attack
        """

        # Linear airfoil model
        if self._type == "linear":

            # Get params
            d_f = kwargs.get("trailing_flap_deflection", 0.0)
            c_f = kwargs.get("trailing_flap_fraction", 0.0)

            # Calculate lift coefficient
            if np.array(d_f == 0.0).all() or np.array(c_f == 0.0).all():
                aL0 = self._aL0
            else:
                delta_a_d_f = self._get_flap_influence(c_f, d_f)
                aL0 = self._aL0-delta_a_d_f
            
            return aL0

        # Database/poly fit/functional
        # Use secant method in alpha to find a_L0
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Remove alpha from kwargs
            kwargs.pop('alpha', None)

            # Initialize secant method
            a0 = 0.0
            CL0 = self.get_CL(alpha=a0, **kwargs)
            a0 = np.zeros_like(CL0)
            a1 = np.zeros_like(CL0)+0.01
            CL1 = self.get_CL(alpha=a1, **kwargs)
            a2 = np.zeros_like(CL1)

            # If we're outside the domain of the database, aL0 should be nan
            if a2.size == 1:
                if np.isnan(CL1):
                    a2 = np.nan
            else:
                a2[np.where(np.isnan(CL1))] = np.nan
            
            # Iterate
            np.seterr(invalid='ignore')
            not_converged = np.where(np.array(np.abs(CL1)>1e-10))[0]
            while not_converged.size>0:
                
                # Update estimate
                if a2.size == 1:
                    a2 = (a1-CL1*(a0-a1)/(CL0-CL1))
                else:
                    a2[not_converged] = (a1-CL1*(a0-a1)/(CL0-CL1))[not_converged]
                CL2 = self.get_CL(alpha=a2, **kwargs)

                # Update for next iteration
                a0 = np.copy(a1)
                CL0 = np.copy(CL1)
                a1 = np.copy(a2)
                CL1 = np.copy(CL2)

                # Check convergence
                not_converged = np.where(np.array(np.abs(CL1)>1e-10))[0]

            np.seterr()
            return a2


    def get_CLM(self, **kwargs):
        """Returns the lift slope with respect to Mach number using a forward-difference approximation.
        Simply returns 0 for a type 'linear' airfoil.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        dx : float
            Step size for finite-difference equation. Defaults to 0.05.

        Returns
        -------
        float or ndarray
            Lift slope with respect to Mach number
        """

        # Linear model
        if self._type == "linear":
            return 0.0

        # Database
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Check the database is dependent on Mach
            if (self._type == "database" or self._type == "poly_fit") and "Mach" not in self._dof_db_order:
                return 0.0

            # Get center Mach value
            dx = kwargs.get("dx", 0.05)
            Mach = kwargs.pop("Mach", 0.0)
            
            # Calculate forward and center points (since we'll often be at M=0 and negative M doesn't work)
            CL1 = self.get_CL(Mach=Mach+dx, **kwargs)
            CL0 = self.get_CL(Mach=Mach, **kwargs)

            return (CL1-CL0)/dx


    def get_CLRe(self, **kwargs):
        """Returns the lift slope with respect to Reynolds number using a central-difference approximation.
        Simply returns 0 for a type 'linear' airfoil.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        dx : float
            Step size for finite-difference equation. Defaults to 1000.

        Returns
        -------
        float or ndarray
            Lift slope with respect to Reynolds number
        """

        # Linear model
        if self._type == "linear":
            return 0.0

        # Database
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Check the database is dependent on Re
            if (self._type == "database" or self._type == "poly_fit") and "Rey" not in self._dof_db_order:
                return 0.0

            # Get center Re value
            dx = kwargs.get("dx", 1000)
            Rey = kwargs.pop("Rey", 1000000)
            
            # Calculate forward and backward points
            CL1 = self.get_CL(Rey=Rey+dx, **kwargs)
            CL0 = self.get_CL(Rey=Rey-dx, **kwargs)

            return (CL1-CL0)/(2*dx)


    def get_CLa(self, **kwargs):
        """Returns the lift slope using a central-difference approximation.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        dx : float, optional
            Step size for finite-difference equation. Defaults to 0.001 radians.

        Returns
        -------
        float or ndarray
            Lift slope
        """

        # Linear model
        if self._type == "linear":
            return self._CLa

        # Database
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Check the database is dependent on alpha
            if (self._type == "database" or self._type == "poly_fit") and "alpha" not in self._dof_db_order:
                return 0.0

            # Get center alpha value
            dx = kwargs.get("dx", 0.001)
            alpha = kwargs.pop("alpha", 0.0)
            
            # Calculate forward and backward points
            CL1 = self.get_CL(alpha=alpha+dx, **kwargs)
            CL0 = self.get_CL(alpha=alpha-dx, **kwargs)

            return (CL1-CL0)/(2*dx)


    def get_thickness(self, x):
        """Returns the thickness normal to the camber line at the specified x location(s).

        Parameters
        ----------
        x : float or ndarray
            x location(s) at which to get the thickness.

        Returns
        -------
        float or ndarray
            Thickness as a percentage of the chord.
        """
        if isinstance(x, float):
            return self._thickness(x).item()
        else:
            return self._thickness(x)


    def get_max_thickness(self):
        """Returns the maximum thickness of the airfoil, divided by the chord length.
        """
        return self._max_thickness


    def get_camber(self, x):
        """Returns the y coordinate(s) of the camber line at the specified x location(s).

        Parameters
        ----------
        x : float or ndarray
            x location(s) at which to get the thickness.

        Returns
        -------
        float or ndarray
            Camber line y coordinate(s) as a percentage of the chord.
        """
        if isinstance(x, float):
            return self._camber_line(x).item()
        else:
            return self._camber_line(x)


    def get_max_camber(self):
        """Returns the maximum camber of the airfoil, divided by the chord length.
        """
        return self._max_camber


    def get_outline_points(self, **kwargs):
        """Returns an array of outline points showing the geometry of the airfoil.

        Parameters
        ----------
        N : int, optional
            The number of outline points to return. This function will not always return exactly this many
            but never more. Defaults to 200.

        cluster : bool, optional
            Whether to cluster points about the leading and trailing edges. Defaults to True.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians (positive down). Defaults to zero.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord. Defaults to zero.

        export : str, optional
            If specified, the outline points will be saved to a file. Defaults to no file.

        top_first : bool, optional
            The order of the coordinates when exported. Defaults to going from the trailing edge along the top and
            the around to the bottom.

        close_te : bool, optional
            Whether the top and bottom trailing edge points should be forced to be equal. Defaults to False

        plot : bool, optional
            Whether a plot of the outline points should be displayed once computed. Defaults to False.

        original_points : bool, optional
            Whether this should simply return the original inputted points. If set to True, all other kwargs relating
            to the geometry will be ignored. Defaults to False.

        Returns
        -------
        ndarray
            Outline points in airfoil coordinates.
        """

        # Check the geometry has been defined
        if self.geom_specification != "none":

            # Get kwargs
            N = kwargs.get("N", 200)
            cluster = kwargs.get("cluster", True)
            trailing_flap_deflection = kwargs.get("trailing_flap_deflection", 0.0)
            trailing_flap_fraction = kwargs.get("trailing_flap_fraction", 0.0)
            close_te = kwargs.get("close_te", False)

            if not kwargs.get("original_points", False):
            
                # Zach's method of determining NACA airfoils with deflected parabolic flaps (actually works really well for all of them...)

                # Get flap parameters
                d_f = trailing_flap_deflection
                x_f = 1.0-trailing_flap_fraction
                y_f = self._input_dict.get("trailing_flap_hinge_height", self._camber_line(x_f))
            
                # Calculate distributions
                theta_c = np.linspace(np.pi, -np.pi, N) # Loop over entire airfoil from TE->top->LE->bottom->TE
                if cluster:
                    x_c = 0.5*(1.0-np.cos(theta_c))
                else:
                    x_c = abs(np.linspace(-1.0, 1.0, N))
            
                # Calculate undeformed camber line and thickness
                y_c = self._camber_line(x_c)
                t = self._thickness(x_c)
                dyc_dx = self._camber_deriv(x_c)
            
                if d_f != 0.0 and x_f < 1.0:
                    # Determine which camber points belong to the flap
                    flap_ind = np.where(x_c>x_f)

                    # Linear flap
                    if self._trailing_flap_type == "linear":

                        # Calculate deflected camber line Eqs. (8-10) in "Geometry and Aerodynamic Performance of Parabolic..." by Hunsaker, et al. 2018
                        r = np.sqrt((y_c-y_f)*(y_c-y_f)+(x_c-x_f)*(x_c-x_f))
                        psi = np.arctan((y_c-y_f)/(x_c-x_f))
                        x_c[flap_ind] = x_f+(r*np.cos(d_f-psi))[flap_ind]
                        y_c[flap_ind] = y_f-(r*np.sin(d_f-psi))[flap_ind]
                        dyc_dx[flap_ind] = np.gradient(y_c[flap_ind], x_c[flap_ind], edge_order=2)

                    else:
                        # Parabolic flap from "Geometry and Aerodynamic Performance of Parabolic..." by Hunsaker, et al. 2018

                        # Calculate the neutral line parameters
                        l_n = np.sqrt(y_f*y_f+(1-x_f)*(1-x_f))
                        phi_n = -np.arctan2(y_f, 1-x_f)

                        # Calculate the location of the deflected trailing edge
                        tan_df = np.tan(d_f)
                        R = np.sqrt(4*tan_df*tan_df+1)+np.arcsinh(2*tan_df)/(2*tan_df)
                        E_te = 2.0*l_n/R

                        # Find E_p using secant method

                        # Constants
                        R_tan_df = R*tan_df
                        R_tan_df2 = R_tan_df*R_tan_df
                        E_0 = ((x_c-x_f)/(1-x_f)*l_n)[flap_ind]

                        # Initial guesses
                        E_p0 = E_te*E_0/l_n
                        R0 = E_p0/2*np.sqrt(E_p0**2/l_n**2*R_tan_df2+1)+l_n/(2*R_tan_df)*np.arcsinh(E_p0/l_n*R_tan_df)-E_0
                        E_p1 = E_te*E_0/l_n+0.001
                        R1 = E_p1/2*np.sqrt(E_p1**2/l_n**2*R_tan_df2+1)+l_n/(2*R_tan_df)*np.arcsinh(E_p1/l_n*R_tan_df)-E_0

                        # Suppress warnings because an error will often occur within the np.where that has no effect on computation
                        with np.errstate(invalid='ignore'):
                        
                            # Iterate
                            while (abs(R1)>1e-10).any():

                                # Update value
                                E_p2 = np.where(np.abs(R0-R1) != 0.0, E_p1-R1*(E_p0-E_p1)/(R0-R1), E_p1)

                                # Get residual
                                R2 = E_p2/2*np.sqrt(E_p2**2/l_n**2*R_tan_df2+1)+l_n/(2*R_tan_df)*np.arcsinh(E_p2/l_n*R_tan_df)-E_0

                                # Update for next iteration
                                E_p0 = E_p1
                                R0 = R1
                                E_p1 = E_p2
                                R1 = R2

                        # Store final result
                        E_p = E_p1
                        n_p = -E_p*E_p/E_te*tan_df

                        # Calculate deflected neutral line
                        x_p = x_f+E_p*np.cos(phi_n)-n_p*np.sin(phi_n)
                        y_p = y_f+E_p*np.sin(phi_n)+n_p*np.cos(phi_n)
                        y_nl = y_f*(1-(x_c-x_f)/(1.0-x_f))
                        dy_c = (y_c-y_nl)[flap_ind]

                        # Calculate deflected camber line
                        C = np.arctan(2*E_p/E_te*tan_df)
                        x_c[flap_ind] = x_p+dy_c*np.sin(C)
                        y_c[flap_ind] = y_p+dy_c*np.cos(C)

                        dyc_dx[flap_ind] = (dyc_dx[flap_ind] - 2*E_p*tan_df/E_te) / (1 + 2*E_p*tan_df/E_te*dyc_dx[flap_ind])

                # Outline points
                X = x_c-t*np.sin(np.arctan(dyc_dx))*np.sign(theta_c)
                Y = y_c+t*np.cos(np.arctan(dyc_dx))*np.sign(theta_c)

                # Trim overlapping points from linear flap deflection
                if self._trailing_flap_type == "linear" and d_f != 0.0 and x_f < 1.0:

                    # Get indices of top and bottom points
                    top_ind = theta_c > 0.0
                    bot_ind = theta_c <= 0.0

                    # Split points into top and bottom
                    X_t = X[top_ind]
                    Y_t = Y[top_ind]
                    X_b = X[bot_ind]
                    Y_b = Y[bot_ind]

                    # Find the point on the surface where the hinge breaks
                    # These equations determine the slope of the line bisecting the angle between the camber line before the flap
                    # and the camber line of the flap
                    psi_prime = np.pi+np.arctan(self._camber_deriv(x_f)) # Angle to the camber line before the flap
                    d_f_prime = -d_f+np.arctan(self._camber_deriv(x_f)) # Angle to the camber line after the flap
                    phi = 0.5*(psi_prime+d_f_prime)
                    b = np.tan(phi)
                    x_t_break, y_t_break, _ = self._get_intersection_point(x_f, y_f, b, "top")
                    x_b_break, y_b_break, _ = self._get_intersection_point(x_f, y_f, b, "bottom")

                    # Trim overlapping points off of both surfaces
                    X_b, Y_b, num_trimmed_from_bot = self._trim_surface(X_b, Y_b, "forward")
                    X_t, Y_t, num_trimmed_from_top = self._trim_surface(X_t, Y_t, "backward")

                    # Check if we need to fill anything in so the number of outline points remains the same
                    if num_trimmed_from_bot>0:
                        r_t = self._get_cart_dist(x_t_break, y_t_break, x_f, y_f)
                        X_t, Y_t = self._fill_surface(X_t, Y_t, x_f, y_f, r_t, x_t_break, num_trimmed_from_bot, "backward")

                    if num_trimmed_from_top>0:
                        r_b = self._get_cart_dist(x_b_break, y_b_break, x_f, y_f)
                        X_b, Y_b = self._fill_surface(X_b, Y_b, x_f, y_f, r_b, x_b_break, num_trimmed_from_top, "forward")

                    # Concatenate top and bottom points
                    X = np.concatenate([X_t, X_b])
                    Y = np.concatenate([Y_t, Y_b])

                # Make sure the trailing edge is sealed
                if close_te:
                    x_te = 0.5*(X[0]+X[-1])
                    y_te = 0.5*(Y[0]+Y[-1])
                    X[0] = x_te
                    Y[0] = y_te
                    X[-1] = x_te
                    Y[-1] = y_te

            # Just use the original points
            else:
                X = self._raw_outline[:,0]
                Y = self._raw_outline[:,1]

            # Plot result
            if kwargs.get("plot", False):
                plt.figure()
                plt.plot(X, Y)
                #plt.plot(x_t_break, y_t_break, 'rx')
                #plt.plot(x_b_break, y_b_break, 'rx')
                #plt.plot(x_f, y_f, 'rx')
                plt.plot(x_c, y_c, 'r--')
                plt.xlabel('x')
                plt.ylabel('y')
                plt.title(self.name)
                plt.gca().set_aspect('equal', adjustable='box')
                plt.show()

            # Concatenate x and y
            outline_points = np.concatenate([X[:,np.newaxis], Y[:,np.newaxis]], axis=1)
            if not kwargs.get("top_first", True):
                outline_points = outline_points[::-1,:]
                    
            # Save to file
            export = kwargs.get("export", None)
            if export is not None:
                np.savetxt(export, outline_points, fmt='%10.8f')

            return outline_points

        else:
            raise RuntimeError("The geometry has not been defined for airfoil {0}. Outline points cannot be generated.".format(self.name))


    def _trim_surface(self, X, Y, direction):
        # Trims any points within a region of doubling back in x

        # Loop through points
        trim_indices = []
        rev = False
        fwd = False

        # Determine direction
        indices = range(X.shape[0])
        if direction == "backward":
            indices = indices[::-1]
        
        # Loop through points
        trim_indices = []
        i_prev = 0
        for i in indices:
            
            # Skip first third of the section so we don't end up trimming off the nose
            if X[i] < 0.3:
                continue

            # Check if we've started going backwards
            if not rev and X[i] < X[i_prev]:
                rev = i_prev

            # Check if we've started going forward again
            if rev and not fwd and X[i] > X[i_prev]:
                fwd = i_prev
                break

            i_prev = i
        
        # Trim and insert
        if rev and fwd:

            # Determine where to trim
            if direction == "forward":
                trim_indices = list(range(rev, fwd+1))
            else:
                trim_indices = list(range(fwd, rev+1))

            # Trim
            X = np.delete(X, trim_indices)
            Y = np.delete(Y, trim_indices)

            return X, Y, len(trim_indices)
        
        else:
            return X, Y, 0


    def _fill_surface(self, X, Y, x_h, y_h, r, x_break, num_points, direction):
        # Fills in num_points along the arc defined by x_h, y_h, and r

        # Determine direction
        indices = range(X.shape[0])
        if direction == "backward":
            indices = indices[::-1]

        # Find the two points we need to fill in between
        for i in indices:
            
            # Skip first third of the section
            if X[i] < 0.3:
                continue

            if X[i] > x_break:
                fill_start = i-1
                fill_stop = i
                break

        # No filling needed, apparently...
        else:
            return X, Y

        # Get angles from the hinge point to the start and stop points
        theta0 = math.atan2(Y[fill_start]-y_h, X[fill_start]-x_h)
        theta1 = math.atan2(Y[fill_stop]-y_h, X[fill_stop]-x_h)

        # Find fill in points
        theta_fill = np.linspace(theta0, theta1, num_points+2)[1:-1]
        x_fill = x_h+r*np.cos(theta_fill)
        y_fill = y_h+r*np.sin(theta_fill)

        return np.insert(X, fill_stop, x_fill), np.insert(Y, fill_stop, y_fill)


    def _get_closest_point_on_surface(self, x, y, surface):
        # Finds the point on the surface of the airfoil which is closest to the given point using Golden section search
        # Returns the coordinates and the radius from the given point

        # Decide where to start in s
        if surface == "top":
            s0 = 0.0
            s3 = 0.5
        else:
            s0 = 0.5
            s3 = 1.0

        # Get Golden ratio
        R = 2.0/(1.0+math.sqrt(5.0))

        # Loop until interval converges
        while abs(s0-s3)>1e-10:
            
            # Get interior points
            diff = s3-s0
            s1 = s3-diff*R
            s2 = s0+diff*R

            # Calculate points
            x1 = self._x_outline(s1)
            y1 = self._y_outline(s1)
            x2 = self._x_outline(s2)
            y2 = self._y_outline(s2)
    
            # Calculate distances
            d1 = self._get_cart_dist(x, y, x1, y1)
            d2 = self._get_cart_dist(x, y, x2, y2)

            # Check
            if d1 < d2:
                s3 = s2
            else:
                s0 = s1

        return x1, y1, d1


    def _get_cart_dist(self, x0, y0, x1, y1):
        x_diff = x0-x1
        y_diff = y0-y1
        return math.sqrt(x_diff*x_diff+y_diff*y_diff)


    def generate_database(self, **kwargs):
        """Makes calls to Xfoil to calculate CL, CD, and Cm as a function of each given degree of freedom.

        Parameters
        ----------
        degrees_of_freedom : dict
            A dict specifying which degrees of freedom the database should perturb. Allowable degrees of 
            freedom are "alpha", "Rey", "Mach", "trailing_flap_deflection", and "trailing_flap_fraction".

            Each key should be one of these degrees of freedom. To specify a range for the degree of freedom,
            a dictionary with the following keys should be given:

                "range" : list
                    The lower and upper limits for this DOF.

                "steps" : int
                    The number of points in the range to interrogate.

                "index" : int
                    Index of the column for this degree of freedom in the database.

                "log_step" : bool, optional
                    Whether the steps in this dof should be spaced linearly (False) or logarithmically
                    (True). Defaults to False.

            If instead of perturbing a variable, you want the database to be evaluated at a constant value of
            that variable, a float should be given instead of a dictionary. That variable will then not be considered
            a degree of freedom of the database and will not appear in the database.
            
            An example is shown below:

                dofs = {
                    "alpha" : {
                        "range" : [math.radians(-15.0), math.radians(15.0)],
                        "steps" : 21,
                        "index" : 1
                    },
                    "Rey" : 2900000.0,
                    "trailing_flap_deflection" : {
                        "range" : [math.radians(-20.0), math.radians(20.0)],
                        "steps" : 1,
                        "index" : 0
                    },
                    "trailing_flap_fraction" : 0.25
                }

            The above input will run the airfoil through angles of attack from -15 to 15 degrees at a Reynolds number
            of 2900000.0 and through flap deflections from -20 to 20 degrees with a chord fraction of 25%.

            If a float, the degree of freedom is assumed to be constant at that value.
            
            If not specified, each degree of freedom defaults to the following:

                "alpha" : 0.0

                "Rey" : 1000000.0

                "Mach" : 0.0

                "trailing_flap_deflection" : 0.0

                "trailing_flap_fraction" : 0.0

            Please note that all angular degreees of freedom are in radians, rather than degrees.

            Currently, the number of steps in Reynolds number multiplied by the number of steps in Mach number
            may not exceed 12. This is due to internal limitations in Xfoil. However, due to the weak dependence
            of airfoil properties on Reynolds number, we do not expect this to be a great hinderance.

        N : int, optional
            Number of panel nodes for Xfoil to use. Defaults to 200.

        max_iter : int, optional
            Maximum iterations for Xfoil. Defaults to 100.

        x_trip : float or list, optional
            x location, non-dimensionalized by the chord length, of the boundary layer trip position. This is 
            specified for the top and bottom of the airfoil. If a float, the value is the same for the top
            and the bottom. If a list, the first list element is the top trip location and the second list element
            is the bottom trip location. Defaults to 1.0 for both.

        visc : bool, optional
            Whether to include viscosity. Defaults to True.

        N_crit : float, optional
            Critical amplification exponent for the boundary layer in Xfoil. Defaults to 9.0.

        update_type : bool, optional
            Whether to update the airfoil to use the newly computed database for calculations. Defaults to True.

        show_xfoil_output : bool, optional
            Display whatever Xfoil prints out. Defaults to False.

        show_xfoil_plots : bool, optional
            Display Xfoil plots. Defaults to True.

        resize_xfoil_window : float, optional
            resizes the xfoil window to screen size fraction. Xfoil defaults to 0.8 window/screen size.
            This variable defaults to None. Has no effect if show_xfoil_plots is False.

        CD_type : str, optional
            Which drag coefficient to read in. May be 'total', 'friction', or 'pressure'.
            Defaults to 'total'.

        verbose : bool, optional
            Defaults to True
        """

        # Set up lists of independent vars
        xfoil_args = {}
        self._dof_db_cols = {}
        num_total_runs = 1
        for dof, params in kwargs.pop("degrees_of_freedom", {}).items():
            if dof not in self._allowable_dofs:
                raise IOError("{0} is not an allowable DOF.".format(dof))
            vals, column_index = self._setup_ind_var(params)
            xfoil_args[dof] = vals
            num_total_runs *= len(vals)
            if column_index is not None:
                self._dof_db_cols[dof] = column_index

        # Get coefficients
        CL, CD, Cm = self.run_xfoil(**xfoil_args, **kwargs)

        # Determine the rows and cols in the database; each independent var and coefficient is a column to be iterpolated using scipy.interpolate.griddata
        self._num_dofs = len(list(self._dof_db_cols.keys()))
        num_cols = 3+self._num_dofs
        num_rows = CL.size-np.count_nonzero(np.isnan(CL))
        dof_sorted = sorted(self._dof_db_cols.items(), key=operator.itemgetter(1))
        self._dof_db_order = [x[0] for x in dof_sorted]

        # Arrange into 2D database
        self._data = np.zeros((num_rows, num_cols))
        database_row = 0
        coef_shape = CL.shape

        for i in range(coef_shape[0]):
            for j in range(coef_shape[1]):
                for k in range(coef_shape[2]):
                    for l in range(coef_shape[3]):
                        for m in range(coef_shape[4]):

                            # Check for nan
                            if np.isnan(CL[i,j,k,l,m]):
                                continue

                            # Append independent vars to database
                            for n, dof in enumerate(self._dof_db_order):
                                if dof == "alpha":
                                    ind = i
                                elif dof == "Rey":
                                    ind = j
                                elif dof == "Mach":
                                    ind = k
                                elif dof == "trailing_flap_deflection":
                                    ind = l
                                else:
                                    ind = m
                                self._data[database_row,n] = xfoil_args[dof][ind]
                        
                            # Append coefficients
                            self._data[database_row,self._num_dofs] = CL[i,j,k,l,m]
                            self._data[database_row,self._num_dofs+1] = CD[i,j,k,l,m]
                            self._data[database_row,self._num_dofs+2] = Cm[i,j,k,l,m]

                            database_row += 1

        # Sort by columns so the first column is perfectly in order
        dtype = ",".join(['i8' for i in range(num_cols)])
        for i in range(self._num_dofs,-1,-1):
            self._data = self._data[self._data[:,i].argsort(axis=0, kind='stable')] # 'stable' option is necessary to maintain ordering of columns not being actively sorted

        # Let the user know how much of the design space we actually got results for
        if kwargs.get("verbose", True):
            percent_success = round(self._data.shape[0]/num_total_runs*100, 2)
            print("\nDatabase generation complete.")
            print("Convergent results obtained from Xfoil for {0}% of the requested points.".format(percent_success))

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("database")


    def _setup_ind_var(self, input_dict):
        # Sets up a range of independent variables

        # Constant value
        if isinstance(input_dict, float):
            lower = input_dict
            upper = input_dict
            N = 1
            index = None
            log_step = False

        # Range
        else:
            limits = input_dict.get("range")
            lower = limits[0]
            upper = limits[1]
            N = input_dict.get("steps")
            index = input_dict.get("index", None)
            log_step = input_dict.get("log_step", False)

            # Check that the range will actually have multiple points
            if N == 1:
                raise IOError("A range with only one step may not be specified for a degree of freedom. Please give a single float instead.")
        
        if log_step:
            return list(np.logspace(np.log10(lower), np.log10(upper), N)), index
        else:
            return list(np.linspace(lower, upper, N)), index


    def export_database(self, **kwargs):
        """Exports the database generated by generate_database().

        Parameters
        ----------
        filename : str
            File to export the database to.
        """

        filename = kwargs.get("filename")

        # Check the database is there
        if hasattr(self, "_data"):

            # Create header
            header = []

            # Add degrees of freedom
            for dof in sorted(self._dof_db_cols.items(), key=operator.itemgetter(1)):
                header.append("{:<25s}".format(dof[0]))

            # Add coefficients
            header.append("{:<25s}".format('CL'))
            header.append("{:<25s}".format('CD'))
            header.append("{:<25s}".format('Cm'))
            header = " ".join(header)

            # Export
            with open(filename, 'w') as db_file:
                np.savetxt(db_file, self._data, '%25.10E', header=header)
        else:
            raise RuntimeError("No database has been generated for airfoil {0}. Please create a database before exporting.".format(self.name))


    def import_database(self, **kwargs):
        """Imports the specified database. Please note that if you have generated your own database not
        using AirfoilDatabase, angle of attack should be stored in radians, rather than degrees.

        Parameters
        ----------
        filename : str
            File to import the database from

        update_type : bool, optional
            Whether to update the airfoil to use the newly imported database for calculations. Defaults to True.
        """

        filename = kwargs.get("filename")

        # Load data from file
        with open(filename, 'r') as db_file:
            self._data = np.loadtxt(db_file)

        # Determine the column indices
        with open(filename, 'r') as db_file:
            header = db_file.readline().strip('#')
        self._dof_db_cols = {}
        self._num_dofs = 0
        for i, col_name in enumerate(header.split()):

            # Stop once we get to coefficient columns
            if col_name == "CL":
                break

            # Add
            self._dof_db_cols[col_name] = i
            self._num_dofs += 1

        # Figure out the order of the columns in the database
        dof_sorted = sorted(self._dof_db_cols.items(), key=operator.itemgetter(1))
        self._dof_db_order = [x[0] for x in dof_sorted]

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("database")


    def run_xfoil(self, **kwargs):
        """Calls Xfoil and extracts the aerodynamic coefficients at the given state.

        Parameters
        ----------
        alpha : float or list of float
            Angle(s) of attack to calculate the coefficients at in radians. Defaults to 0.0.

        Rey : float or list of float
            Reynolds number(s) to calculate the coefficients at. Defaults to 1000000.

        Mach : float or list of float
            Mach number(s) to calculate the coefficients at. Defaults to 0.0.

        trailing_flap_deflection : float or list of float
            Flap deflection(s) to calculate the coefficients at in radians. Defaults to 0.0.

        trailing_flap_fraction : float or list of float
            Flap fraction(s) to calculate the coefficients at in radians. Defaults to 0.0.

        N : int, optional
            Number of panels for Xfoil to use. Defaults to 200.

        max_iter : int, optional
            Maximum iterations for Xfoil. Defaults to 100.

        visc : bool, optional
            Whether to include viscosity. Defaults to True.

        x_trip : float or list, optional
            x location, non-dimensionalized by the chord length, of the boundary layer trip position. This is 
            specified for the top and bottom of the airfoil. If a float, the value is the same for the top
            and the bottom. If a list, the first list element is the top trip location and the second list element
            is the bottom trip location. Defaults to 1.0 for both.

        xycm : list, optional
            x-y coordinates, non-dimensionalized by the chord length, of the reference point for determining the
            moment coefficient. Defaults to the quater-chord.

        N_crit : float, optional
            Critical amplification exponent for the boundary layer in Xfoil. Defaults to 9.0.

        show_xfoil_output : bool, optional
            Display whatever Xfoil outputs from the command line interface. Defaults to False.

        show_xfoil_plots : bool, optional
            Display Xfoil plots. Defaults to True.
        
        resize_xfoil_window : float, optional
            resizes the xfoil window to screen size fraction. Xfoil defaults to 0.8 window/screen size.
            This variable defaults to None. Has no effect if show_xfoil_plots is False.

        CD_type : str, optional
            Which drag coefficient to read in. May be 'total', 'friction', or 'pressure'.
            Defaults to 'total'.

        verbose : bool, optional

        Returns
        -------
        CL : ndarray
            Coefficient of lift. First dimension will match the length of alpha, second will match Rey, etc.

        CD : ndarray
            Coefficient of drag. Dimensions same as CL.

        Cm : ndarray
            Moment coefficient. Dimensions same as CL.
        """
        N = kwargs.get("N", 200)
        max_iter = kwargs.get("max_iter", 100)
        verbose = kwargs.get("verbose", True)
        show_xfoil_output = kwargs.get("show_xfoil_output", False)
        x_trip = kwargs.get("x_trip", [1.0, 1.0])
        xycm = kwargs.get("xycm", [0.25, 0.0])
        if isinstance(x_trip, float):
            x_trip = [x_trip, x_trip]
        N_crit = kwargs.get("N_crit", 9.0)

        # Get states
        # Angle of attack
        alphas = kwargs.get("alpha", [0.0])
        if isinstance(alphas, float):
            alphas = [alphas]
        first_dim = len(alphas)
    
        # Reynolds number
        Reys = kwargs.get("Rey", [1000000.0])
        if isinstance(Reys, float):
            Reys = [Reys]
        second_dim = len(Reys)

        # Mach number
        Machs = kwargs.get("Mach", [0.0])
        if isinstance(Machs, float):
            Machs = [Machs]
        third_dim = len(Machs)

        # Flap deflections
        delta_fts = kwargs.get("trailing_flap_deflection", [0.0])
        if isinstance(delta_fts, float):
            delta_fts = [delta_fts]
        fourth_dim = len(delta_fts)

        # Flap fractions
        c_fts = kwargs.get("trailing_flap_fraction", [0.0])
        if isinstance(c_fts, float):
            c_fts = [c_fts]
        fifth_dim = len(c_fts)

        # xfoil window resizing
        resize_xfoil_window = kwargs.get('resize_xfoil_window', None)

        # Initialize coefficient arrays
        CL = np.empty((first_dim, second_dim, third_dim, fourth_dim, fifth_dim))
        CD = np.empty((first_dim, second_dim, third_dim, fourth_dim, fifth_dim))
        Cm = np.empty((first_dim, second_dim, third_dim, fourth_dim, fifth_dim))
        CL[:] = np.nan
        CD[:] = np.nan
        Cm[:] = np.nan

        # Clean up from previous iterations
        dir_list = os.listdir()
        for item in dir_list:
            if os.path.isfile(item) and ".pacc" in item or ".geom" in item:
                os.remove(item)

        # Loop through flap deflections and fractions
        if verbose:
            print("Running Xfoil...")
            print("{0:>25}{1:>25}{2:>25}".format("Percent Complete", "Flap Deflection [deg]", "Flap Fraction"))
            print(''.join(['-']*75))
        num_xfoil_runs = fourth_dim*fifth_dim
        for l, delta_ft in enumerate(delta_fts):
            for m, c_ft in enumerate(c_fts):
                
                # Clear pacc file list
                pacc_files = []
                file_id = 0
            
                # Export geometry
                outline_points = "a_{0:1.6f}_{1:1.6f}.geom".format(delta_ft, c_ft)
                #outline_points = os.path.abspath("xfoil_geom_{0:1.6f}.geom".format(delta_ft))
                self.get_outline_points(N=N, trailing_flap_deflection=delta_ft, trailing_flap_fraction=c_ft, export=outline_points, close_te=False)

                # Display update
                if verbose:
                    percent_complete = round((l*fifth_dim+m)/(num_xfoil_runs)*100)
                    print("{0:>24}%{1:>25}{2:>25}".format(percent_complete, math.degrees(delta_ft), c_ft))

                # Loop through Reynolds number
                for Re in Reys:

                    # Initialize xfoil execution
                    with sp.Popen(['xfoil'], stdin=sp.PIPE, stdout=sp.PIPE) as xfoil_process:

                        commands = []

                        # Turn off plots
                        if not kwargs.get("show_xfoil_plots", True):
                            commands += ['PLOP',
                                         'G',
                                         '']
                        elif resize_xfoil_window != None:
                            commands += ['PLOP',
                                         'W {}'.format(resize_xfoil_window),
                                         '']

                        # Read in geometry
                        commands += ['LOAD {0}'.format(outline_points),
                                     '{0}'.format(self.name)]

                        # Set panelling ratio and let Xfoil make its own panels
                        # This throws a fortran error if the plots are turned off with Xfoil 6.99
                        commands += ['PPAR',
                                     'N',
                                     '{0}'.format(N),
                                     'T',
                                     '1',
                                     '',
                                     '']

                        # Set moment reference point
                        commands += ['XYCM',
                                     str(xycm[0]),
                                     str(xycm[1])]

                        # Set viscous mode (if desired)
                        if kwargs.get("visc", True):
                            commands += ['OPER',
                                         'VISC',
                                         '']

                            # Set boundary layer parameters
                            commands += ['VPAR',
                                         'Xtr',
                                         str(x_trip[0]),
                                         str(x_trip[1]),
                                         'N',
                                         str(N_crit),
                                         '',
                                         '']

                        # Initialize PACC index
                        pacc_index = 0

                        # Loop through Mach numbers
                        for M in Machs:

                            # Polar accumulation file
                            file_id += 1
                            pacc_file = "xfoil_results_{0}.pacc".format(file_id)
                            pacc_files.append(pacc_file)

                            # Set Mach, Reynolds number, iteration limit, and polar accumulation
                            if kwargs.get("visc", True):
                                commands += ['OPER',
                                            'RE',
                                            str(Re),
                                            'MACH',
                                            str(M),
                                            'ITER {0}'.format(max_iter),
                                            'PACC',
                                            pacc_file,
                                            '']
                            else:
                                commands += ['OPER',
                                            'MACH',
                                            str(M),
                                            'ITER {0}'.format(max_iter),
                                            'PACC',
                                            pacc_file,
                                            '']

                            # Sweep angle of attack
                            if len(alphas) == 1:
                                commands.append('ALFA {0:1.6f}'.format(math.degrees(alphas[0])))

                            else:
                                # Sweep from 0 aoa up
                                zero_ind = np.argmin(np.abs(alphas))
                                if zero_ind != len(alphas)-1:
                                    for a in alphas[zero_ind:]:
                                        commands.append('ALFA {0:1.6f}'.format(math.degrees(a)))
                            
                                # Reset solver
                                commands.append('INIT')

                                # Sweep from 0 aoa down
                                if zero_ind != 0:
                                    for a in alphas[zero_ind-1::-1]:
                                        commands.append('ALFA {0:1.6f}'.format(math.degrees(a)))
                            
                            # Reset solver
                            commands.append('INIT')

                            # End polar accumulation
                            commands += ['PACC {0}'.format(pacc_index),
                                         '']
                            pacc_index += 1

                        # Finish commands
                        commands += ['',
                                     'QUIT']

                        # Run Xfoil
                        xfoil_input = '\r'.join(commands).encode('utf-8')
                        response = xfoil_process.communicate(xfoil_input)

                        # Show output
                        if show_xfoil_output:
                            print(response[0].decode('utf-8'))
                            if response[1] is not None:
                                print(response[1].decode('utf-8'))

                # Clean up geometry
                os.remove(outline_points)

                # Read in files and store arrays
                for filename in pacc_files:

                    # Read in file
                    try:
                        alpha_i, CL_i, CD_i, Cm_i, Re_i, M_i = self.read_pacc_file(filename, CD_type=kwargs.get('CD_type', 'total'))
                    except FileNotFoundError:
                        warnings.warn("Couldn't find results file {0}. Usually an indication of Xfoil crashing.".format(filename))
                        continue

                    # Determine the Reynolds and Mach indices
                    j = min(range(len(Reys)), key=lambda i: abs(Reys[i]-Re_i))

                    k = min(range(len(Machs)), key=lambda i: abs(Machs[i]-M_i))

                    # Loop through alphas
                    i_true = 0
                    for i_iter, alpha in enumerate(alpha_i):

                        # Line up with our original independent alpha, as Xfoil does not output a non-converged result
                        i_true = min(range(len(alphas)), key=lambda i: abs(alphas[i]-alpha))

                        CL[i_true,j,k,l,m] = CL_i[i_iter]
                        CD[i_true,j,k,l,m] = CD_i[i_iter]
                        Cm[i_true,j,k,l,m] = Cm_i[i_iter]

                    # Interpolate missing values
                    for i, alpha in enumerate(alpha_i):
                        if np.isnan(CL[i,j,k,l,m]): # Result did not converge

                            # Mid-value
                            if i != 0 and i != len(alpha_i)-1:
                                weight = (alpha_i[i+1]-alpha)/(alpha_i[i+1]-alpha_i[i-1])
                                CL[i,j,k,l,m] = CL[i-1,j,k,l,m]*(1-weight)+CL[i+1,j,k,l,m]*weight
                                CD[i,j,k,l,m] = CD[i-1,j,k,l,m]*(1-weight)+CD[i+1,j,k,l,m]*weight
                                Cm[i,j,k,l,m] = Cm[i-1,j,k,l,m]*(1-weight)+Cm[i+1,j,k,l,m]*weight

                    # Clean up polar files
                    os.remove(filename)

        return CL, CD, Cm


    def read_pacc_file(self, filename, CD_type='total'):
        """Reads in and formats an Xfoil polar accumulation file.

        Parameters
        ----------
        filename : str
            File to read in.

        CD_type : str, optional
            Which drag coefficient to read in. May be 'total', 'friction', or 'pressure'.
            Defaults to 'total'.

        Returns
        -------
        alpha : list
            List of angles of attack from the accumulation polar.

        CL : list
            Coefficient of lift at each alpha.

        CD : list
            Coefficient of drag at each alpha.
        
        Cm : list
            Moment coefficient at each alpha.

        Re : float
            Reynolds number for the polar.

        M : float
            Mach number for the polar.
        """

        # Open file
        with open(filename, 'r') as file_handle:

            # Read in line by line
            lines = []
            line = file_handle.readline()
            while line:
                lines.append(line)
                line = file_handle.readline()

        # Find Mach and Reynolds number
        mr_line = lines[8].split()
        M = float(mr_line[2])
        Re = float(''.join(mr_line[5:8]))

        # Collect alpha and coefficients
        alpha = []
        CL = []
        CD = []
        Cm = []
        for line in lines[12:]:
            split_line = line.split()
            alpha.append(math.radians(float(split_line[0])))
            CL.append(float(split_line[1]))
            if CD_type=='total':
                CD.append(float(split_line[2]))
            elif CD_type=='pressure':
                CD.append(float(split_line[3]))
            elif CD_type=='friction':
                CD.append(float(split_line[2])-float(split_line[3]))
            Cm.append(float(split_line[4]))

        # Sort in alpha
        sorted_indices = np.argsort(alpha)
        alpha = np.array(alpha)[sorted_indices]
        CL = np.array(CL)[sorted_indices]
        CD = np.array(CD)[sorted_indices]
        Cm = np.array(Cm)[sorted_indices]

        return alpha, CL, CD, Cm, Re, M


    def _create_filled_database(self):
        # Fills in missing values in the database to make it a consistent d-dimensional array.

        # Initialize storage for independent vars
        self._dof_filled = []
        for i in range(self._num_dofs):
            self._dof_filled.append([])

        # Gather independent vars
        for i in range(self._data.shape[0]):
            for j in range(self._num_dofs):

                # Check if the value is already there
                if not self._data[i,j] in self._dof_filled[j]:
                    self._dof_filled[j].append(self._data[i,j])

        # Sort independent vars and initialize filled array
        shape = []
        for dof in self._dof_filled:
            dof.sort()
            shape.append(len(dof))
        filled_CL = np.zeros(tuple(shape))
        filled_CD = np.zeros(tuple(shape))
        filled_Cm = np.zeros(tuple(shape))
        N = filled_CL.size

        # Create grid of independent vars
        raw_grid = np.meshgrid(*self._dof_filled)

        # Parse independent vars for passing to getters
        params = {}
        for i, dof in enumerate(self._dof_db_order):
            params[dof] = raw_grid[i].flatten()

        # Fill in values
        filled_CL_view = filled_CL.reshape(N)
        filled_CL_view[:] = self.get_CL(**params)
        filled_CD_view = filled_CD.reshape(N)
        filled_CD_view[:] = self.get_CD(**params)
        filled_Cm_view = filled_Cm.reshape(N)
        filled_Cm_view[:] = self.get_Cm(**params)

        # Huh. Turns out I don't actually need this, so I'm not going to bother developing it further. But I'll keep it here in case it becomes useful


    def generate_polynomial_fit(self, **kwargs):
        """Generates a set of multivariable polynomials using least-squares regression to approximate the database.
        Note: This airfoil must have a database already for fits to be created.

        Parameters
        ----------
        CL_degrees : dict or str, optional
            If dict, order of fit polynomial for the coefficient of lift for each degree of freedom,
            formatted as

            {
                "<DOF1_NAME>" : <ORDER>,
                "<DOF2_NAME>" : <ORDER>,
                ...
            }

            Orders must be integers. Defaults to 1 for any not specified.

            Can also be specified as "auto". In this case, the fit degrees will be determined automatically
            using the method described in Morelli, "Global Nonlinear Aerodynamic Modeling Using
            Multivariate Orthogonal Functions," Journal of Aircraft, 1995. The algorithm tried to minimize
            the RMS error between the data and the prediction while also minimizing the degree of the fit. 
            This will automatically determine the fit order for each degree of freedom.

        CD_degrees : dict, optional
            Same as CL_degrees.

        Cm_degrees : dict, optional
            Same as CL_degrees.

        CL_kwargs : dict, optional
            keyword arguments sent to the CL polynomial fit function
            
            When CL_degrees is specified as "auto" then CL_kwargs can be
            
                "max_order" : int, optional
                    gives the max order of polynomial for any one of the independent varialbes
                    to try. Defaults to 6.
                "tol" : float, optional
                    Gives the cut-off value for any polynomial coefficient to not be included
                    in the final results. If a coefficient has an absolute value below tol,
                    it won't be included. Defaults to 1e-12.
                "sigma" : float, optional
                    value used to determine the trade off between how good of a fit to perform
                    and how many terms to keep. Defaults to None, which causes the function to
                    calculate sigma automatically using the mean squared of the difference of
                    the independent variable values with respect to the mean independent
                    variable value of the dataset
                "sigma_multiplier" : float, optional
                    term multiplied onto sigma to change it's value. Allows using a multiple
                    of the automatically determined sigma value. Defaults to 1.
            
            Otherwise CL_kwargs could be
            
                "interaction" : boolean, optional
                    value with default set to True. This variable determines whether or not
                    interaction terms are included in the fit function. If set to True,
                    interaction terms up the max order for each independent variable are
                    included, i.e. if Nvec = [3,2] then the highest interaction term included
                    is x_1^3*x_2^2. Specific interaction terms can be omitted using the
                    constraints input
                "sym" : list, optional
                    Defaults to an empty list. If used, the length should be V and each element
                    should contain a boolean, True or False. The ith element determines if the
                    ith independent variable is symmetric either even or odd, which is
                    determined by the order given in Nvec. This will also remove the
                    cooresponding interaction terms if they are enabled.
                "sym_same" : list, optional
                    Defaults as an empty list. If used, the entries in the list should be
                    tuples with two integers. The integers represent the independent variables
                    that the "same" symmetry condition will be applied. The "same" symmetry
                    ensures all interaction terms with exponents of the two independent
                    variables that are either odd-odd or even-even to be forced to zero
                "sym_diff" : = list, optional
                    Defaults as an empty list. Similar to "sym_same" except it enforces the
                    "diff" symmetry condition which ensures all interaction terms with exponents
                    of the two independent variables that are either odd-even or even-odd to be
                    forced to zero
                "zeroConstraints" : list, optional
                    Defaults as an empty list. Entries in the list contain integer tuples of
                    length V. The integer values represent the powers of the independent variables
                    whose coefficient will be forced to 0 before the best fit calculations are
                    performed, allowing the user to omit specific interaction terms or regular
                    polynomial terms
                "constraints" : list, optional
                    Defaults to an empty list. Entries in the list contain tuples of length 2.
                    The first entry is a list of integers that represent the powers of the
                    independent variables whose coefficient will then be forced to be equal to the
                    second entry in the tuple, which should be a float.
                "percent" : boolean, optional
                    Default set to False. When set to True the least squares is performed on the
                    percent error squared. This option should not be used if y contains any zero
                    or near zero values, as this might cause a divide by zero error.
                "weighting" : function, optional
                    Defaults to None. If given, weighting should be a function that takes as
                    arguments x, y, and p where x and y are the independent and dependent
                    variables defined above and p is the index representing a certain data point.
                    weighting should return a 'weighting factor' that determines how important
                    that datapoint is. Returning a '1' weights the datapoint normally.
        
        CD_kwargs : dict, optional
            Same as CL_kwargs

        Cm_kwargs : dict, optional
            Same as CL_kwargs

        update_type : bool, optional
            Whether to update the airfoil to use the newly computed polynomial fits for calculations. Defaults to True.

        verbose : bool, optional
        """

        # Check for database
        if not hasattr(self, "_data"):
            raise RuntimeError("No database found! Please generate or import a database before trying to create polynomial fits.")

        # Determine what the maximum fit order is for autoPolyFit
        CL_degrees = kwargs.pop("CL_degrees", {})
        CD_degrees = kwargs.pop("CD_degrees", {})
        Cm_degrees = kwargs.pop("Cm_degrees", {})
        CL_kwargs  = kwargs.pop("CL_kwargs", {})
        CD_kwargs  = kwargs.pop("CD_kwargs", {})
        Cm_kwargs  = kwargs.pop("Cm_kwargs", {})
        verbose = kwargs.pop('verbose', True)
        if verbose: print('Generating Polynomial Fits for airfoil {}'.format(self.name))
        CL_kwargs['verbose'] = verbose
        CD_kwargs['verbose'] = verbose
        Cm_kwargs['verbose'] = verbose

        # CL
        if verbose: print('Performing CL curve fit')
        if CL_degrees=="auto":
            self._CL_poly_coefs, self._CL_degrees, self._CLfit_R2 = autoPolyFit(self._data[:,:self._num_dofs], self._data[:, self._num_dofs], **CL_kwargs)

        elif isinstance(CL_degrees, dict):

            # Sort fit degrees
            self._CL_degrees = []
            for dof in self._dof_db_order:
                self._CL_degrees.append(CL_degrees.get(dof, 1))

            # Generate
            self._CL_poly_coefs, self._CLfit_R2 = multivariablePolynomialFit(self._CL_degrees, self._data[:,:self._num_dofs], self._data[:, self._num_dofs], **CL_kwargs)

        else:
            raise IOError("Fit degree specification must be 'auto' or type(dict). Got {0} type {1}.".format(CL_degrees, type(CL_degrees)))
        
        # CD
        if verbose: print('Performing CD curve fit')
        if CD_degrees=="auto":
            self._CD_poly_coefs, self._CD_degrees, self._CDfit_R2 = autoPolyFit(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+1], **CD_kwargs)

        elif isinstance(CL_degrees, dict):

            # Sort fit degrees
            self._CD_degrees = []
            for dof in self._dof_db_order:
                self._CD_degrees.append(CD_degrees.get(dof, 1))

            # Generate
            self._CD_poly_coefs, self._CDfit_R2 = multivariablePolynomialFit(self._CD_degrees, self._data[:,:self._num_dofs], self._data[:,self._num_dofs+1], **CD_kwargs)

        else:
            raise IOError("Fit degree specification must be 'auto' or type(dict). Got {0} type {1}.".format(CL_degrees, type(CL_degrees)))
        
        # Cm
        if verbose: print('Performing Cm curve fit')
        if Cm_degrees=="auto":
            self._Cm_poly_coefs, self._Cm_degrees, self._Cmfit_R2 = autoPolyFit(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+2], **Cm_kwargs)

        elif isinstance(Cm_degrees, dict):

            # Sort fit degrees
            self._Cm_degrees = []
            for dof in self._dof_db_order:
                self._Cm_degrees.append(Cm_degrees.get(dof, 1))

            # Generate polynomial fit
            self._Cm_poly_coefs, self._Cmfit_R2 = multivariablePolynomialFit(self._Cm_degrees, self._data[:,:self._num_dofs], self._data[:, self._num_dofs+2], **Cm_kwargs)

        # Store limits
        self._dof_limits = []
        for i in range(self._num_dofs):
            self._dof_limits.append([np.min(self._data[:,i]), np.max(self._data[:,i])])

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("poly_fit")
        
        self._CLfit_RMS, self._CLfit_RMSN = multivariableRMS(self._data[:,:self._num_dofs], self._data[:,self._num_dofs], self._CL_poly_coefs, self._CL_degrees, verbose=verbose)
        self._CDfit_RMS, self._CDfit_RMSN = multivariableRMS(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+1], self._CD_poly_coefs, self._CD_degrees, verbose=verbose)
        self._Cmfit_RMS, self._Cmfit_RMSN = multivariableRMS(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+2], self._Cm_poly_coefs, self._Cm_degrees, verbose=verbose)
        
        if verbose:
            print('\nCL fits\n'+'='*20)
            print('R^2 : {}'.format(self._CLfit_R2))
            print('RMS : {}'.format(self._CLfit_RMS))
            print('RMSN: {}\n'.format(self._CLfit_RMSN))
            print('CD fits\n'+'='*20)
            print('R^2 : {}'.format(self._CDfit_R2))
            print('RMS : {}'.format(self._CDfit_RMS))
            print('RMSN: {}\n'.format(self._CDfit_RMSN))
            print('Cm fits\n'+'='*20)
            print('R^2 : {}'.format(self._Cmfit_R2))
            print('RMS : {}'.format(self._Cmfit_RMS))
            print('RMSN: {}\n'.format(self._Cmfit_RMSN))


    def export_polynomial_fits(self, **kwargs):
        """Save the polynomial fit to a JSON object.

        Parameters
        ----------
        filename : str
            JSON object to write polynomial fit data to.

        write_limits : bool, optional
            Whether to limit the polynomial fits based on the original range of data.
            Defaults to True.

        """

        # Get filename
        filename = kwargs.get("filename")

        # Create export dictionary
        export = {}
        export["tag"] = "Polynomial fit to database for {0} airfoil.".format(self.name)
        export["degrees_of_freedom"] = self._dof_db_order
        if kwargs.get("write_limits"):
            export["limits"] = self._dof_limits
        export["defaults"] = self._dof_defaults
        export["fit_degrees"] = {}
        export["fit_degrees"]["CL"] = self._CL_degrees
        export["fit_degrees"]["CD"] = self._CD_degrees
        export["fit_degrees"]["Cm"] = self._Cm_degrees
        export['fit_error'] = {}
        export['fit_error']['CL'] = {}
        export['fit_error']['CL']['R^2'] = self._CLfit_R2
        export['fit_error']['CL']['RMS'] = self._CLfit_RMS
        export['fit_error']['CL']['RMSN'] = self._CLfit_RMSN
        export['fit_error']['CD'] = {}
        export['fit_error']['CD']['R^2'] = self._CDfit_R2
        export['fit_error']['CD']['RMS'] = self._CDfit_RMS
        export['fit_error']['CD']['RMSN'] = self._CDfit_RMSN
        export['fit_error']['Cm'] = {}
        export['fit_error']['Cm']['R^2'] = self._Cmfit_R2
        export['fit_error']['Cm']['RMS'] = self._Cmfit_RMS
        export['fit_error']['Cm']['RMSN'] = self._Cmfit_RMSN
        export["fit_coefs"] = {}
        export["fit_coefs"]["CL"] = list(self._CL_poly_coefs)
        export["fit_coefs"]["CD"] = list(self._CD_poly_coefs)
        export["fit_coefs"]["Cm"] = list(self._Cm_poly_coefs)

        # Export data
        with open(filename, 'w') as export_file_handle:
            json.dump(export, export_file_handle, indent=4)


    def import_polynomial_fits(self, **kwargs):
        """Read in polynomial fit data from a JSON object.

        Parameters
        ----------
        filename : str
            JSON object to read polynomial fit data from.

        update_type : bool, optional
            Whether to update the airfoil to use the newly imported polynomial fits for calculations. Defaults to True.

        """

        # Get filename
        filename = kwargs.get("filename")

        # Read in data
        with open(filename, 'r') as import_file_handle:
            input_dict = json.load(import_file_handle)

        # Parse input dict
        self._dof_db_order = input_dict["degrees_of_freedom"]
        self._num_dofs = len(self._dof_db_order)
        self._dof_limits = input_dict.get("limits", [[-np.inf, np.inf]]*self._num_dofs)
        self._CL_degrees = input_dict["fit_degrees"]["CL"]
        self._CD_degrees = input_dict["fit_degrees"]["CD"]
        self._Cm_degrees = input_dict["fit_degrees"]["Cm"]
        self._CL_poly_coefs = np.array(input_dict["fit_coefs"]["CL"])
        self._CD_poly_coefs = np.array(input_dict["fit_coefs"]["CD"])
        self._Cm_poly_coefs = np.array(input_dict["fit_coefs"]["Cm"])
        if isinstance(input_dict.get('fit_error', None), dict):
            if isinstance(input_dict['fit_error'].get('CL', None), dict):
                self._CLfit_R2 = input_dict['fit_error']['CL'].get('R^2', None)
                self._CLfit_RMS = input_dict['fit_error']['CL'].get('RMS', None)
                self._CLfit_RMSN = input_dict['fit_error']['CL'].get('RMSN', None)
            if isinstance(input_dict['fit_error'].get('CD', None), dict):
                self._CDfit_R2 = input_dict['fit_error']['CD'].get('R^2', None)
                self._CDfit_RMS = input_dict['fit_error']['CD'].get('RMS', None)
                self._CDfit_RMSN = input_dict['fit_error']['CD'].get('RMSN', None)
            if isinstance(input_dict['fit_error'].get('Cm', None), dict):
                self._Cmfit_R2 = input_dict['fit_error']['Cm'].get('R^2', None)
                self._Cmfit_RMS = input_dict['fit_error']['Cm'].get('RMS', None)
                self._Cmfit_RMSN = input_dict['fit_error']['Cm'].get('RMSN', None)

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("poly_fit")


    def _get_polynomial_data(self, coef_index, **kwargs):
        # Determines the value of the given coefficient from the polynomial fit
        # coef_index | coef
        #   0        |  CL
        #   1        |  CD
        #   2        |  Cm

        # Stack up independent vars
        ind_vars = []
        N = 1
        for dof in self._dof_db_order:

            # Get independent variable values
            ind_var = kwargs.get(dof, self._dof_defaults[dof])
            
            # Check for array of size 1
            if not np.isscalar(ind_var) and len(ind_var) == 1:
                ind_vars.append(ind_var.item())
            else:
                ind_vars.append(ind_var)

            # Update max size
            if not np.isscalar(ind_var):
                N = max(N, len(ind_var))

        # Fill any values
        if N > 1:
            for i, ind_var in enumerate(ind_vars):
                if np.isscalar(ind_var):
                    ind_vars[i] = np.full(N, ind_var)

        # Setup input matrix
        if N == 1:
            x = np.array(ind_vars)[:,np.newaxis]
        else:
            x = np.array(ind_vars)

        # Get data
        if coef_index == 0:
            coef = multivariablePolynomialFunction(self._CL_poly_coefs, self._CL_degrees, x)
        elif coef_index == 1:
            coef = multivariablePolynomialFunction(self._CD_poly_coefs, self._CD_degrees, x)
        elif coef_index == 2:
            coef = multivariablePolynomialFunction(self._Cm_poly_coefs, self._Cm_degrees, x)

        # Check limits
        if self._raise_poly_bounds_error:
            for i in range(N):
                for j in range(self._num_dofs):
                    if x[j,i] > self._dof_limits[j][1] or x[j,i] < self._dof_limits[j][0]:
                        coef[i] = np.nan

            # Check for going out of bounds
            if np.isnan(coef).any():
                raise PolyFitBoundsError(self.name, np.argwhere(np.isnan(coef)).flatten(), kwargs)

        return coef


    def generate_linear_model(self, **kwargs):
        """Creates a linearized model of the airfoil coefficients in alpha. Pulls from the
        database or poly_fit information to generate this model. Cannot be used on a type
        "linear" airfoil.
        
        linear_limits : list, optional
            Limits in alpha for which the behavior of the airfoil can be considered linear. If not
            given, the user will be prompted to graphically select this region. Given in degrees.

        update_type : bool, optional
            Whether to change the type of the airfoil to "linear" once the model is determined.
            Defaults to True.

        plot_model : bool, optional
            Whether to display a polar of the linear region determined. Defaults to False.

        Rey : float, optional
            Reynolds number at which to evaluate the model.

        Mach : float, optional
            Mach number at which to evaluate the model.
        """

        # Check for correct type
        if self._type == "linear":
            raise RuntimeError("generate_linear_model() cannot be called on a 'linear' type airfoil.")

        # Determine range of alpha
        linear_limits = kwargs.get("linear_limits", None)
        if linear_limits is None:
            alpha = np.linspace(-20.0, 20.0, 30)
        else:
            alpha = np.linspace(linear_limits[0], linear_limits[1], 30)

        # Generate dataset
        CL = np.zeros(30)
        Cm = np.zeros(30)
        CD = np.zeros(30)
        for i, a in enumerate(alpha):
            try:
                CL[i] = self.get_CL(alpha=np.radians(a), **kwargs)
                Cm[i] = self.get_Cm(alpha=np.radians(a), **kwargs)
                CD[i] = self.get_CD(alpha=np.radians(a), **kwargs)
            except DatabaseBoundsError:
                continue

        # Plot dataset for user to select linear region
        if linear_limits is None:

            # Define picker
            self._selected_ind = []
            def on_pick(event):

                # Get index
                i = int(event.ind[0])
                self._selected_ind.append(i)

                # Add x
                fig.axes[0].plot(alpha[i], CL[i], 'rx')

                # Check if we have enough
                if len(self._selected_ind) >= 2:
                    plt.close(fig)

            # Display
            plt.ion()
            fig, ax = plt.subplots()
            ax.plot(alpha, CL, 'bo', picker=3)
            plt.xlabel("Alpha [deg]")
            plt.ylabel("Lift Coefficient")
            plt.title("To generate a linear model, select the lower and upper limits of the linear region.")
            fig.canvas.mpl_connect('pick_event', on_pick)
            plt.show(block=True)
            plt.ioff()

            # Trim arrays
            self._selected_ind = sorted(self._selected_ind)
            if len(self._selected_ind) != 2:
                raise RuntimeError("No points were selected to determine the linear region.")
            alpha = np.radians(alpha[self._selected_ind[0]:self._selected_ind[1]+1])
            CL = CL[self._selected_ind[0]:self._selected_ind[1]+1]
            Cm = Cm[self._selected_ind[0]:self._selected_ind[1]+1]
            CD = CD[self._selected_ind[0]:self._selected_ind[1]+1]

        else:
            alpha = np.radians(alpha)

        # Get CL model
        coef_array = np.polyfit(alpha, CL, 1)
        self._CLa = coef_array[0]
        self._aL0 = -coef_array[1]/self._CLa
        self._CL_max = np.max(CL)

        # Get Cm model
        coef_array = np.polyfit(alpha, Cm, 1)
        self._Cma = coef_array[0]
        self._CmL0 = self._Cma*self._aL0+coef_array[1]

        # Get CD model
        coef_array = np.polyfit(CL, CD, 2)
        self._CD0 = coef_array[2]
        self._CD1 = coef_array[1]
        self._CD2 = coef_array[0]

        # Plot model within linear region
        if kwargs.get("plot_model", False):

            # CL
            plt.close('all')
            fig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3)
            fig.suptitle("Linear Model for {0}".format(self.name))
            ax0.set_title("CL")
            ax0.plot(alpha, CL, "gx", label="Data")
            ax0.plot(alpha, alpha*self._CLa+self._aL0, "g-", label="Model")
            ax0.legend()
            ax0.set_xlabel("Angle of Attack [rad]")
            ax0.set_ylabel("Lift Coefficient")

            # Cm
            ax1.set_title("Cm")
            ax1.plot(alpha, Cm, 'bx', label="Data")
            ax1.plot(alpha, (alpha-self._aL0)*self._Cma+self._CmL0, "b-", label="Model")
            ax1.legend()
            ax1.set_xlabel("Angle of Attack [rad]")
            ax1.set_ylabel("Moment Coefficient")

            # CD
            ax2.set_title("CD")
            ax2.plot(CL, CD, 'rx', label="Data")
            ax2.plot(CL, self._CD0+self._CD1*CL+self._CD2*CL*CL, 'r-', label="Model")
            ax2.legend()
            ax2.set_xlabel("Lift Coefficient")
            ax2.set_ylabel("Drag Coefficient")
            plt.show()

        # Update type
        if kwargs.get("update_type", True):
            self._type = "linear"


    def export_linear_model(self, **kwargs):
        """Exports the linear coefficients used to predict the behavior of the airfoil.

        Parameters
        ----------
        filename : str
            JSON file to export the model data to.
        """

        # Check there is a model to export
        if not hasattr(self, "_aL0"):
            raise RuntimeError("A linear model for {0} could not be exported because it has none.".format(self.name))

        # Parse coefficients
        model_dict = {
            "aL0" : self._aL0,
            "CLa" : self._CLa,
            "CmL0" : self._CmL0,
            "Cma" : self._Cma,
            "CD0" : self._CD0,
            "CD1" : self._CD1,
            "CD2" : self._CD2,
            "CL_max" : self._CL_max
        }

        # Export
        filename = kwargs.get("filename")
        with open(filename, 'w') as export_file_handle:
            json.dump(model_dict, export_file_handle, indent=4)
</"file: python/AirfoilDatabase/airfoil_db/airfoil.py">

<"file: python/AirfoilDatabase/airfoil_db/exceptions.py">"""Custom exceptions used in the airfoil class."""

class DatabaseBoundsError(Exception):
    """An exception thrown when the inputs to the airfoil database fall outside the database bounds.

    Attributes
    ----------
    airfoil : str
        The name of the airfoil for which this exception occurred.

    inputs_dict : dict
        The arguments passed to the airfoil.

    exception_indices : list
        The indices at which the arguments fell outside the database bounds.

    message : str
        A message about the error.
    """

    def __init__(self, airfoil, exception_indices, inputs_dict):
        self.airfoil = airfoil
        self.exception_indices = exception_indices
        self.inputs_dict = inputs_dict
        self.message = "The inputs to the airfoil database fell outside the bounds of available data."
        super().__init__(self.message)


    def __str__(self):
        return self.message+" Airfoil: {0}".format(self.airfoil)


class PolyFitBoundsError(Exception):
    """An exception thrown when the inputs to the airfoil polynomial fits fall outside the bounds.

    Attributes
    ----------
    airfoil : str
        The name of the airfoil for which this exception occurred.

    inputs_dict : dict
        The arguments passed to the airfoil.

    exception_indices : list
        The indices at which the arguments fell outside the bounds.

    message : str
        A message about the error.
    """

    def __init__(self, airfoil, exception_indices, inputs_dict):
        self.airfoil = airfoil
        self.exception_indices = exception_indices
        self.inputs_dict = inputs_dict
        self.message = "The inputs to the airfoil polynomial fits fell outside the bounds of available data."
        super().__init__(self.message)


    def __str__(self):
        return self.message+" Airfoil: {0}".format(self.airfoil)


class CamberSolverNotConvergedError(Exception):
    """An exception thrown when the camber line solver fails to converge.

    Attributes
    ----------
    airfoil : str
        The name of the airfoil for which this exception occurred.

    final_error : float
        The final approximate error of the solver.

    message : str
        A message about the error.
    """

    def __init__(self, airfoil, final_error):
        self.airfoil = airfoil
        self.final_error = final_error
        self.message = "The camber line solver for {0} failed to converge. Final error: {1}".format(self.airfoil, self.final_error)
        super().__init__(self.message)</"file: python/AirfoilDatabase/airfoil_db/exceptions.py">

<"file: python/AirfoilDatabase/airfoil_db/poly_fits.py">"""
Generic Multivariable Polynomial Fit Using Least Squares Regression With
Full Control Of Interaction Terms And Constraint Capabilities

This module contains functions to calculate the polynomial coefficients for 
an arbitrary order polynomial curve fit to a dataset with an arbitrary
number of independent variables.

Routine Listings
-----------------

multivariablePolynomialFit : function for calculating a curve fit to data
    with an arbitrary number of independent variables

multivariablePolynomialFunction : function for calculating a polynomial with
    an arbitrary number of independent variables

multivariableR2 : function calculating the coefficient of determination
    value, or R^2 value, of a polynomial fit of an arbitrary number of
    independent variables

multivariableRMS : function calculating an RMS (root, mean, squared) error
    and a custom RMSN (root, mean, squared, normalized) error where
    normalized means the error is divided by the mean of the absolute value
    of the dependent variables, for a multidimensional polynomial function

compose_j : function used by the multivariable series of functions that
    composes the n values of the independent variables into the counter j,
    this function can also be used for the nhat values and i

decompose_j : function used by the multivariable seris of functions that
    decomposes the counter j into the different n values for the independent
    variables, this function can also be used for i and the nhat values.
"""
import numpy as np
from datetime import datetime as dt
from datetime import timedelta as td


def multivariablePolynomialFit(Nvec, xx, yy ,interaction=True, sym=[], sym_same=[], sym_diff=[], zeroConstraints=[], constraints=[], percent=False, weighting=None, verbose=True):
    """
    inputs
    
        Nvec = list with a length V equal to the number of independent
            variables. The ith element values are integers of polynomial
            order of the ith independent variable
        x = numpy matrix of size k by V, where k is the total number of
            points in the dataset. The ith column represents the ith
            independent variable values with the rows representing the
            different data points
        y = list with a length of k with the dependent variable values
        interaction = boolean value with default set to False. This variable
            determines whether or not interaction terms are included in the
            fit function. If set to True, interaction terms up the max order
            for each independent variable are included, i.e. if Nvec = [3,2]
            then the highest interaction term included is x_1^3*x_2^2.
            Specific interaction terms can be omitted using the constraints
            input
        sym = optional list that defaults as an empty list. If used, the
            length should be V and each element should contain a boolean,
            True or False. The ith element determines if the ith independent
            variable is symmetric either even or odd, which is determined by
            the order given in Nvec. This will also remove the cooresponding
            interaction terms if they are enabled.
        sym_same = optional list that defaults as an empty list. If used,
            the entries in the list should be tuples with two integers. The
            integers represent the independent variables that the "same"
            symmetry condition will be applied. The "same" symmetry forces
            all interaction terms
        sym_diff = optional list that defaults as an empty list. 
        zeroConstraints = an optional list that defaults as an empty list.
            Entries in the list contain integer tuples of length V. The
            integer values represent the powers of the independent variables
            whose coefficient will be forced to 0 before the best fit
            calculations are performed, allowing the user to omit specific
            interaction terms or regular polynomial terms
        constraints = an optional list that defaults to an empty list.
            Entries in the list contain tuples of length 2. The first entry 
            is a list of integers that represent the powers of the
            independent variables whose coefficient will then be forced to
            be equal to the second entry in the tuple, which should be a
            float.
        percent = boolean value with default set to False. When set to True
            the least squares is performed on the percent error squared.
            This option should not be used if y contains any zero or near
            zero values, as this might cause a divide by zero error.
        weighting = optional callable function that defaults to None. If
            given, weighting should be a function that takes as arguments:
            x, y, and p where x and y are the independent and dependent
            variables defined above and p is the index representing a
            certain data point. weighting should return a 'weighting factor'
            that determines how important that datapoint is. Returning a '1'
            weights the datapoint normally.
    
    returns
    
        a = list of the polynomial coefficients. 'a' has a length equal to
            the products of the n_vec elements plus one.
            i.e.: (n_vec0+1)*(n_vec1+1)*...
        r2 = the coefficient of determination, also referred to as the R^2
            value. A value of 1 means the polynomial given by 'a' fits the
            data perfectly
    """
    # input variables and setup calculations
    ########################################################################
    x = np.copy(xx)
    y = np.copy(yy)
    # calculate number of dimensions used
    if type(Nvec) != list:
        Nvec = [Nvec]
    V = len(Nvec)
    # calculate the number of points in dataset
    k = len(y)
    # check for inconsistencies in dimensions from input variables
    if len(x.shape) == 1:
        x = np.transpose([x])
    if x.shape[1] != V: raise ValueError('Dimensions for V don\'t match between n_vec and x. Lenght of n_vec and number of columns of x should equal the number of independent variables used, V.')
    if x.shape[0] != k: raise ValueError('Number of rows between x and y don\'t agree! The number of rows should be the total number of points, k, of the dataset.')
    # calculate the length of the coefficient list to be returned
    # J = 1
    # for n in Nvec:
        # J *= n + 1
    J = calcJ(Nvec)
    # if sym wasn't given, initialize it to False values
    if type(sym) != list: sym = [sym]
    if sym == []:
        sym = [False] * V
    elif len(sym) != V:
        raise ValueError('Length of sym doesn\'t match the number of dimensions, V.')
    # create active list
    ########################################################################
    # set active to empty list
    active = []
    # loop through j values
    for j in range(J):
        # calculate the n values
        n = decompose_j(j, Nvec)
        # check if n is a constraint then continue on to the next j
        if tuple(n) in zeroConstraints: continue
        # check if j is an interaction term and if interactions aren't allowed then continue on to the next j
        if sum(n) != max(n) and not interaction: continue
        # initialize flag variable to false
        flag = False
        # loop through the sym list to find the symmetry constraints
        for count,symm in enumerate(sym):
            # check if flag has been tripped, then continue to the next j if it has
            if flag: break
            # check for a symmetry constraint
            if symm:
                # check if the order of the count-th independent variable is even
                if Nvec[count]%2 == 0:
                    # check if the n value of the count-th independent variable is odd
                    if n[count]%2 == 1:
                        flag = True
                # this else block means the order of the count-th independent variable is odd
                else:
                    # check if the n value of the count-th independent variable is even
                    if n[count]%2 == 0:
                        flag = True
        # if the flag has been tripped, skip to the next j value
        if flag: continue
        # loop through sym_same constraints
        for val in sym_same:
            # check if the n values from both variables given in val are even, then trip flag
            if n[val[0]]%2 == 0 and n[val[1]]%2 == 0:
                flag = True
            # check if the n values from both variables given in val are odd, then trip flap
            if n[val[0]]%2 == 1 and n[val[1]]%2 == 1:
                flag = True
        # loop through sym_diff constraints
        for val in sym_diff:
            # check if the n values from both variables given in val are even and odd, then trip flag
            if n[val[0]]%2 == 0 and n[val[1]]%2 == 1:
                flag = True
            # check if the n values from both variables given in val are odd and even, then trip flap
            if n[val[0]]%2 == 1 and n[val[1]]%2 == 0:
                flag = True
        # if flag hasn't been tripped, append j value onto the active list
        if not flag: active.append(j)
    #create constraints list
    ########################################################################
    con = {}
    for n,val in constraints:
        j = compose_j(n, Nvec)
        con['{}'.format(j)] = val
    #create A matrix and b vector
    ########################################################################
    # initialize A matrix
    A = np.zeros( ( len(active),len(active) ) )
    # initialize b vector
    b = np.zeros( len(active) )
    # setup progress bar for display
    if verbose: prog = oneLineProgress(len(active), msg='Building Matrix Eq for MultiPolyFit')
    # loop through i values
    for ii,i in enumerate(active):
        # calculate the nhat values
        nhat = decompose_j(i, Nvec)
        # loop through the j values
        for jj,j in enumerate(active):
            # calculate the n values
            n = decompose_j(j, Nvec)
            # calcualte Aij entry
            #####################
            
            if str(i) in con:
                if i == j:
                    A[ii,jj] = 1.
                else:
                    A[ii,jj] = 0.
            else:
                # initialize summ to 0
                summ = 0.
                # loop through points in dataset
                for p in range(1,k+1):
                    # initialize product series variable to 1
                    if y[p-1] != None:
                        prod = 1.
                    else:
                        prod = 0.
                    # loop through dimensions
                    for v in range(1,V+1):
                        # multiply the term onto the product series
                        prod *= x[p-1,v-1] ** (n[v-1] + nhat[v-1])
                    #==================================================
                    # add weighting factor
                    if callable(weighting):
                        prod *= weighting(x, y, p-1)
                    #==================================================
                    # add the product series variable to the summation
                    if percent:
                        if y[p-1] != None: summ += prod/abs(y[p-1])
                    else:
                        summ += prod
                # set Aij to the finalized summation
                A[ii,jj] = summ
        # calculate bi entry
        ####################
        if str(i) in con:
            b[ii] = con[str(i)]
        else:
            # initialize summation variable to 0
            summ = 0.
            # loop through points in the dataset
            for p in range(1,k+1):
                # initialize the product series variable to 1
                if y[p-1] != None:
                    prod = 1.
                else:
                    prod = 0.
                # loop through the dimensions
                for v in range(1,V+1):
                    # multiply the term onto the product series
                    prod *= x[p-1,v-1] ** nhat[v-1]
                #==================================================
                # add weighting factor
                if callable(weighting) and y[p-1] != None:
                    prod *= weighting(x, y, p-1)
                #==================================================
                # add the term onto the summation
                if percent:
                    summ += prod
                else:
                    if y[p-1] != None: summ += y[p-1] * prod
            # set bi to the finalized summation
            b[ii] = summ
        if verbose: prog.display()
    #solve Aa=b equation
    ########################################################################
    if verbose: print('solving the Aa=b equation')
    a = np.linalg.solve(A,b)
    #input the missing 0 coefficients into 'a' so that it can be used with the multidimensional_poly_func
    ########################################################################
    for i in range(J):
        if not i in active:
            a = np.insert(a,i,0.)
            active = np.insert(active,i,0)
    #calculate R^2 value
    ########################################################################
    r = multivariableR2(a, Nvec, x, y, verbose=verbose)       #r2_2D(a,M,x,y,z)
    #return values
    return a, r

def multivariablePolynomialFunction(a, Nvec, x):
    """
    Multivariable Polynomial Function
    
    inputs:
    
        a = list of the polynomial coefficients. 'a' has a length equal to
            the products of the Nvec elements plus one.
            i.e.: (Nvec0+1)*(Nvec1+1)*...
        Nvec = list with a length V equal to the number of independent
            variables. The ith element values are integers of polynomial
            order of the ith independent variable
        ??x = numpy matrix of size k by V, where k is the total number of
            points in the dataset. The ith column represents the ith
            independent variable values with the rows representing the
            different data points
    
    returns:
    
        f = value of the multivariable polynomial function for the given
            independent variables
    """
    # initialize summation to 0
    f = 0.
    # calculate total number of datapoints
    k = len(a)
    # calculate total number of dimensions
    V = len(x)
    # loop through the datapoints
    for j in range(k):
        # calculate the n values
        n = decompose_j(j, Nvec)
        # initialize the product series variable to 1
        prod = 1.
        # loop through the dimensions
        for v in range(V):
            # multiply onto the product series the term
            prod *= x[v] ** n[v]
        # add onto the summation the proper term
        f += a[j] * prod
    # return the finalized summation value
    return f

def multivariableR2(a, Nvec, xx, yy, verbose=True):
    """
    Routine to calculate the R^2 value of a multivariable polynomial fit to
    a dataset
    
    inputs:
    
        a = array of polynomial coefficients
        Nvec = list of integers representing the polynomial order of the
            independent variables
        xx = numpy matrix of size k by V, where k is the total number of
            points in the dataset. The ith column represents the ith
            independent variable values with the rows representing the
            different data points
        yy = list with a length of k with the dependent variable values
    
    returns:
    
        R2 = R^2 value, or the coefficient of determination
    """
    # ensure x and y are in the proper format
    x = np.copy(xx)
    y = np.copy(yy)
    ynew = np.copy([temp for temp in y if temp != None])
    # calculate k
    k = len(ynew)
    # calculate mean y value
    y_ = sum(ynew) / float(k)
    # calculate the SSt value
    SSt = sum( (ynew - y_) ** 2. )
    # initialize the f array
    f = []
    # loop through the datapoints
    if verbose: prog = oneLineProgress(len(y), msg='Determining R^2 of the fit')
    for i in range(len(y)):
        if y[i] == None:
            if verbose: prog.display()
            continue
        # calculate the f value from the polynomial function
        f.append( multivariablePolynomialFunction(a,Nvec,x[i,:]) )
        if verbose: prog.display()
    f = np.copy(f)
    # calculate the SSr term
    SSr = sum( (ynew - f) ** 2. )
    # calculate and return the R^2 value
    return 1. - SSr / SSt

def multivariableRMS(raw_x, raw_y, a, Nvec, verbose=True):
    """
    Routine to calculate the RMS and RMSN errors of a multivariable
    polynomial fit to a dataset
    
    inputs:
    
        raw_x = array of independent variables values from the dataset of
            shape (k,V) where k is the total number of points in the dataset
            and V is the number of independent variables
        raw_y = array of dependent variable values from the dataset
        a = array of polynomial coefficients
        Nvec = list of integers representing the polynomial order of the
            independent variables
    
    returns:
    
        RMS = root, mean, squared error
        RMSN = root, mean, squared, normalized error
    """
    x = np.copy( raw_x )
    y = np.copy( raw_y )
    avg = np.mean(abs(y))
    k = len(x[:,0])
    func = np.zeros(k)
    e = np.zeros(k)
    e_per = np.zeros(k)
    if verbose: prog = oneLineProgress(k, msg='Determining RMS of the fit')
    for i in range(k):
        func[i] = multivariablePolynomialFunction(a, Nvec, x[i])
        e[i] = (y[i] - func[i]) ** 2.
        e_per[i] = ((y[i] - func[i])/avg) ** 2.
        if verbose: prog.display()
    return np.sqrt(np.mean(e)), np.sqrt(np.mean(e_per))

def compose_j(n, Nvec):
    """
    Eq. 4 in Poly Fits Derivation. Routine to compose the j counter from
    the n values. Can also be used as Eq. 10 with the i counter and the nhat
    values.
    
    inputs:
    
        n = list of integer values representing the independent variables'
            exponents for the jth term in the multidimensional polynomial
            function (Eq. 2)
        Nvec = list of integers representing the polynomial order of the
            independent variables
    
    returns:
    
        j = integer representing the column of the A matrix or the jth
            polynomial coefficient
    """
    # calculate V
    V = len(Nvec)
    # initialize j to 0
    j = 0
    # loop through independent variables
    for v in range(1,V+1):
        # initialize product series to 1
        prod = 1
        # loop through w values for product series
        for w in range(v+1,V+1):
            # multiply on the term to the product series
            prod *= Nvec[w-1] + 1
        # add on term onto j
        j += n[v-1] * prod
    return j

def decompose_j(j, Nvec):
    """
    Eq. 5 in Poly Fits Derivation. Routine to decompose the j counter into
    the n values. Can also be used as Eq. 1 with the i counter and the nhat
    values.
    
    inputs:
    
        j = integer representing the column of the A matrix or the jth
            polynomial coefficient
        Nvec = list of integers representing the polynomial order of the
            independent variables
    
    returns:
    
        n = list of integer values representing the independent variables'
            exponents for the jth term in the multidimensional polynomial
            function (Eq. 2)
    """
    # calculate V
    V = len(Nvec)
    # initialize n values to nothing
    n = [[]]*V
    # loop through the n values that need to be solved, starting at the highest and working down
    for v in range(V,0,-1):
        # initialize the denomenator product series to 1
        denom = 1
        # loop through the w values needed for the product series
        for w in range(v+1,V+1):
            # multiply on the terms for the denomenator product series
            denom *= Nvec[w-1] + 1
        # initialize the summation variable to 0
        summ = 0
        # loop through the u values necessary for the summation
        for u in range(v+1,V+1):
            # initialize the product series variable inside the summation to 1
            prod = 1
            # loop through the s values needed for the product series that is inside the summation
            for s in range(u+1,V+1):
                # multiply on the term for the product series that is inside of the summation
                prod *= Nvec[s-1] + 1
            # add on the needed term to the summation series
            summ += n[u-1] * prod
        # finally calculate the n value cooresponding to this v
        n[v-1] = int(round( ((j-summ)/denom)%(Nvec[v-1]+1) ))
    return n

############################################################################
############################################################################
############################################################################

def calcJ(Nvec):
    J = 1
    for n in Nvec:
        J *= n + 1
    return J

def kDecompose(k, V):
    t = 1
    ###################################################
    ## find the category
    c = 0
    vals = [0] * V
    while k > t:
        c += 1
        m = [c] * (V-1)
        vals[0] = calcJ(m)
        for j in range(V-1):
            m[j] -= 1
            vals[j+1] = calcJ(m)
        t += sum(vals)
    if c == 0:
        return [0]*V
    ####################################################
    ## find the subcategory
    for sc in range(V-1,-1,-1):
        t -= vals[sc]
        if k > t:
            break
    ####################################################
    ## determine n
    # initialize n
    n = [None]*V
    n[sc] = c
    # create mx based on the sc, then decompose to get m
    mx = [c]*(V-1)
    for i in range(sc):
        mx[i] -= 1
    m = decompose_j(k-t-1, mx)
    # set m values into n and return
    j = -1
    for i in range(V):
        if i != sc:
            j += 1
            n[i] = m[j]
    return n

def kCompose(n):
    ########################################
    V = len(n)
    if V == 1: return calcJ(n)
    mx = max(n)
    if mx == 0: return 1
    k = 1
    ## calculate lower number sets
    for i in range(1,mx):
        m = [i] * (V-1)
        k += calcJ(m)
        for j in range(V-1):
            m[j] -= 1
            k += calcJ(m)
    ## calculate location in current number set
    for i in range(V):
        M = [mx]*(V-1)
        for j in range(i):
            M[j] -= 1
        if n[i] != mx:
            k += calcJ(M)
        else:
            m = [n[j] for j in range(V) if j != i]
            k += compose_j(m, M) + 1
            return k
    raise ValueError('Unable to compose n into k: current k value {}'.format(k))

class oneLineProgress():
    
    def __init__(self, Total, msg='', showETR=True):
        self.total = Total
        self.msg = msg
        self.count = 0
        self.showETR = showETR
        self.start = dt.now()
        self.rollTimer = dt.now()
        self.rollCount = -1
        self.rollDelta = 0.2
        self.display()
    
    def increment(self):
        self.count += 1
    
    def decrement(self):
        self.count -= 1
    
    def __str__(self):
        pass
    
    def __len__(self):
        l = len(str(self))
        self.decrement()
        return l
    
    def Set(self, count):
        self.count = count
    
    def display(self):
        rolling = '-\\|/'
        rollDelta = (dt.now()-self.rollTimer).total_seconds()
        
        p2s = False
        if rollDelta >= self.rollDelta or self.rollCount == -1:
            p2s = True
            self.rollTimer = dt.now()
            self.rollCount += 1
            if self.rollCount >= len(rolling):
                self.rollCount = 0
        
        perc = self.count / self.total * 100.
        self.increment()
        
        if not p2s and perc < 100.: return
        
        s = '\r' + ' '*(len(self.msg)+50) + '\r'
        s += self.msg + ' '*4
        
        # j = 0
        for i in range(10):
            if perc >= i*10:
                j = i
        
        if perc < 100.:
            s += u'\u039e'*j + rolling[self.rollCount] + '-'*(9-j)
        else:
            s += u'\u039e'*10
        
        # for i in range(1,11):
            # if i*10 <= perc:
                # s += u'\u039e'
            # else:
                # s += '-'
        s += ' '*4 + '{:7.3f}%'.format(perc)
        if not self.showETR:
            if perc >= 100.: s += '\n'
            print(s, end='')
            return
        
        if perc <= 0:
            etr = '-:--:--.------'
            s += ' '*4 + 'ETR = {}'.format(etr)
        elif perc >= 100.:
            s += ' '*4 + 'Run Time {}'.format(dt.now()-self.start) + '\n'
        else:
            time = (dt.now()-self.start).total_seconds()
            etr = td(seconds=time / perc * 100. - time)
            s += ' '*4 + 'ETR = {}'.format(etr)
        print(s, end='')
        return

def zSort(v, *W, ascend=True, verbose=True, msg='Sorting the arrays'):
    k = len(v)
    for w in W:
        if len(w) != k: raise ValueError('All arrays need to be the same length in zSort')
    c = []
    if verbose: prog = oneLineProgress(sum([i for i in range(k)])+len(W), msg=msg)
    for m in range(k):
        for j in range(k-1,m,-1):
            i = j-1
            
            if (ascend and v[j] < v[i]) or (not ascend and v[j] > v[i]):
                c.append(j)
                temp = v[j]
                v[j] = v[i]
                v[i] = temp
            if verbose: prog.display()
    
    for w in W:
        for j in c:
            i = j-1
            temp = w[j]
            w[j] = w[i]
            w[i] = temp
        if verbose: prog.display()

def isClose(x, y, tol=1.e-12):
    return y-tol <= x and x <= y+tol


def autoPolyFit(X, y, max_order=6, tol=1.e-12, sigma=None, sigma_multiplier=1., verbose=True):
    '''
    autoPolyFit function performs a mutivariable polynomial curve
    fit to a dataset and automatically determines which terms in the
    polynomial to use based on a balance between a goodness of the fit and a
    predictive capabilities measure that attempts to make the model compact.
    
    inputs:
        X : numpy array of shape (N,m). X consists of all the independent
            variables in the dataset. N is the number of data points in the
            set and m is the number of independent variables
        y : list or numpy array with length N. y is the dependent variable
            values cooresponding to the independent variables in X
        max_order : optional integer. gives the max order of polynomial for
            any one of the independent varialbes to try. defaults to 12
        tol : optional float. Gives the cut-off value for any polynomial
            coefficient to not be included in the final results. If a
            coefficient has an absolute value below tol, it won't be
            included. defaults to 1e-12
        sigma : optional float. value used to determine the trade off
            between how good of a fit to perform and how many terms to keep.
            defaults to None, which causes the function to calculate sigma
            automatically using the mean squared of the difference of the
            independent variable values with respect to the mean independent
            variable value of the dataset
        sigma_multiplier : optional float. term multiplied onto sigma to
            change it's value. Allows using a multiple of the automatically
            determined sigma value. Defaults to 1.
    
    returns:
        list : a list of the polynomial coefficients in a form used by the
            poly_fits module
        list : a list of the max polynomial orders for each independent
            variable. The length of this list is therefore m. This list is
            the 'Nvec' object used in the poly_fits module
        float : the coefficient of determination, R^2 value, representing
            the goodness of the fit
    '''
    ## number of independent variables
    m = X.shape[1]
    ## max range of polynomials to try
    Nvec = tuple([max_order]*m)
    ## number of datapoints
    N = len(y)
    ## number of p functions
    K = kCompose(Nvec)
    ###################################################################
    ##           determine the orthogonal p functions
    if verbose: prog = oneLineProgress(K-1, msg='Determining the orthogonal p functions')
    ## initialize the P matrix
    P = np.zeros((N, K))
    P[:,0] = 1.
    ## loop thru k values
    for k in range(2,K+1):
        ## determine the set associated with k
        n = decompose_j(k-1, Nvec)
        ## find pkhat and mu
        mu = None
        for i in range(m):
            nhat = n[:]
            if nhat[i] > 0:
                nhat[i] -= 1
                khat = compose_j(nhat, Nvec) + 1
                if khat < k:
                    mu = i
                    break
        if mu == None: raise ValueError('Unable to find previous khat set')
        pkhat = P[:,khat-1]
        xmu = X[:,mu]
        ## calculate pk first term
        temp = xmu * pkhat
        phik = sum(n)
        pk = temp[:]
        ## loop thru summation in eq 18
        for j in range(1,k):
            ## check if value is needed
            phij = sum(decompose_j(j-1, Nvec))
            if phik - phij <= 2:
                ## calculate gamma
                pj = P[:,j-1]
                gamma = np.dot(pj, temp) / np.dot(pj, pj)
                pk -= gamma * pj
        ## add pk to P
        P[:,k-1] = pk[:]
        if verbose: prog.display()
    #################################################################
    ##              sort the p functions by effectiveness
    order = [i for i in range(K)]
    ranks = [None] * K
    for i in range(K):
        pj = P[:,i]
        pjdot = np.dot(pj, pj)
        ajhat = np.dot(pj, y) / pjdot
        ranks[i] = ajhat ** 2. * pjdot
    zSort(ranks, order, ascend=False, msg='Sorting the p functions by effectivenss', verbose=verbose)
    Pordered = np.zeros((N,K))
    for i,o in enumerate(order):
        Pordered[:,i] = P[:,o]
    P = Pordered[:,:]
    ###################################################################
    ##          determine how many of the orthogonal p functions to use
    if verbose: prog = oneLineProgress(K, msg='Determining number of p functions to use')
    PSEold = None
    foundMin = False
    if sigma == None:
        yavg = sum(y) / N
        sigma = sum([(i - yavg)**2. for i in y]) / N
    sigma *= sigma_multiplier
    
    for n in range(1,K+1):
        Phat = P[:,:n]
        ahat = np.matmul(np.matmul(np.linalg.inv(np.matmul(Phat.transpose(), Phat)), Phat.transpose()), y)
        yhat = np.matmul(Phat, ahat)
        MSE = np.dot(y - yhat, y - yhat) / N
        PSEnew = MSE + sigma * n / N
        if verbose: prog.display()
        if PSEold == None or PSEnew <= PSEold:
            PSEold = PSEnew
        else:
            foundMin = True
            nn = n-1
            P = Phat[:,:nn]
            order = order[:nn]
            if verbose: 
                prog.Set(K)
                prog.display()
            break
    if not foundMin:
        raise ValueError('Unable to find minimum PSE')
    ###################################################################
    ##              final coefficients and polynomial size
    if verbose: prog = oneLineProgress(4+nn, msg='Determining final coefficients and polynomial size')
    b = np.zeros((nn,nn))
    for k in range(1,nn+1):
        j = k - 1
        pj = P[:,j]
        w = np.ones((N,k))
        for i in range(k):
            n = decompose_j(order[i], Nvec)
            for ii,e in enumerate(n):
                w[:,i] *= X[:,ii] ** e
        vals = np.matmul(np.matmul(np.linalg.inv(np.matmul(w.transpose(), w)), w.transpose()), pj)
        b[j,:k] = vals[:]
        if verbose: prog.display()
    
    A = [np.dot(P[:,i],y)/np.dot(P[:,i],P[:,i]) for i in range(nn)]
    if verbose: prog.display()
    
    c = [np.dot(A,b[:,i]) for i in range(nn)]
    js = [decompose_j(order[i], Nvec) for i in range(nn)]
    if verbose: prog.display()
    
    js = [js[i] for i in range(nn) if not isClose(c[i], 0., tol=tol)]
    c = [i for i in c if not isClose(i, 0., tol=tol)]
    if verbose: prog.display()
    
    nvec = [None]*m
    for i in range(m):
        nvec[i] = max([j[i] for j in js])
    JJ = 1
    for n in nvec:
        JJ *= n+1
    
    a = [0.] * JJ
    for j in range(JJ):
        n = decompose_j(j, nvec)
        for i in range(len(c)):
            if n == js[i]:
                a[j] = c[i]
    if verbose: prog.display()
    
    return a, nvec, multivariableR2(a, nvec, X, y, verbose=verbose)

</"file: python/AirfoilDatabase/airfoil_db/poly_fits.py">

<"file: python/AirfoilDatabase/dev/test.py">import airfoil_db as adb
import matplotlib.pyplot as plt
import numpy as np
import math as m
from mpl_toolkits.mplot3d import Axes3D

#geometry_file = "dev/uCRM-9_wr0_xfoil.txt"
#geometry_file = "dev/symmetric.dat"
#geometry_file = "dev/MMXX0700cTE4.muxf"
geometry_file = "dev/Eppler_335_profile.csv"
#geometry_file = "dev/64A204.txt"
#geometry_file = "dev/NACA_9412_geom.txt"
#geometry_file = "dev/NACA_0012_geom.txt"
airfoil_input = {
    "type" : "database",
    "geometry" : {
        #"outline_points" : geometry_file
        "NACA" : "0012"
        #"NACA_closed_te" : True
    },
    "trailing_flap_type" : "parabolic"
}

airfoil = adb.Airfoil("test_airfoil", airfoil_input, verbose=True, camber_termination_tol=1e-11)
#airfoil.get_outline_points(trailing_flap_fraction=0.3, trailing_flap_deflection=np.radians(0.0), export="dev/symmetric.dat")

dofs = {
    "alpha" : {
        "range" : [m.radians(-15.0), m.radians(15.0)],
        "steps" : 11,
        "index" : 1
    },
    "Rey" : {
        "range" : [1000000, 4000000],
        "steps" : 2,
        "index" : 2
    },
    "Mach" : {
        "range" : [0.0, 0.4],
        "steps" : 3,
        "index" : 3
    },
    "trailing_flap_deflection" : {
        "range" : [m.radians(-20.0), m.radians(20.0)],
        "steps" : 7,
        "index" : 0
    },
    #"trailing_flap_fraction" : 0.25
    "trailing_flap_fraction" : {
        "range" : [0.0, 0.5],
        "steps" : 3,
        "index" : 3
    }
}

# Generate or import database
#airfoil.generate_database(degrees_of_freedom=dofs, max_iter=100, show_xfoil_plots=True, show_xfoil_output=False, visc=True)
airfoil.run_xfoil(alpha=0.0, show_xfoil_output=True)
#airfoil.export_database(filename="database.txt")
#airfoil.import_database(filename="database.txt")
print("Imported database")
airfoil.generate_linear_model()

# Fit orders
CL_fit_orders = {
    "alpha" : 3,
    "Rey" : 1,
    "trailing_flap" : 1,
    "Mach" : 2
}

CD_fit_orders = {
    "alpha" : 4,
    "Rey" : 1,
    "trailing_flap" : 4,
    "Mach" : 2
}

Cm_fit_orders = {
    "alpha" : 1,
    "Rey" : 1,
    "trailing_flap" : 1,
    "Mach" : 2
}

# Generate or import fits
#airfoil.generate_polynomial_fit(CL_degrees=CL_fit_orders, CD_degrees=CD_fit_orders, Cm_degrees=Cm_fit_orders)
#airfoil.generate_polynomial_fit(CL_degrees="auto", CD_degrees="auto", Cm_degrees="auto", max_order=6)
#airfoil.export_polynomial_fits(filename="fits.json")
#airfoil.import_polynomial_fits(filename="database.json")

# Compare interpolation and fits
alphas = np.radians(np.linspace(-10, 10, 20))
flaps = np.radians(np.linspace(10, -10, 20))
Re = 2000000
c_tf = 0.2

fig = plt.figure(figsize=plt.figaspect(1.0))
ax = fig.gca(projection='3d')
for a in alphas:

    # Interpolation results
    airfoil.set_type("database")
    CL_int = airfoil.get_CL(alpha=a, trailing_flap_deflection=flaps, Rey=Re, trailing_flap_fraction=c_tf)
    CD_int = airfoil.get_CD(alpha=a, trailing_flap_deflection=flaps, Rey=Re, trailing_flap_fraction=c_tf)

    # Polynomial results
    #airfoil.set_type("poly_fit")
    #CL_fit = airfoil.get_CL(alpha=a, trailing_flap_deflection=flaps, Rey=Re, trailing_flap_fraction=c_tf)
    #CD_fit = airfoil.get_CD(alpha=a, trailing_flap_deflection=flaps, Rey=Re, trailing_flap_fraction=c_tf)

    # Plot
    alpha_graph = np.full(20, a)
    ax.plot(alpha_graph, flaps, CL_int, 'rx')
    #ax.plot(alpha_graph, flaps, CL_fit, 'b-')
    #ax.plot(alpha_graph, flaps, CD_int, 'x', color='orange')
    #ax.plot(alpha_graph, flaps, CD_fit, 'g-')

ax.set_xlabel("Angle of Attack")
ax.set_ylabel("Flap Deflection")
ax.set_zlabel("CL")
plt.show()</"file: python/AirfoilDatabase/dev/test.py">

<"file: python/AirfoilDatabase/dev/zach/ExampleAirfoilData.json">{"Description": ["angle of attack","Reynolds Number","Flap Deflection"],"bounds": [[-15, 15],[200000, 1000000],[-20, 20]],"Nvec": [4,2,2],"Coefficients": [0.0,902.1426724490917,0.0,91.06020473857689,0.0,107581.59925646387,0.0,-15975.9049715397,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1510.5390303010813,0.0,19.777897305942993,0.0,175810.3474203558,0.0,46316.89926429353,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1440.6917274137616,0.0,59.73426585447858,0.0,98658.0076932291,0.0,35637.18743326546,0.0],"R^2": 0.9853767171687212}</"file: python/AirfoilDatabase/dev/zach/ExampleAirfoilData.json">

<"file: python/AirfoilDatabase/dev/zach/VortexPanel.py">import numpy as np
from numpy import pi, sqrt, cos, sin, tan, sign
from numpy import arctan2 as atan2
from numpy import arctan as atan
from numpy import arcsinh as asinh
from numpy import log as ln
import csv
import os
import scipy.optimize as opt

import matplotlib.pyplot as plt
plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams["mathtext.fontset"] = "stix"

import airfoil as af

class driver(object):
    def __init__(self):
        super(driver,self).__init__()

    def add_airfoil(self,airfoil):
        self.myaf = airfoil

    def airfoil_coefficient_matrix(self):
        n = self.myaf.nPts
        # Calculate control points and length of each panel
        l, xc, yc, xnorm, ynorm = self.myaf.panel_geom()

        # Compute the "P matrix"
        P = self.p_matrix()

        # Compute the "A matrix"
        A = np.zeros([n, n])
        for i in range(n - 1):
            A[i, :-1] += ynorm[i] * P[i, :, 1, 0] + xnorm[i] * P[i, :, 0, 0]
            A[i, 1:] += ynorm[i] * P[i, :, 1, 1] + xnorm[i] * P[i, :, 0, 1]

        # Last row of A matrix enforces kutta condition
        A[n - 1, 0] = 1.0
        A[n - 1, n - 1] = 1.0

        return A

    def p_matrix(self,offset = 0.0):
        x = self.myaf.x
        y = self.myaf.y
        n = self.myaf.nPts
        # Calculate control points and length of each panel
        l, xc, yc, xnorm, ynorm = self.myaf.panel_geom()
        xc += xnorm * offset
        yc += ynorm * offset

        # Calculate panel coordinates for each control point
        xi = np.zeros([n - 1, n - 1])
        eta = np.zeros([n - 1, n - 1])
        Phi = np.zeros([n - 1, n - 1])
        Psi = np.zeros([n - 1, n - 1])
        for i in range(n - 1):
            xi[i] = (xc[i] - x[:-1]) * ynorm + (yc[i] - y[:-1]) * (-xnorm)
            eta[i] = -(xc[i] - x[:-1]) * (-xnorm) + (yc[i] - y[:-1]) * ynorm
            Phi[i] = atan2(eta[i] * l, eta[i]**2 + xi[i]**2 - xi[i] * l)
            Psi[i] = 0.5 * ln((xi[i]**2 + eta[i]**2) / ((xi[i] - l)**2 + eta[i]**2))

        # Calculate the panel coefficient matrix
        P = np.zeros([n - 1, n - 1, 2, 2])
        af_array = np.asarray([[(x[1:] - x[:-1]), -(y[1:] - y[:-1])],
                            [(y[1:] - y[:-1]),  (x[1:] - x[:-1])]])
        for i in range(n - 1):
            p_array = np.asarray([[((l - xi[i]) * Phi[i] + eta[i] * Psi[i]), (xi[i] * Phi[i] - eta[i] * Psi[i])],
                                [(eta[i] * Phi[i] - (l - xi[i]) * Psi[i] - l), (-eta[i] * Phi[i] - xi[i] * Psi[i] + l)]])
            for j in range(n - 1):
                P[i, j] = 0.5 / (pi * l[j]**2) * np.dot(af_array[:,:,j], p_array[:,:,j])

        return P

    def aero_coefficients(self, m, M, inc, A):
        x = self.myaf.x
        y = self.myaf.y
        n = self.myaf.nPts

        # Set up an array of angles of attack to evaluate
        alphas = np.linspace(m, M, int((M - m) / inc) + 1)
        aero_coeff = []
        cp_profiles = []

        # Calculate control points and length of each panel
        l, xc, yc, xnorm, ynorm = self.myaf.panel_geom()

        # Get a P matrix with slight offset from the surface (used for Cp calculations)
        offset = 1.0e-3
        P = self.p_matrix(offset)

        # Invert the airfoil coefficient matrix to solve for multiple operating conditions
        A_inv = np.linalg.inv(A)

        vec = np.zeros(n)
        for alpha in alphas:
            rad = alpha * pi / 180.0
            vec[:-1] = ((y[1:] - y[:-1]) * cos(rad) - (x[1:] - x[:-1]) * sin(rad)) / l

            # Calculate vortex strengths at each panel endpoint
            gamma = np.dot(A_inv, vec)

            # Compute aerodynamic coefficients
            cl = 0.0
            cmLE = 0.0
            for i in range(n - 1):
                cl += l[i] * (gamma[i] + gamma[i + 1])
                cmLE += l[i] * ((2.0 * x[i] * gamma[i] + x[i] * gamma[i + 1] + x[i + 1] * gamma[i]
                                 + 2.0 * x[i + 1] * gamma[i + 1]) * cos(rad) +
                                (2.0 * y[i] * gamma[i] + y[i] * gamma[i + 1] + y[i + 1] * gamma[i]
                                 + 2.0 * y[i + 1] * gamma[i + 1]) * sin(rad))

            cmLE /= -3.0
            cmQC = cmLE + 0.25 * cl * cos(rad)

            # Compute the pressure coefficients along the surface of the airfoil
            cp_profile = []
            for i in range(n - 1):
                v = [cos(rad), sin(rad)]
                for j in range(n - 1):
                    v += np.dot(P[i, j], gamma[j:j+2])
                cp_profile.append([xc[i], yc[i], np.linalg.norm(v), 1.0 - np.dot(v, v)])

            aero_coeff.append([alpha, cl, cmLE, cmQC])
            cp_profiles.append([alpha, cp_profile])

        return list(map(list, zip(*aero_coeff))), cp_profiles

    def view(self, filename=None):
        # Calculate geometry parameters
#        theta, x, y, xcamber, ycamber, dydx = geometry(airfoil, nnodes, flap_type, hinge, delta)

        x = self.myaf.x
        y = self.myaf.y
        xcamber = self.myaf.xcamber
        ycamber = self.myaf.ycamber
        dydx = self.myaf.dydx
        # Plot the airfoil geometry
        fig = plt.figure(figsize=(10,5))
        ax = fig.add_subplot(111)
    #    ax.set_title('Geometry and Camber Line of a NACA {} Airfoil ({} nodes)'.format(airfoil, nnodes))
        ax.set_xlabel('$x/c$', size=20)
        ax.set_ylabel('$y/c$', size=20)
        ax.plot(x, y, '-', label = 'Airfoil Geometry', lw=2, color = 'black', fillstyle = 'none')
        ax.plot(xcamber, ycamber, '-', lw=1, label = 'Camber Line', color = 'black')
        ax.set_aspect('equal', 'datalim')
    #    plt.legend()
        ax2=ax.twinx()
        ax2.plot(xcamber, dydx, '.', markersize = 2, label = 'Camber-Line Slope', color = 'black')
        ax2.set_ylabel('$dy_c/dx$', style = 'italic', size=20)
        ax2.set_ylim([-1.0,0.6])
        h1, l1 = ax.get_legend_handles_labels()
        h2, l2 = ax2.get_legend_handles_labels()
        ax.legend(h1+h2, l1+l2, loc=1, prop={'size':16})
    #    plt.legend()
        plt.show()
        if(filename != None):
            filename1 = filename + '.pdf'
            print('Saving Figure: ' + filename)
            fig.savefig(filename1,format='pdf')
            cwd = os.getcwd()
            mystring = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
            mystring += ' --file '+cwd+'/'+filename1+' --export-wmf '+cwd+'/'+filename+'.wmf'
            #after you run this, you have to open in Inkscape and save as emf
            os.system(mystring)

    def write_xfoil(self, filename = 'coordinates.dat'):
        x = self.myaf.x
        y = self.myaf.y
        n = self.myaf.nPts

        a = open(filename,'w')
        for i in range(n):
            print("{:25.16E}{:25.16E}".format(x[i],y[i]),file=a)
        a.close()
        print("Xfoil file written: ",filename)


    def fit(self, minAlpha, maxAlpha, incAlpha,iprint=False):
        # Calculate geometry parameters
    #    theta, x, y, xcamber, ycamber, dydx = geometry(airfoil, nnodes, flap_type, hinge, delta)

        # Calculate the inverse of the Airfoil Coefficient Matrix
        A = self.airfoil_coefficient_matrix()

        # Calculate aerodynamic coefficients for each desired angle of attack
        aero_coeff, cp_profiles = self.aero_coefficients(minAlpha, maxAlpha, incAlpha, A)
        aero_coeff = np.asarray(aero_coeff)
        alphas = aero_coeff[0][:]
        CL = aero_coeff[1]
        CmLE = aero_coeff[2]
        rads = alphas[:]*np.pi/180.0

        if(iprint):
            print("   Alpha[deg]               CL                      CmLE")
            for i in range(len(alphas)-1):
                print("{:25.16E}{:25.16E}{:25.16E}".format(alphas[i],CL[i],CmLE[i]))

        aL0 = np.sum(CL*cos(rads))*np.sum(sin(rads)**2) - np.sum(CL*sin(rads))*np.sum(sin(rads)*cos(rads))
        aL0 = atan(aL0/(np.sum(CL*cos(rads))*np.sum(sin(rads)*cos(rads)) - np.sum(CL*sin(rads))*np.sum(cos(rads)**2)))

        CL0a = np.sum(CL*cos(rads))/(np.sum(sin(rads)*cos(rads)) - tan(aL0)*np.sum(cos(rads)**2))

        Cmat = np.zeros([3, 3])
        Cmat[0,0] =   np.sum(sin(2.0*rads)**2)
        Cmat[0,1] =   np.sum(CL*sin(2.0*rads)*cos(rads))
        Cmat[0,2] = - np.sum(CL*sin(2.0*rads)*sin(rads))
        Cmat[1,0] =   Cmat[0,1]
        Cmat[1,1] =   np.sum(CL**2*cos(rads)**2)
        Cmat[1,2] = - np.sum(CL**2*cos(rads)*sin(rads))
        Cmat[2,0] = - Cmat[0,2]
        Cmat[2,1] = - Cmat[1,2]
        Cmat[2,2] = - np.sum(CL**2*sin(rads)**2)

        RHS = np.zeros(3)
        RHS[0] = np.sum(CmLE*sin(2.0*rads))
        RHS[1] = np.sum(CmLE*CL*cos(rads))
        RHS[2] = np.sum(CmLE*CL*sin(rads))

        #Check for symmetric airfoil. If so, Cmat is ill-conditioned, and cannot be solved
        if(abs(aL0)<1.0e-12):
            Cans = np.zeros(3)
            Cans[1] = RHS[1]/Cmat[1,1]
        else:
            C_inv = np.linalg.inv(Cmat)
            Cans = np.dot(C_inv, RHS)

        Cm0a = Cans[0]
        CmN = Cans[1]
        CmA = Cans[2]

        if(iprint):
            print("   aL0                      CL0a                     Cm0a                     CmN                      CmA")
            print("{:25.16E}{:25.16E}{:25.16E}{:25.16E}{:25.16E}".format(aL0,CL0a,Cm0a,CmN,CmA))

        return aL0, CL0a, Cm0a, CmN, CmA

    def eq_deflection(self,naca,xf=0.7,flapType=2,alpha=0.0,targetCL=0.5,iprint=False):

        ans = opt.newton(self.f_one_delta,0.0,fprime=None,args=(naca,xf,flapType,alpha,targetCL),tol=1.0e-6,maxiter=50,fprime2=None)
        if(iprint): print("Equivalent Deflection = ",ans)
        return ans

    def f_one_delta(self,x,naca,xf,flapType,alpha,targetCL):
        self.myaf = af.airfoil(naca=naca,xf=xf,flapType=flapType,delta=x)
        CL,CmLE,dummy = self.single(alpha)
        return (CL-targetCL)

    def single(self,alpha):
        theta = self.myaf.theta
        nnodes = self.myaf.nPts

        # Calculate the inverse of the Airfoil Coefficient Matrix
        A = self.airfoil_coefficient_matrix()

        # Calculate aerodynamic coefficients for each desired angle of attack
        aero_coeff, cp_profiles = self.aero_coefficients(alpha, alpha, 1, A)
        alphas = aero_coeff[0][:]
        CL = aero_coeff[1]
        CmLE = aero_coeff[2]
        CmQC = aero_coeff[3]
        return CL[0], CmLE[0], CmQC[0]

    def sweep(self,minAlpha, maxAlpha, incAlpha):
        theta = self.myaf.theta
        nnodes = self.myaf.nPts
        # Calculate geometry parameters
#        theta, x, y, xcamber, ycamber, dydx = geometry(airfoil, nnodes, flap_type, hinge, delta)

        # Calculate the inverse of the Airfoil Coefficient Matrix
        A = self.airfoil_coefficient_matrix()

        # Calculate aerodynamic coefficients for each desired angle of attack
        aero_coeff, cp_profiles = self.aero_coefficients(minAlpha, maxAlpha, incAlpha, A)
        alphas = aero_coeff[0][:]
        cl = aero_coeff[1]
        cmLE = aero_coeff[2]
        cmQC = aero_coeff[3]

        # Plot the cl and cm(LE) as functions of alpha
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.set_title('Lift and Moment Coefficients for a NACA {}\nas a function of Angle of Attack'.format(airfoil))
        ax.set_xlabel(r'$\alpha$ (deg)')
        ax.set_ylabel(r'$C_L, C_m$')
        ax.plot(alphas, cl, 'o', label = r'$C_L$ (Vortex Panel Method)', color = 'black', fillstyle = 'none')
        ax.plot(alphas, cmLE, 's', label = r'$C_{m_{LE}}$ (Vortex Panel Method)', color = 'black')
        plt.legend(loc = 'upper left')
        plt.show()

        # Generate a CSV file of cl and cm data
        with open('CL_CmLE_{}.csv'.format(self.myaf.naca), 'w') as cl_cmle_file:
            writer = csv.writer(cl_cmle_file, lineterminator="\n")
            for i in range(len(alphas)):
                writer.writerow([alphas[i], cl[i], cmLE[i]])

        output_alphas = [-10, 0, 10]
        for alpha in alphas:
            ind = int(alpha) - minAlpha
            cp = list(map(list, zip(*cp_profiles[ind][1])))

            if alpha in output_alphas:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                ax.set_title(r'Pressure distribution over a NACA {} at $\alpha$ = {} deg'
                    .format(airfoil, alpha))
                ax.set_xlabel('$x/c$')
                ax.set_ylabel('$C_p$')
                ax.plot(cp[0][:int(nnodes/2)], cp[3][:int(nnodes/2)], '--', label = 'Bottom Surface', color = 'black')
                ax.plot(cp[0][int(nnodes/2):], cp[3][int(nnodes/2):], '-', label = 'Top Surface', color = 'black')
                lims = ax.get_ylim()
                ax.set_ylim([lims[1], lims[0]])
                plt.legend(loc='lower right')
                plt.show()

            # Generate a CSV file of cp data
            with open('Cp_{}_{}.csv'.format(self.myaf.naca, alpha), 'w') as cp_file:
                writer = csv.writer(cp_file, lineterminator="\n")
                for i in range(len(cp[0])):
                    writer.writerow([theta[i], cp[0][i], cp[1][i], cp[2][i], cp[3][i]])
</"file: python/AirfoilDatabase/dev/zach/VortexPanel.py">

<"file: python/AirfoilDatabase/dev/zach/airfoil.py">import numpy as np
from numpy import pi, sqrt, cos, sin, tan, sign
from numpy import arctan2 as atan2
from numpy import arctan as atan
from numpy import arcsinh as asinh
from numpy import log as ln

import scipy.optimize as opt
from timeit import default_timer as timer

import matplotlib.pyplot as plt
plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams["mathtext.fontset"] = "stix"

class airfoil(object):
    def __init__(self, naca='0012', nPts=400, flapType=0, xf=1.0, yf=-100.0, delta=0.0):
        super(airfoil, self).__init__()

        self.naca = naca
        self.nPts = nPts
        self.flapType = flapType
        self.xf = xf
        self.yf = yf
        self.delta = delta

        self.setup()

    def setup(self):
        delta = self.delta*pi/180.0
        n = self.nPts

        # Set up theta evenly spaced (cosine clustering in x)
        theta = np.linspace(-pi, pi, n)

        # Compute x values along camber line
        s = 0.5 * (1.0 - cos(theta))

        # Compute nodal x and y coordinates for a symmetric airfoil
        t = float(self.naca[-2:]) * 0.01
        yt = 5.0 * t * (0.2969 * sqrt(s) - 0.1260 * s - 0.3516 * s**2 + 0.2843 * s**3 - 0.1015 * s**4) * sign(theta)

        # Get the max camber and location of max camber
        m = 0.01 * float(self.naca[0])  # Maximum camber (% chord)
        p = 0.1 * float(self.naca[1])  # Location of maximum chamber (% chord)

        # Compute x and y coordinates for a cambered airfoil
        ycamber = np.zeros(n)
        dydx = np.zeros(n)
        xcamber = np.copy(s)

        xf = self.xf
        yf = self.yf
        #Find vertical hinge point if not given
        if(yf==-100.0):
            if xf < p:
                yf = m / p**2 * (2.0 * p * xf - xf**2)
            else:
                yf = m / (1.0 - p)**2 * (1.0 - 2.0 * p + 2.0 * p * xf - xf**2)

        self.yf = yf
        #print("xf,yf = ",xf,yf)
        #Calculate camber line and slope
        for i in range(n):
            # Leading-edge Geometry
            if s[i] < p:
                ycamber[i] = m / p**2 * (2.0 * p * s[i] - s[i]**2)
                dydx[i] = 2.0 * m / p**2 * (p - s[i])
            # Trailing-edge Geometry
            else:
                ycamber[i] = m / (1.0 - p)**2 * (1.0 - 2.0 * p + 2.0 * p * s[i] - s[i]**2)
                dydx[i] = 2.0 * m / (1.0 - p)**2 * (p - s[i])

            #Flap Settings offset yc and dydx
            if((s[i]>xf) and (self.flapType>0) and (delta != 0.0)):
                if(self.flapType==1): #Traditional Flap
                    r = sqrt((ycamber[i]-yf)**2 + (s[i]-xf)**2)
                    psi = atan((ycamber[i]-yf)/(s[i]-xf))
                    xcamber[i] = xf + r*cos(delta-psi)
                    ycamber[i] = yf - r*sin(delta-psi)
                    dydx[i] = (dydx[i] - tan(delta))/(1+dydx[i]*tan(delta))
                if(self.flapType==2): #Parabolic Flap
                    length = sqrt(yf**2+(1-xf)**2)
                    ghi = -atan(yf/(1-xf))
                    R = sqrt(4*tan(delta)**2 + 1) + asinh(2*tan(delta))/2.0/tan(delta)
#                    if(delta<0.01):
#                        R = 1.0+sqrt(4*delta**2+1.0)
                    xite = 2*length/R
                    etate = -2*length/R*tan(delta)
                    xio = (xcamber[i]-xf)*length/(1-xf)
                    xip = opt.newton(self.f_eq_28,xite*xio/length,fprime=None,args=(xio,length,R,delta),tol=1.0e-12,maxiter=50,fprime2=None)
                    etap = -xip**2/xite*tan(delta)
                    detadxi = -2*xip/xite*tan(delta)
                    xp = xf + xip*cos(ghi) - etap*sin(ghi)
                    yp = yf + xip*sin(ghi) + etap*cos(ghi)
                    yo = yf*(1-xio/length)
                    dyc = ycamber[i] - yo
                    xcamber[i] = xp + dyc*sin(atan(2*xip/xite*tan(delta)))
                    ycamber[i] = yp + dyc*cos(atan(2*xip/xite*tan(delta)))
                    dydx[i] = (dydx[i] - 2*xip*tan(delta)/xite)/(1 + 2*xip*tan(delta)/xite*dydx[i])

        # Add thickness offset to camber location for airfoil surface
        angle = atan(dydx)
        self.x = xcamber - yt * sin(angle)
        self.y = ycamber + yt * cos(angle)
        self.theta = theta
        self.xcamber = xcamber
        self.ycamber = ycamber
        self.dydx = dydx
#        for i in range(n):
#            print(i,self.x[i],self.y[i])

    def f_eq_28(self,x,xio,length,R,delta):
        return -xio + x/2.0*sqrt((x/length*R*tan(delta))**2 + 1) + length*asinh(x*R*tan(delta)/length)/(2*R*tan(delta))

    def panel_geom(self):
        x = self.x
        y = self.y

        # Calculate the length of each panel
        length = sqrt((x[1:] - x[:-1])**2 + (y[1:] - y[:-1])**2)

        # Calculate the normal vector for each panel
        xnorm = -(y[1:] - y[:-1]) / length
        ynorm = (x[1:] - x[:-1]) / length

        # Calculate the centroid (control point) for each panel
        xc = (x[:-1] + x[1:]) / 2.0
        yc = (y[:-1] + y[1:]) / 2.0

        return length, xc, yc, xnorm, ynorm
</"file: python/AirfoilDatabase/dev/zach/airfoil.py">

<"file: python/AirfoilDatabase/dev/zach/database_creator_step1.py">#import modules
import sys
import VortexPanel as VP
import airfoil as af
import xfoil as xfoil
import numpy as np
# import airfoil_database_mod as zach
from openpyxl import Workbook
from openpyxl.chart import ScatterChart, Reference, Series
import json

#setup excel file
wb = Workbook()

#input airfoil file
if len(sys.argv) > 1:
	input_filename = sys.argv[1]
else:
	input_filename = input('\n'*2+'Enter name of file for input: ')
ff = open(input_filename, 'r')
f = json.load(ff)
ff.close()

#setup airfoil constants
m = VP.driver()
NACA = f['step 1']['NACA']
xf = f['step 1']['xf']

#setup flap deflection range
df_min = f['step 1']['flap deflection']['min']
df_max = f['step 1']['flap deflection']['max']
delta_df = f['step 1']['flap deflection']['delta']
N_df = int((df_max-df_min)/delta_df) + 1

#setup aoa range
aoa_min = f['step 1']['angle of attack']['min']
aoa_max = f['step 1']['angle of attack']['max']
delta_aoa = f['step 1']['angle of attack']['delta']

#setup ncrit
ncrit = f['step 1']['ncrit']

#setup xtr range
xtr = f['step 1']['xtr']

#setup the Reynolds number
Re = f['step 1']['Re']

#set grid size
grid = f['step 1']['grid']

#set number of iterations until not converged
niter = f['step 1']['Niter']

#loop through the flap deflection range
for i in range(N_df):
	#set the flap deflection for this loop iteration
	df = df_min + float(i) * delta_df
	
	#determine the filename
	if df < 0.:
		sgn = 'n'
	else:
		sgn = 'p'
	filename = '{}{:0>2d}'.format(sgn,int(abs(df)))       # filename cannot be greater than 6 characters long
	
	#create the airfoil and run xfoil
	myaf = af.airfoil(naca=NACA,xf=xf,flapType=0,delta=df)
	m.add_airfoil(myaf)
	m.write_xfoil(filename = filename+'.txt')
	deflection_set = xfoil.generate_machup_from_xfoil(airfoils			= [filename+'.txt'],
									alpha_min			= aoa_min,
									alpha_max			= aoa_max,
									delta_alpha			= delta_aoa,
									reynolds_number		= Re,
									grid_size			= grid,
									niter				= niter,
									ncrit				= ncrit,
									xtrt				= xtr,
									xtrb				= xtr,
									flap				= df,
									xf					= xf,
									yf					= 0.0)
	
	#initialize some variable to extract data from the xfoil run
	N = len(deflection_set)
	aoa_deg = [None] * N
	aoa_rad = [None] * N
	CL = [None] * N
	CD = [None] * N
	Cm = [None] * N
	Ch = [None] * N
	# cl2, cl3, cl4, aoa2, aoa3, aoa4, cdcl, cdcl2, claoa, claoa2, cmaoa, cmaoa2 = [0.] * 12
	
	#create a new excel sheet
	ws = wb.create_sheet(title = filename)
	ws_row = 1
	col = 1
	ws.cell(row = ws_row, column = col, value = 'aoa (rad)')
	col += 1
	ws.cell(row = ws_row, column = col, value = 'aoa (deg)')
	col += 1
	ws.cell(row = ws_row, column = col, value = 'CL')
	col += 1
	ws.cell(row = ws_row, column = col, value = 'CD')
	col += 1
	ws.cell(row = ws_row, column = col, value = 'Cm')
	col += 1
	ws.cell(row = ws_row, column = col, value = 'CHinge')
	
	#extract data from xfoil run and put it on the excel sheet
	for j in range(N):
		#extract data from xfoil
		aoa_deg[j],CL[j],CD[j],Cm[j],Ch[j] = deflection_set[j]
		aoa_rad[j] = aoa_deg[j] * np.pi / 180.
		#add data to the excel sheet
		ws_row += 1
		col = 1
		ws.cell(row = ws_row, column = col, value = aoa_rad[j])
		col += 1
		ws.cell(row = ws_row, column = col, value = aoa_deg[j])
		col += 1
		ws.cell(row = ws_row, column = col, value = CL[j])
		col += 1
		ws.cell(row = ws_row, column = col, value = CD[j])
		col += 1
		ws.cell(row = ws_row, column = col, value = Cm[j])
		col += 1
		ws.cell(row = ws_row, column = col, value = Ch[j])
	
	#set up charts
	point = 12700
	#set up CL chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 2).value
	chart.y_axis.title = 'CL'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws_row)
	yvalues = Reference(ws, min_col = 3, min_row = 1, max_row = ws_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.marker.size = 5.
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "B2")
	
	#set up CD chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 2).value
	chart.y_axis.title = 'CD'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws_row)
	yvalues = Reference(ws, min_col = 4, min_row = 1, max_row = ws_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "L2")
	
	#set up Cm chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 2).value
	chart.y_axis.title = 'Cm'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws_row)
	yvalues = Reference(ws, min_col = 5, min_row = 1, max_row = ws_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.marker.size = 5.
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "V2")
	
	#set up Ch chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 2).value
	chart.y_axis.title = 'Chinge'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws_row)
	yvalues = Reference(ws, min_col = 6, min_row = 1, max_row = ws_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.marker.size = 5.
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "B31")

#prompt user for filename and save results
wb.save(f['step 1']['excel file']+'.xlsx')

</"file: python/AirfoilDatabase/dev/zach/database_creator_step1.py">

<"file: python/AirfoilDatabase/dev/zach/database_creator_step2.py">#import modules
import sys
import numpy as np
import poly_fits as pf
from openpyxl import Workbook, load_workbook
from openpyxl.utils import get_column_letter
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.styles import Alignment, Border, Side
import json

def display_coef(var1_name, var2_name, func_name, n_vec, a, r2, rms, rmsn, row, column, sheet):
	
	last_row = row + 2 + n_vec[1]
	if last_row < row + 7: last_row = row + 7
	last_column = column + 4 + n_vec[0]
	
	for i in range(column,last_column+1):
		sheet.column_dimensions[get_column_letter(i)].width = 11.
	al = Alignment(horizontal = 'center', vertical = 'center')
	
	sheet.merge_cells(start_row = row, start_column = column, end_row = row + 1, end_column = column + 1)
	c = sheet.cell( row = row, column = column)
	c.value = func_name
	c.alignment = al
	
	sheet.merge_cells(start_row = row, start_column = column + 2, end_row = row, end_column = column + 2 + n_vec[0])
	c = sheet.cell( row = row, column = column + 2)
	c.value = var1_name
	c.alignment = al
	
	sheet.merge_cells(start_row = row + 2, start_column = column, end_row = row + 2 + n_vec[1], end_column = column)
	c = sheet.cell( row = row + 2, column = column)
	c.value = var2_name
	c.alignment = Alignment(horizontal = 'center', vertical = 'center', wrap_text = True)
	
	#create constant list
	data_coef_str = []
	for i in range(100):
		data_coef_str.append( 'C{}'.format(i) )
	
	for i in range(n_vec[0]+1):
		c = sheet.cell( row = row + 1, column = column + 2 + i)
		c.value = data_coef_str[i]
		c.alignment = al
	for i in range(n_vec[1]+1):
		c = sheet.cell( row = row + 2 + i, column = column + 1)
		c.value = data_coef_str[i]
		c.alignment = al
	
	for n in range(n_vec[0]+1):
		for m in range(n_vec[1]+1):
			j = pf.compose_j([n,m], n_vec)
			if a[j] != 0.:
				c = sheet.cell( row = row + 2 + m, column = column + 2 + n)
				c.value = a[j]
				c.alignment = al
	
	c = sheet.cell( row = row, column = column + 2 + n_vec[0] + 2)
	c.value = 'R^2'
	c.alignment = al
	c = sheet.cell( row = row + 1, column = column + 2 + n_vec[0] + 2)
	c.value = r2
	c.alignment = al
	
	c = sheet.cell( row = row + 3, column = column + 2 + n_vec[0] + 2)
	c.value = 'RMS Error'
	c.alignment = al
	c = sheet.cell( row = row + 4, column = column + 2 + n_vec[0] + 2)
	c.value = rms
	c.alignment = al
	
	c = sheet.cell( row = row + 6, column = column + 2 + n_vec[0] + 2)
	c.value = 'RMSN Error'
	c.alignment = al
	c = sheet.cell( row = row + 7, column = column + 2 + n_vec[0] + 2)
	c.value = rmsn
	c.alignment = al
	
	ran = get_column_letter(column)+str(row)+':'+get_column_letter(last_column) + str(last_row)
	rows = sheet[ran]
	border = Border(left = Side(border_style = 'thick'),
	                right = Side(border_style = 'thick'),
	                top = Side(border_style = 'thick'),
	                bottom = Side(border_style = 'thick'))
	bottom = Border(bottom = border.bottom)
	right = Border(right = border.right)
	left = Border(left = border.left)
	top = Border(top = border.top)
	for c in rows[0]:
		c.border = c.border + top
	for c in rows[-1]:
		c.border = c.border + bottom
	for ro in rows:
		l = ro[0]
		r = ro[-1]
		l.border = l.border + left
		r.border += right

#input airfoil file
if len(sys.argv) > 1:
	input_filename = sys.argv[1]
else:
	input_filename = input('\n'*2+'Enter name of file for input: ')
ff = open(input_filename, 'r')
f = json.load(ff)
ff.close()

print('Reading in raw data')

# load excel file
filename_excel = f['step 1']['excel file']
wb = load_workbook(filename_excel+'.xlsx')
ws_coef = wb.active
ws_coef.title = 'Function Coefficients'
ws_coef_row = 1

#setup flap deflection range
df_min = f['step 1']['flap deflection']['min']
df_max = f['step 1']['flap deflection']['max']
delta_df = f['step 1']['flap deflection']['delta']
N_df = int((df_max-df_min)/delta_df) + 1

#setup aoa range
aoa_min = f['step 1']['angle of attack']['min']
aoa_max = f['step 1']['angle of attack']['max']
delta_aoa = f['step 1']['angle of attack']['delta']
N_aoa = int((aoa_max-aoa_min)/delta_aoa) + 1

#poly_fit variables
x = []
CL = []
CD = []
Cm = []
Ch = []
n_vec_CL = f['step 2']['CL']
n_vec_CD = f['step 2']['CD']
n_vec_Cm = f['step 2']['Cm']
n_vec_Ch = f['step 2']['Ch']

#read xfoil setup variables
ncrit = f['step 1']['ncrit']
xtr = f['step 1']['xtr']
NACA = f['step 1']['NACA']
grid = f['step 1']['grid']
Re = f['step 1']['Re']
xhinge = f['step 1']['xf']
Niter = f['step 1']['Niter']

#write xfoil setup variables to excel file
for i in range(2,15):
	ws_coef.column_dimensions[get_column_letter(i)].width = 11.

al = Alignment(horizontal = 'center', vertical = 'center')
ws_coef.merge_cells( start_row = 2, start_column = 2, end_row = 2, end_column = 14 )
c = ws_coef.cell( row = 2, column = 2)
c.value = 'XFOIL settings'
c.alignment = al

c = ws_coef.cell( row = 3, column = 2)
c.value = 'Re'
c.alignment = al

c = ws_coef.cell( row = 3, column = 3)
c.value = 'x, trip'
c.alignment = al

c = ws_coef.cell( row = 3, column = 4)
c.value = 'Ncrit'
c.alignment = al

c = ws_coef.cell( row = 3, column = 5)
c.value = 'airfoil grid'
c.alignment = al

c = ws_coef.cell( row = 3, column = 6)
c.value = 'NACA'
c.alignment = al

c = ws_coef.cell( row = 3, column = 7)
c.value = 'x, hinge'
c.alignment = al

c = ws_coef.cell( row = 3, column = 8)
c.value = 'iterations'
c.alignment = al

c = ws_coef.cell( row = 3, column = 9)
c.value = 'flap, min'
c.alignment = al

c = ws_coef.cell( row = 3, column = 10)
c.value = 'flap, max'
c.alignment = al

c = ws_coef.cell( row = 3, column = 11)
c.value = 'flap, step'
c.alignment = al

c = ws_coef.cell( row = 3, column = 12)
c.value = 'aoa, min'
c.alignment = al

c = ws_coef.cell( row = 3, column = 13)
c.value = 'aoa, max'
c.alignment = al

c = ws_coef.cell( row = 3, column = 14)
c.value = 'aoa, step'
c.alignment = al

c = ws_coef.cell( row = 4, column = 2)
c.value = Re
c.alignment = al

c = ws_coef.cell( row = 4, column = 3)
c.value = xtr
c.alignment = al

c = ws_coef.cell( row = 4, column = 4)
c.value = ncrit
c.alignment = al

c = ws_coef.cell( row = 4, column = 5)
c.value = grid
c.alignment = al

c = ws_coef.cell( row = 4, column = 6)
c.value = NACA
c.alignment = al

c = ws_coef.cell( row = 4, column = 7)
c.value = xhinge
c.alignment = al

c = ws_coef.cell( row = 4, column = 8)
c.value = Niter
c.alignment = al

c = ws_coef.cell( row = 4, column = 9)
c.value = df_min
c.alignment = al

c = ws_coef.cell( row = 4, column = 10)
c.value = df_max
c.alignment = al

c = ws_coef.cell( row = 4, column = 11)
c.value = delta_df
c.alignment = al

c = ws_coef.cell( row = 4, column = 12)
c.value = aoa_min
c.alignment = al

c = ws_coef.cell( row = 4, column = 13)
c.value = aoa_max
c.alignment = al

c = ws_coef.cell( row = 4, column = 14)
c.value = delta_aoa
c.alignment = al

ran = 'B2:N4'
rows = ws_coef[ran]
border = Border(left = Side(border_style = 'thick'),
                right = Side(border_style = 'thick'),
                top = Side(border_style = 'thick'),
                bottom = Side(border_style = 'thick'))
bottom = Border(bottom = border.bottom)
right = Border(right = border.right)
left = Border(left = border.left)
top = Border(top = border.top)
for c in rows[0]:
	c.border = c.border + top
for c in rows[-1]:
	c.border = c.border + bottom
for ro in rows:
	l = ro[0]
	r = ro[-1]
	l.border = l.border + left
	r.border += right

count = 0

#loop through the flap deflection range
for i in range(N_df):
	#set the flap deflection for this loop iteration
	df = df_min + float(i) * delta_df
	
	#determine the filename
	if df < 0.:
		sgn = 'n'
	else:
		sgn = 'p'
	filename = '{}{:0>2d}'.format(sgn,int(abs(df)))       # filename cannot be greater than 6 characters long
	
	#create a new excel sheet
	ws = wb[filename]
	ws_row = 1
	
	#initialize some variable to extract data from the xfoil run
	N = ws.max_row - 1
	#extract data from xfoil run and put it on the excel sheet
	for j in range(N):
		#extract data from sheet
		x.append([])
		ws_row += 1
		col = 1
		x[count].append( ws.cell(row = ws_row, column = col).value )
		x[count].append( df )
		col += 1
		# aoa_deg[j] = ws.cell(row = ws_row, column = col).value #, value = aoa_deg[j])
		col += 1
		CL.append( ws.cell(row = ws_row, column = col).value )
		col += 1
		CD.append( ws.cell(row = ws_row, column = col).value )
		col += 1
		Cm.append( ws.cell(row = ws_row, column = col).value )
		col += 1
		Ch.append( ws.cell(row = ws_row, column = col).value )
		
		count += 1

print('Performing CL curve fit')
aCL, rCL = pf.multidimensional_poly_fit(n_vec_CL, x, CL, sym_same = [[0,1]])
rmsCL, rmsnCL = pf.multidimensional_rms(x, CL, aCL, n_vec_CL)
print('Performing CD curve fit')
aCD, rCD = pf.multidimensional_poly_fit(n_vec_CD, x, CD, sym_diff = [[0,1]])
rmsCD, rmsnCD = pf.multidimensional_rms(x, CD, aCD, n_vec_CD)

#############################################################################
# print('generating 3D plot')
# import matplotlib.pyplot as plt
# from mpl_toolkits.mplot3d import Axes3D

# aoa_plot = []
# df_plot = []
# CD_plot = []
# f_plot = []
# #error_plot = []
# for i,xx in enumerate(x):
	# if i%30 == 0:
		# aoa_plot.append( xx[0] * 180. / np.pi )
		# df_plot.append( xx[1] )
		# CD_plot.append( CD[i] )

# aoa_plot1 = []
# df_plot1 = []
# for i in np.linspace(-15.,15.,10) * np.pi / 180.:
	# for j in np.linspace(-20.,20.,100):
		# xx = [i,j]
		# aoa_plot1.append( i * 180. / np.pi )
		# df_plot1.append( j )
		# f_plot.append( pf.multidimensional_poly_func(aCD,n_vec_CD,xx) )
		# #error_plot.append( CD[i] - pf.multidimensional_poly_func(aCD,n_vec_CD,xx) )

# fig1 = plt.figure()
# ax1 = fig1.add_subplot(111, projection='3d')
# ax1.scatter(aoa_plot,df_plot,CD_plot,'b')
# ax1.scatter(aoa_plot1,df_plot1,f_plot,'r')
# ax1.set_xlabel('aoa')
# ax1.set_ylabel('df')
# ax1.set_zlabel('CD')
# #ax1.set_title('Symmetric Inner')
# #ax1.set_xlim3d(-.05,.05)

# #fig2 = plt.figure()
# #ax2 = fig2.add_subplot(111, projection = '3d')
# #ax2.scatter(aoa_plot, df_plot, error_plot, 'r')
# #ax2.set_xlabel('aoa')
# #ax2.set_ylabel('df')
# #ax2.set_zlabel('error')

# plt.show()


#############################################################################

print('Performing Cm curve fit')
aCm, rCm = pf.multidimensional_poly_fit(n_vec_Cm, x, Cm)
rmsCm, rmsnCm = pf.multidimensional_rms(x, Cm, aCm, n_vec_Cm)
print('Performing Ch curve fit')
aCh, rCh = pf.multidimensional_poly_fit(n_vec_Ch, x, Ch)
rmsCh, rmsnCh = pf.multidimensional_rms(x, Ch, aCh, n_vec_Ch)





row = 6
column = 2
display_coef('aoa', 'control deflection', 'CL', n_vec_CL, aCL, rCL, rmsCL, rmsnCL, row, column, ws_coef)
display_coef('aoa', 'control deflection', 'CD', n_vec_CD, aCD, rCD, rmsCD, rmsnCD, row + n_vec_CL[1] + 4, column, ws_coef)
display_coef('aoa', 'control deflection', 'Cm', n_vec_Cm, aCm, rCm, rmsCm, rmsnCm, row + n_vec_CL[1] + 4 + n_vec_CD[1] + 4, column, ws_coef)
display_coef('aoa', 'control deflection', 'Ch', n_vec_Ch, aCh, rCh, rmsCh, rmsnCh, row + n_vec_CL[1] + 4 + n_vec_CD[1] + 4 + n_vec_Cm[1] + 4, column, ws_coef)

print('writing results to excel file and generating airfoil json file')

#loop through the flap deflection range
for i in range(N_df):
	#set the flap deflection for this loop iteration
	df = df_min + float(i) * delta_df
	
	#determine the filename
	if df < 0.:
		sgn = 'n'
	else:
		sgn = 'p'
	filename = '{}{:0>2d}'.format(sgn,int(abs(df)))       # filename cannot be greater than 6 characters long
	
	#create a new excel sheet
	ws = wb[filename]
	ws_row = 1
	
	#initialize some variable to extract data from the xfoil run
	N = ws.max_row - 1
	aoa_raw_deg = [None] * N
	aoa_raw_rad = np.zeros((N,2))
	CL_raw = [None] * N
	CD_raw = [None] * N
	Cm_raw = [None] * N
	Ch_raw = [None] * N
	#extract data from xfoil run and put it on the excel sheet
	for j in range(N):
		#extract data from sheet
		ws_row += 1
		col = 1
		aoa_raw_rad[j,0] = ws.cell(row = ws_row, column = col).value
		aoa_raw_rad[j,1] = df
		col += 1
		aoa_raw_deg[j] = ws.cell(row = ws_row, column = col).value
		col += 1
		CL_raw[j] = ws.cell(row = ws_row, column = col).value
		col += 1
		CD_raw[j] = ws.cell(row = ws_row, column = col).value
		col += 1
		Cm_raw[j] = ws.cell(row = ws_row, column = col).value
		col += 1
		Ch_raw[j] = ws.cell(row = ws_row, column = col).value
	
	#create trendline data
	N_plot = 100
	CD_anal = [None] * N_plot
	CL_anal = [None] * N_plot
	Cm_anal = [None] * N_plot
	Ch_anal = [None] * N_plot
	aoa_anal_deg = np.linspace(aoa_min,aoa_max,N_plot)
	aoa_anal_rad = aoa_anal_deg * np.pi / 180.
	
	r2CL = pf.multidimensional_r2(aCL, n_vec_CL, aoa_raw_rad, CL_raw)
	r2CD = pf.multidimensional_r2(aCD, n_vec_CD, aoa_raw_rad, CD_raw)
	r2Cm = pf.multidimensional_r2(aCm, n_vec_Cm, aoa_raw_rad, Cm_raw)
	r2Ch = pf.multidimensional_r2(aCh, n_vec_Ch, aoa_raw_rad, Ch_raw)
	
	#add trendline date to the excel sheet
	row = 1
	col = 8
	ws.cell(row = row, column = col, value = 'aoa (rad)')
	col += 1
	ws.cell(row = row, column = col, value = 'aoa (deg)')
	col += 1
	ws.cell(row = row, column = col, value = 'CL(aoa,df) r2 = {:.5f}'.format(r2CL))
	col += 1
	ws.cell(row = row, column = col, value = 'CD(aoa,df) r2 = {:.5f}'.format(r2CD))
	col += 1
	ws.cell(row = row, column = col, value = 'Cm(aoa,df) r2 = {:.5f}'.format(r2Cm))
	col += 1
	ws.cell(row = row, column = col, value = 'Ch(aoa,df) r2 = {:.5f}'.format(r2Ch))
	for row in range(N_plot):
		col = 8
		ws.cell(row = row+2, column = col, value = aoa_anal_rad[row])
		col += 1
		ws.cell(row = row+2, column = col, value = aoa_anal_deg[row])
		col += 1
		ws.cell(row = row+2, column = col, value = pf.multidimensional_poly_func(aCL, n_vec_CL, [aoa_anal_rad[row], df]))
		col += 1
		ws.cell(row = row+2, column = col, value = pf.multidimensional_poly_func(aCD, n_vec_CD, [aoa_anal_rad[row], df]))
		col += 1
		ws.cell(row = row+2, column = col, value = pf.multidimensional_poly_func(aCm, n_vec_Cm, [aoa_anal_rad[row], df]))
		col += 1
		ws.cell(row = row+2, column = col, value = pf.multidimensional_poly_func(aCh, n_vec_Ch, [aoa_anal_rad[row], df]))
	
	#set up charts
	point = 12700
	#set up CL chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 9).value
	chart.y_axis.title = 'CL'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws.max_row)
	yvalues = Reference(ws, min_col = 3, min_row = 1, max_row = ws.max_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.marker.size = 5.
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#CL(aoa) series
	xvalues = Reference(ws, min_col = 9, min_row = 2, max_row = N_plot+1)
	yvalues = Reference(ws, min_col =10, min_row = 1, max_row = N_plot+1)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.graphicalProperties.line.solidFill = 'FF0000'
	series.graphicalProperties.line.width = point * 2
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "B2")
	
	#set up CD chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 9).value
	chart.y_axis.title = 'CD'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws.max_row)
	yvalues = Reference(ws, min_col = 4, min_row = 1, max_row = ws.max_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#CD(aoa) series
	xvalues = Reference(ws, min_col =  9, min_row = 2, max_row = N_plot+1)
	yvalues = Reference(ws, min_col = 11, min_row = 1, max_row = N_plot+1)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.graphicalProperties.line.solidFill = 'FF0000'
	series.graphicalProperties.line.width = point * 2
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "L2")
	
	#set up Cm chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 9).value
	chart.y_axis.title = 'Cm'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws.max_row)
	yvalues = Reference(ws, min_col = 5, min_row = 1, max_row = ws.max_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.marker.size = 5.
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#Cm(aoa) series
	xvalues = Reference(ws, min_col =  9, min_row = 2, max_row = N_plot+1)
	yvalues = Reference(ws, min_col = 12, min_row = 1, max_row = N_plot+1)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.graphicalProperties.line.solidFill = 'FF0000'
	series.graphicalProperties.line.width = point * 2
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "V2")
	
	#set up Ch chart
	chart = ScatterChart()
	chart.x_axis.title = ws.cell(row = 1, column = 9).value
	chart.y_axis.title = 'Chinge'
	chart.x_axis.scaling.min = aoa_min
	chart.x_axis.scaling.max = aoa_max
	chart.y_axis.crosses = "min"
	chart.x_axis.crosses = "min"
	chart.height = 15.
	#raw data series
	xvalues = Reference(ws, min_col = 2, min_row = 2, max_row = ws.max_row)
	yvalues = Reference(ws, min_col = 6, min_row = 1, max_row = ws.max_row)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.marker.symbol = 'circle'
	series.marker.size = 5.
	series.graphicalProperties.line.noFill = True
	series.marker.graphicalProperties.noFill = True
	series.marker.graphicalProperties.line.solidFill = '000000'
	series.marker.graphicalProperties.line.width = point
	chart.series.append(series)
	#Ch(aoa) series
	xvalues = Reference(ws, min_col =  9, min_row = 2, max_row = N_plot+1)
	yvalues = Reference(ws, min_col = 13, min_row = 1, max_row = N_plot+1)
	series = Series(yvalues, xvalues, title_from_data = True)
	series.graphicalProperties.line.solidFill = 'FF0000'
	series.graphicalProperties.line.width = point * 2
	chart.series.append(series)
	#add chart to sheet
	ws.add_chart(chart, "B31")

wb.save(filename_excel+'_final'+'.xlsx')

#prep for airfoil database json file
filename = filename_excel
#add common data
json_data = { filename : ''}
json_data[filename] = { 'properties' : ''}
data = {}
data['type'] = 'polynomial'
data['is_function'] = 1
#create constant list
data_coef_str = []
for i in range(100):
	data_coef_str.append( 'C{}'.format(i) )
#setup coefficients for CL
data['CL'] = {}
for n in range(n_vec_CL[0]+1):
	data['CL'][data_coef_str[n]] = {}
	for m in range(n_vec_CL[1]+1):
		j = pf.compose_j([n,m], n_vec_CL)
		if aCL[j] != 0.: data['CL'][data_coef_str[n]][data_coef_str[m]] = aCL[j]
	if data['CL'][data_coef_str[n]] == {}: data['CL'][data_coef_str[n]][data_coef_str[0]] = 0.
#setup coefficients for CD
data['CD'] = {}
for n in range(n_vec_CD[0]+1):
	data['CD'][data_coef_str[n]] = {}
	for m in range(n_vec_CD[1]+1):
		j = pf.compose_j([n,m], n_vec_CD)
		if aCD[j] != 0.: data['CD'][data_coef_str[n]][data_coef_str[m]] = aCD[j]
	if data['CD'][data_coef_str[n]] == {}: data['CD'][data_coef_str[n]][data_coef_str[0]] = 0.
#setup coefficients for Cm
data['Cm'] = {}
for n in range(n_vec_Cm[0]+1):
	data['Cm'][data_coef_str[n]] = {}
	for m in range(n_vec_Cm[1]+1):
		j = pf.compose_j([n,m], n_vec_Cm)
		if aCm[j] != 0.: data['Cm'][data_coef_str[n]][data_coef_str[m]] = aCm[j]
	if data['Cm'][data_coef_str[n]] == {}: data['Cm'][data_coef_str[n]][data_coef_str[0]] = 0.
#setup coefficients for Ch
data['Ch'] = {}
for n in range(n_vec_Ch[0]+1):
	data['Ch'][data_coef_str[n]] = {}
	for m in range(n_vec_Ch[1]+1):
		j = pf.compose_j([n,m], n_vec_Ch)
		if aCh[j] != 0.: data['Ch'][data_coef_str[n]][data_coef_str[m]] = aCh[j]
	if data['Ch'][data_coef_str[n]] == {}: data['Ch'][data_coef_str[n]][data_coef_str[0]] = 0.
data['CL_max'] = ''
data['Comments'] = 'All angles in radians and slopes in 1/radians'
json_data[filename]['properties'] = data
with open(filename+'.json', 'w') as data_file:
	json.dump(json_data, data_file, indent = '\t')

</"file: python/AirfoilDatabase/dev/zach/database_creator_step2.py">

<"file: python/AirfoilDatabase/dev/zach/input.json">{"step 1" : {"NACA" : "0015","xf" : 0.6,"flap deflection" : {"min" : -20.0,"max" : 20.0,"delta" : 1.0},"angle of attack" : {"min" : -15.0,"max" : 15.0,"delta" : 0.1},"ncrit" : 9.0,"xtr" : 0.1,"Re" : 6.28e5,"grid" : 240,"Niter" : 150,"excel file" : "trad"},"step 2" : {"CL" : [4,6],"CD" : [8,10],"Cm" : [4,5],"Ch" : [1,1]}}</"file: python/AirfoilDatabase/dev/zach/input.json">

<"file: python/AirfoilDatabase/dev/zach/poly_fits.py">"""
Generic Multivariable Polynomial Fit Using Least Squares Regression

With full control Of interaction terms And constraint capabilities

This module contains functions to calculate the polynomial coefficients for 
a an arbitrary order polynomial curve fit to a dataset with an arbitrary
number of independent variables.

Originally written by Zach Montgomery
Modified by Cory Goates for AirfoilDatabase
"""
import numpy as np

def multivariablePolynomialFit(Nvec, xx, yy ,interaction=False, sym=[], sym_same=[], sym_diff=[], zeroConstraints=[], constraints=[], percent=False, weighting=None, display=True):
    """Function for calculating a curve fit to data with an arbitrary number of independent variables.

    Parameters
    ----------
    Nvec : list
        list with a length V equal to the number of independent
        variables. The ith element values are integers of polynomial
        order of the ith independent variable
    
    xx : ndarray
        numpy matrix of size k by V, where k is the total number of
        points in the dataset. The ith column represents the ith
        independent variable values with the rows representing the
        different data points
        
    yy : list
        list with a length of k with the dependent variable values

    interation : boolean, optional
        This variable determines whether or not interaction terms are included in the
        fit function. If set to True, interaction terms up the max order
        for each independent variable are included, i.e. if Nvec = [3,2]
        then the highest interaction term included is x_1^3*x_2^2.
        Specific interaction terms can be omitted using the constraints
        input. Defaults to False
        optional list that defaults as an empty list. If used, the

    sym : list, optional
        length should be V and each element should contain a boolean,
        True or False. The ith element determines if the ith independent
        variable is symmetric either even or odd, which is determined by
        the order given in Nvec. This will also remove the cooresponding
        interaction terms if they are enabled.

    sym_same : list, optional
        The entries in the list should be tuples with two integers. The
        integers represent the independent variables that the "same"
        symmetry condition will be applied. The "same" symmetry forces
        all interaction terms.

    sym_diff : list, optional

    zeroConstraints : list, optional
        an optional list that defaults as an empty list.
        Entries in the list contain integer tuples of length V. The
        integer values represent the powers of the independent variables
        whose coefficient will be forced to 0 before the best fit
        calculations are performed, allowing the user to omit specific
        interaction terms or regular polynomial terms

    constraints : list, optional
        an optional list that defaults to an empty list.
        Entries in the list contain tuples of length 2. The first entry 
        is a list of integers that represent the powers of the
        independent variables whose coefficient will then be forced to
        be equal to the second entry in the tuple, which should be a
        float.

    percent : boolean, optional
        boolean value with default set to False. When set to True
        the least squares is performed on the percent error squared.
        This option should not be used if y contains any zero or near
        zero values, as this might cause a divide by zero error.

    weighting : function handle, optional
        optional callable function that defaults to None. If
        given, weighting should be a function that takes as arguments:
        x, y, and p where x and y are the independent and dependent
        variables defined above and p is the index representing a
        certain data point. weighting should return a 'weighting factor'
        that determines how important that datapoint is. Returning a '1'
        weights the datapoint normally.
    
    Returns
    -------
    list
        list of the polynomial coefficients. 'a' has a length equal to
        the products of the n_vec elements plus one.
        i.e.: (n_vec0+1)*(n_vec1+1)*...

    float
        the coefficient of determination, also referred to as the R^2
        value. A value of 1 means the polynomial given by 'a' fits the
        data perfectly
    """
    # input variables and setup calculations
    ########################################################################
    x = np.copy(xx)
    y = np.copy(yy)
    # calculate number of dimensions used
    if type(Nvec) != list:
        Nvec = [Nvec]
    V = len(Nvec)
    # calculate the number of points in dataset
    k = len(y)
    # check for inconsistencies in dimensions from input variables
    if len(x.shape) == 1:
        x = np.transpose([x])
    if x.shape[1] != V: raise ValueError('Dimensions for V don\'t match between n_vec and x. Lenght of n_vec and number of columns of x should equal the number of independent variables used, V.')
    if x.shape[0] != k: raise ValueError('Number of rows between x and y don\'t agree! The number of rows should be the total number of points, k, of the dataset.')
    # calculate the length of the coefficient list to be returned
    J = 1
    for n in Nvec:
        J *= n + 1
    # if sym wasn't given, initialize it to False values
    if type(sym) != list: sym = [sym]
    if sym == []:
        sym = [False] * V
    elif len(sym) != V:
        raise ValueError('Length of sym doesn\'t match the number of dimensions, V.')
    # create active list
    ########################################################################
    # set active to empty list
    active = []
    # loop through j values
    for j in range(J):
        # calculate the n values
        n = decompose_j(j, Nvec)
        # check if n is a constraint then continue on to the next j
        if tuple(n) in zeroConstraints: continue
        # check if j is an interaction term and if interactions aren't allowed then continue on to the next j
        if sum(n) != max(n) and not interaction: continue
        # initialize flag variable to false
        flag = False
        # loop through the sym list to find the symmetry constraints
        for count,symm in enumerate(sym):
            # check if flag has been tripped, then continue to the next j if it has
            if flag: break
            # check for a symmetry constraint
            if symm:
                # check if the order of the count-th independent variable is even
                if Nvec[count]%2 == 0:
                    # check if the n value of the count-th independent variable is odd
                    if n[count]%2 == 1:
                        flag = True
                # this else block means the order of the count-th independent variable is odd
                else:
                    # check if the n value of the count-th independent variable is even
                    if n[count]%2 == 0:
                        flag = True
        # if the flag has been tripped, skip to the next j value
        if flag: continue
        # loop through sym_same constraints
        for val in sym_same:
            # check if the n values from both variables given in val are even, then trip flag
            if n[val[0]]%2 == 0 and n[val[1]]%2 == 0:
                flag = True
            # check if the n values from both variables given in val are odd, then trip flap
            if n[val[0]]%2 == 1 and n[val[1]]%2 == 1:
                flag = True
        # loop through sym_diff constraints
        for val in sym_diff:
            # check if the n values from both variables given in val are even and odd, then trip flag
            if n[val[0]]%2 == 0 and n[val[1]]%2 == 1:
                flag = True
            # check if the n values from both variables given in val are odd and even, then trip flap
            if n[val[0]]%2 == 1 and n[val[1]]%2 == 0:
                flag = True
        # if flag hasn't been tripped, append j value onto the active list
        if not flag: active.append(j)
    #create constraints list
    ########################################################################
    con = {}
    for n,val in constraints:
        j = compose_j(n, Nvec)
        con['{}'.format(j)] = val
    #create A matrix and b vector
    ########################################################################
    # initialize A matrix
    A = np.zeros( ( len(active),len(active) ) )
    # initialize b vector
    b = np.zeros( len(active) )
    # loop through i values
    for ii,i in enumerate(active):
        if display: print('calculating A{}j and b{} values, {:.2f}% done'.format(i,i,ii/len(active)*100))
        # calculate the nhat values
        nhat = decompose_j(i, Nvec)
        # loop through the j values
        for jj,j in enumerate(active):
            # calculate the n values
            n = decompose_j(j, Nvec)
            # calcualte Aij entry
            #####################
            
            if str(i) in con:
                if i == j:
                    A[ii,jj] = 1.
                else:
                    A[ii,jj] = 0.
            else:
                # initialize summ to 0
                summ = 0.
                # loop through points in dataset
                for p in range(1,k+1):
                    # initialize product series variable to 1
                    if y[p-1] != None:
                        prod = 1.
                    else:
                        prod = 0.
                    # loop through dimensions
                    for v in range(1,V+1):
                        # multiply the term onto the product series
                        prod *= x[p-1,v-1] ** (n[v-1] + nhat[v-1])
                    #==================================================
                    # add weighting factor
                    if callable(weighting):
                        prod *= weighting(x, y, p-1)
                    #==================================================
                    # add the product series variable to the summation
                    if percent:
                        if y[p-1] != None: summ += prod/abs(y[p-1])
                    else:
                        summ += prod
                # set Aij to the finalized summation
                A[ii,jj] = summ
        # calculate bi entry
        ####################
        if str(i) in con:
            b[ii] = con[str(i)]
        else:
            # initialize summation variable to 0
            summ = 0.
            # loop through points in the dataset
            for p in range(1,k+1):
                # initialize the product series variable to 1
                if y[p-1] != None:
                    prod = 1.
                else:
                    prod = 0.
                # loop through the dimensions
                for v in range(1,V+1):
                    # multiply the term onto the product series
                    prod *= x[p-1,v-1] ** nhat[v-1]
                #==================================================
                # add weighting factor
                if callable(weighting) and y[p-1] != None:
                    prod *= weighting(x, y, p-1)
                #==================================================
                # add the term onto the summation
                if percent:
                    summ += prod
                else:
                    if y[p-1] != None: summ += y[p-1] * prod
            # set bi to the finalized summation
            b[ii] = summ
    #solve Aa=b equation
    ########################################################################
    if display: print('solving the Aa=b equation')
    a = np.linalg.solve(A,b)
    #input the missing 0 coefficients into 'a' so that it can be used with the multidimensional_poly_func
    ########################################################################
    for i in range(J):
        if not i in active:
            a = np.insert(a,i,0.)
            active = np.insert(active,i,0)
    #calculate R^2 value
    ########################################################################
    r = multivariableR2(a, Nvec, x, y)       #r2_2D(a,M,x,y,z)
    #return values
    return a, r

def multivariablePolynomialFunction(a, Nvec, x):
    """Function for calculating a polynomial with an arbitrary number of independent variables
    
    Parameters
    ----------
    a : list
        list of the polynomial coefficients. 'a' has a length equal to
        the products of the Nvec elements plus one.
        i.e.: (Nvec0+1)*(Nvec1+1)*...

    Nvec : list
        list with a length V equal to the number of independent
        variables. The ith element values are integers of polynomial
        order of the ith independent variable

    x : ndarray
        numpy matrix of size k by V, where k is the total number of
        points in the dataset. The ith column represents the ith
        independent variable values with the rows representing the
        different data points
    
    Returns
    -------
    float
        value of the multivariable polynomial function for the given
        independent variables
    """
    # initialize summation to 0
    f = 0.
    # calculate total number of datapoints
    k = len(a)
    # calculate total number of dimensions
    V = len(x)
    # loop through the datapoints
    for j in range(k):
        # calculate the n values
        n = decompose_j(j, Nvec)
        # initialize the product series variable to 1
        prod = 1.
        # loop through the dimensions
        for v in range(V):
            # multiply onto the product series the term
            prod *= x[v] ** n[v]
        # add onto the summation the proper term
        f += a[j] * prod
    # return the finalized summation value
    return f

def multivariableR2(a, Nvec, xx, yy):
    """Function calculating the coefficient of determination value, or R^2 value, of a polynomial fit of an arbitrary number of
    independent variables.
    
    Parameters
    ----------
    a : list
        array of polynomial coefficients

    Nvec : list
        list of integers representing the polynomial order of the
        independent variables

    xx : ndarray
        numpy matrix of size k by V, where k is the total number of
        points in the dataset. The ith column represents the ith
        independent variable values with the rows representing the
        different data points
    yy : list
        list with a length of k with the dependent variable values
    
    Returns
    -------
    float
        R^2 value, or the coefficient of determination
    """
    # ensure x and y are in the proper format
    x = np.copy(xx)
    y = np.copy(yy)
    ynew = np.copy([temp for temp in y if temp != None])
    # calculate k
    k = len(ynew)
    # calculate mean y value
    y_ = sum(ynew) / float(k)
    # calculate the SSt value
    SSt = sum( (ynew - y_) ** 2. )
    # initialize the f array
    f = []
    # loop through the datapoints
    for i in range(len(y)):
        if y[i] == None: continue
        # calculate the f value from the polynomial function
        f.append( multivariablePolynomialFunction(a,Nvec,x[i,:]) )
    f = np.copy(f)
    # calculate the SSr term
    SSr = sum( (ynew - f) ** 2. )
    # calculate and return the R^2 value
    return 1. - SSr / SSt

def multivariableRMS(raw_x, raw_y, a, Nvec):
    """Function calculating an RMS (root, mean, squared) error
    and a custom RMSN (root, mean, squared, normalized) error where
    normalized means the error is divided by the mean of the absolute value
    of the dependent variables, for a multidimensional polynomial function
    
    Parameters
    ----------
    raw_x : ndarray
        array of independent variables values from the dataset of
        shape (k,V) where k is the total number of points in the dataset
        and V is the number of independent variables

    raw_y : ndarray
        array of dependent variable values from the dataset
    a : ndarray
        array of polynomial coefficients
    Nvec : ndarray
        list of integers representing the polynomial order of the
        independent variables
    
    Returns
    -------
    float
        root, mean, squared error

    float
        root, mean, squared, normalized error
    """
    x = np.copy( raw_x )
    y = np.copy( raw_y )
    avg = np.mean(abs(y))
    k = len(x[:,0])
    func = np.zeros(k)
    e = np.zeros(k)
    e_per = np.zeros(k)
    for i in range(k):
        func[i] = multivariablePolynomialFunction(a, Nvec, x[i])
        e[i] = (y[i] - func[i]) ** 2.
        e_per[i] = ((y[i] - func[i])/avg) ** 2.
    return np.sqrt(np.mean(e)), np.sqrt(np.mean(e_per))

def compose_j(n, Nvec):
    """ Function used by the multivariable series of functions that
    composes the n values of the independent variables into the counter j,
    this function cal also be used for the nhat values and i
    Eq. 4 in Poly Fits Derivation. Can also be used as Eq. 10 with the i counter and the nhat
    values.
    
    Parameters
    ----------
    n : list
        list of integer values representing the independent variables'
        exponents for the jth term in the multidimensional polynomial
        function (Eq. 2)

    Nvec : list
        list of integers representing the polynomial order of the
        independent variables
    
    Returns
    -------
    int
        integer representing the column of the A matrix or the jth
        polynomial coefficient
    """
    # calculate V
    V = len(Nvec)
    # initialize j to 0
    j = 0
    # loop through independent variables
    for v in range(1,V+1):
        # initialize product series to 1
        prod = 1
        # loop through w values for product series
        for w in range(v+1,V+1):
            # multiply on the term to the product series
            prod *= Nvec[w-1] + 1
        # add on term onto j
        j += n[v-1] * prod
    return j

def decompose_j(j, Nvec):
    """Function used by the multivariable seris of functions that
    decomposes the counter j into the different n values for the independent
    variables, this function can also be used for i and the nhat values.
    Eq. 5 in Poly Fits Derivation. Routine to decompose the j counter into
    the n values. Can also be used as Eq. 1 with the i counter and the nhat
    values.
    
    Parameters
    ----------
    j : int
        integer representing the column of the A matrix or the jth
        polynomial coefficient

    Nvec : list
        list of integers representing the polynomial order of the
        independent variables
    
    Returns
    -------
    list
        list of integer values representing the independent variables'
        exponents for the jth term in the multidimensional polynomial
        function (Eq. 2)
    """
    # calculate V
    V = len(Nvec)
    # initialize n values to nothing
    n = [[]]*V
    # loop through the n values that need to be solved, starting at the highest and working down
    for v in range(V,0,-1):
        # initialize the denomenator product series to 1
        denom = 1
        # loop through the w values needed for the product series
        for w in range(v+1,V+1):
            # multiply on the terms for the denomenator product series
            denom *= Nvec[w-1] + 1
        # initialize the summation variable to 0
        summ = 0
        # loop through the u values necessary for the summation
        for u in range(v+1,V+1):
            # initialize the product series variable inside the summation to 1
            prod = 1
            # loop through the s values needed for the product series that is inside the summation
            for s in range(u+1,V+1):
                # multiply on the term for the product series that is inside of the summation
                prod *= Nvec[s-1] + 1
            # add on the needed term to the summation series
            summ += n[u-1] * prod
        # finally calculate the n value cooresponding to this v
        n[v-1] = int(round( ((j-summ)/denom)%(Nvec[v-1]+1) ))
    return n


</"file: python/AirfoilDatabase/dev/zach/poly_fits.py">

<"file: python/AirfoilDatabase/dev/zach/xfoil.py">import subprocess
import math
import re
from collections import OrderedDict, Iterable
import json
import os


def generate_machup_from_xfoil(airfoils, alpha_min, alpha_max, delta_alpha, reynolds_number, grid_size, niter, ncrit, xtrt, xtrb, flap=0.0, xf=1.0, yf=0.0):
	if not isinstance(airfoils, Iterable): airfoils = [airfoils]
	for airfoil in airfoils:
		drag_polar_filename = execute(airfoil, 0.0, alpha_min, delta_alpha, reynolds_number, grid_size, niter, ncrit, xtrt, xtrb, flap, xf, yf)
		results1 = read_results_from_DP_file(drag_polar_filename)
		results1.remove(results1[-1])

		drag_polar_filename = execute(airfoil, 0.0, alpha_max, delta_alpha, reynolds_number, grid_size, niter, ncrit, xtrt, xtrb, flap, xf, yf)
		results2 = read_results_from_DP_file(drag_polar_filename)

		airfoil_name = 'NACA{}_Re={:.2E}_N={}_xtrt={}_xtrb={}'.format(airfoil, reynolds_number, ncrit, xtrt, xtrb)
		nskip = int(round(1.0 / delta_alpha))
		write_machup_airfoil(airfoil_name, results1, results2)
		for i in results2:
			results1.append(i)
	return results1

def execute(airfoil, alpha_start, target_alpha, delta_alpha, reynolds_number, grid_size, n_iter, ncrit, xtrt, xtrb, flap, xf, yf):
	case_name = '{}_Re={:.1E}_N={:3.1f}_xtrt={:3.1f}_xtrb={:3.1f}_{:0<5.1f}deg'.format(
		airfoil, reynolds_number, ncrit, xtrt, xtrb, target_alpha)
	drag_polar_filename = 'XFOIL_{0}_DP.txt'.format(case_name)
	if os.path.exists(drag_polar_filename): os.remove(drag_polar_filename)
	
	# Start execution of XFOIL
	with subprocess.Popen([''],
						  stdin = subprocess.PIPE,
						  stdout = subprocess.PIPE
						 ) as ps:
		commands = []
		isfile = False
		try:
			float(airfoil)
		except(ValueError):
			isfile = True
		if((len(airfoil)==4) and not isfile):
			commands = ['NACA {}'.format(airfoil).encode('utf-8')]
		else:
			commands = ['LOAD {}'.format(airfoil).encode('utf-8'),
						b'new']
		# Set up commands
		commands += [b'GDES',
					b'FLAP',
					'{}'.format(xf).encode('utf-8'),
					'{}'.format(yf).encode('utf-8'),
					'{}'.format(flap).encode('utf-8'),
					# b'GSET',
					b'EXEC',
					b'',
					b'PPAR',
					'N {}'.format(grid_size).encode('utf-8'),
					b'T 1',
					b'',
					b'',
					b'PANE',
					b'PPAR',
					b'',
					b'OPER',
					b'HINC',
					'VISC {}'.format(reynolds_number).encode('utf-8'),
					'ITER {}'.format(n_iter).encode('utf-8'),
					b'VPAR',
					'N {}'.format(ncrit).encode('utf-8'),
					'XTR {} {}'.format(xtrt, xtrb).encode('utf-8'),
					b'',
					b'PACC',
					drag_polar_filename.encode('utf-8'),
					b''
					]

		# Iterate to the desired alpha using the specified delta
		step = int(math.copysign(1, target_alpha))
		nstep = int(round(abs((target_alpha - alpha_start) / delta_alpha))) + 1
		alphas = [i * delta_alpha + alpha_start for i in range(0, nstep, step)]
		for i in range(0, int(target_alpha / delta_alpha) + step, step):
			commands.append('ALFA {}'.format(i * delta_alpha).encode('utf-8'))

		# Finish commands
		commands += [b'PACC',
					 b'',
					 b'QUIT'
					]
		# print('commands:')
		# print(commands)

		# Execute the commands and record the output
		response = ps.communicate(b'\n'.join(commands))[0].decode('utf-8')

	# Write the output to a file
	response = response.replace('\r\n', '\n')
	response = response.replace('a =-', 'a = -')
	# print('response:')
	print(response)
	output_filename = 'XFOIL_{}_dump.txt'.format(case_name)
	with open(output_filename, 'w') as file:
		file.write(response)

	return drag_polar_filename


def write_machup_airfoil(airfoil_name, results1, results2):
	airfoil_filename = airfoil_name + '.txt'
	with open(airfoil_filename, 'w') as file:
		fmt = '{:>7}\t {:>7}\t {:>7}\t {:>7}\n'
		file.write(fmt.format('alpha', 'CL', 'CD', 'Cm'))
		for i in range(0, len(results1)):
			file.write(fmt.format(results1[i][0], results1[i][1], results1[i][2], results1[i][3]))
		for i in range(0, len(results2)):
			file.write(fmt.format(results2[i][0], results2[i][1], results2[i][2], results2[i][3]))

		#always write out the last data point
#        l = len(results2) - 1
#        file.write(fmt.format(results2[l][0], results2[l][1], results2[l][2], results2[l][3]))

	json_properties = OrderedDict()
	json_properties['type'] = "datafile"
	json_properties['filename'] = airfoil_filename
	json_properties['Comments'] = "Tabular reference data from XFOIL"

	json_airfoil = OrderedDict()
	json_airfoil['properties'] = json_properties

	airfoil_name = airfoil_name.replace('.', 'p')
	json_data = OrderedDict()
	json_data[airfoil_name] = json_airfoil

	with open(airfoil_name + '.json', 'w') as json_file:
		json.dump(json_data, json_file, indent = 4)


def read_results_from_DP_file(results_filename):
	# Parse the output and extract alpha, CL, CD, and Cm
	results = []

	with open(results_filename, 'r') as results_file:
		results_text = results_file.readlines()

	header_regex = re.compile('.*alpha.*CL.*CD.*CDp.*CM.*Chinge.*Top_Xtr.*Bot_Xtr.*')
	header_iter = (item for item in results_text if re.match(header_regex, item))
	header = next(header_iter, None)
	if header is not None:
		ind = results_text.index(header)
		for i in range(ind + 2, len(results_text)):
			data = results_text[i].split()
			alpha = float(data[0])
			cL = float(data[1])
			cD = float(data[2])
			cm = float(data[4])
			cH = float(data[5])
			results.append([alpha, cL, cD, cm, cH])

	return sorted(results, key = lambda result: result[0])


def read_results_from_dump_file(dump_filename):
	# Parse the output and extract alpha, CL, CD, and Cm
	results = []

	with open(dump_filename, 'r') as dump_file:
		dump = dump_file.readlines()

	oper_regex = re.compile('\.OPERva   c>.*')
	alpha_regex = re.compile('.* a = .* CL = .*')
	cm_regex = re.compile('.* Cm = .* CD = .*')
	iter = (item for item in dump if re.match(oper_regex, item))
	ind = 0
	item = next(iter, None)
	while item is not None:
		ind = dump.index(item, ind + 1)
		alpha_line = dump[ind - 6]
		cm_line = dump[ind - 5]
		if re.match(alpha_regex, alpha_line) and re.match(cm_regex, cm_line):
			alpha_line = alpha_line.split()
			alpha = float(alpha_line[2])
			cL = float(alpha_line[5])

			cm_line = cm_line.split()
			cm = float(cm_line[2])
			cD = float(cm_line[5])

			results.append([alpha, cL, cD, cm])

		item = next(iter, None)

	return results
</"file: python/AirfoilDatabase/dev/zach/xfoil.py">

<"file: python/AirfoilDatabase/docs/source/conf.py"># Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# http://www.sphinx-doc.org/en/master/config

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

import os
import sys
sys.path.insert(0, os.path.abspath('../'))


# -- Project information -----------------------------------------------------

project = 'Airfoil Database'
copyright = '2019, Cory Goates, Doug Hunsaker'
author = 'Cory Goates, Doug Hunsaker'

# The full version, including alpha/beta/rc tags
release = '1.4.3'


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ["recommonmark", "sphinx.ext.autodoc", "sphinx.ext.napoleon", "sphinx_markdown_tables"]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = []

master_doc = 'index'


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'alabaster'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']
</"file: python/AirfoilDatabase/docs/source/conf.py">

<"file: python/AirfoilDatabase/examples/my_airfoil_fits.json">{"tag": "Polynomial fit to database for my_airfoil airfoil.","degrees_of_freedom": ["trailing_flap_deflection","alpha","Rey","Mach","trailing_flap_fraction"],"limits": [[-0.3490658503988659,0.3490658503988659],[-0.08726646259971647,0.08726646259971647],[100000.0,400000.0],[0.0,0.4],[0.0,0.5]],"fit_degrees": {"CL": [1,3,1,2,1],"CD": [1,4,1,2,1],"Cm": [1,1,1,2,1]},"fit_error": {"CL": {"R^2": 0.9781049509616333,"RMS": 0.11414218794151114,"RMSN": 0.18005462123710944},"CD": {"R^2": 0.500523184114656,"RMS": 0.012734794341878797,"RMSN": 0.5543333269387577},"Cm": {"R^2": 0.9186234633537477,"RMS": 0.026782113107223473,"RMSN": 0.38864448891247927}},"fit_coefs": {"CL": [0.0006529139539593611,0.006070724659125352,-0.003936637664895039,-0.1919418577055944,0.006015568239329886,0.2746575032042677,-1.9165380093404774e-09,-6.093797721505262e-09,-2.809305321105417e-07,1.8096146544134599e-06,7.063941600212054e-07,-4.227228357563265e-06,11.673596520386608,-2.5123405452606717,-1.3856621632434132,-15.731968793873618,15.019545035805427,35.20400508806731,-1.0947824869745818e-05,-1.0686280794454268e-05,-7.566168551566001e-07,9.621650588102251e-05,-2.8305057231494576e-05,-0.0002224000170090528,-1.2918029193570115,2.3874271754504415,7.317306666948212,-4.5691064066161715,4.680423694801593,-55.6868931621174,3.162143682141194e-06,-9.764390401141975e-06,1.3959068911989552e-05,-5.634492964555167e-05,-9.983942835932946e-05,0.000440616591662768,-673.0519659348598,630.6602177935641,330.33546863065203,1361.4401206221767,-2037.8762834921606,-3476.315818326386,0.0018428331402679074,-0.001761346810115741,-2.154945563295023e-05,-0.013164089850031886,0.004160524389280622,0.03700730561480283,-0.04598032941299051,7.61721590791988,0.31747367526546827,-4.0018896056598665,-0.8688383950549046,18.166645090428933,8.15553891342978e-07,4.6671377758720425e-06,-5.445016384038179e-07,-6.365826624856297e-08,-5.121748318288268e-07,2.2916169632356022e-05,0.48869216838794927,-1.413147436957745,4.921032022889859,-71.63625931432725,-15.492255858865162,161.09905188289878,-1.264739575078003e-06,2.0119897653288957e-06,-4.015766211704925e-05,0.0005631788800892284,0.00011760922181860582,-0.0014044822735280054,33.44783660484068,-167.56592201083453,108.98803573840785,-265.54148315997753,-347.76592486634416,247.71538813913483,-0.00014249640008926157,0.0005359373449886828,-0.00028903096865857687,0.0013047977460732961,0.0009487554515518183,-0.0043126683524150715,-97.67450576537901,266.42347813325244,-660.7431356829607,10600.557509349066,2908.878626138132,-30490.17907960651,0.0002562734776639749,-0.00011069081780724749,0.005697148558209212,-0.08269134725193097,-0.01964879600675141,0.23305988231471192],"CD": [0.019424427545896693,0.05393256102289288,-0.0049803607976096845,0.1290106558817296,0.023081503251104408,-0.5194128117185605,-3.368326701156759e-08,-3.5525184079003505e-08,1.912142554799228e-09,-1.3678029524347972e-07,1.0367686546026796e-08,5.650536195100569e-07,-0.00015198202607929624,0.26189121649480823,0.08033837617585957,-1.7693151311617596,-0.3129944691039405,2.015489290774751,2.8633188479355756e-09,-7.60394085815272e-07,3.123915087873441e-07,3.424117656998395e-08,-8.82988599850586e-07,7.0594504793174e-06,-2.568084334664504,3.724417572715878,-1.4473594400834295,58.59341014864897,10.230352471324899,-154.0237974586124,8.854144779553348e-06,-1.4154996664138264e-05,2.1346552294782833e-06,-0.0002697819345118469,-2.3697589724086594e-05,0.0007188742689507218,0.015288200922780399,-45.25903146156209,-17.06940059054898,303.57321971051095,62.30496289782326,-337.53212527716283,1.4698169206861137e-06,0.00014703569764852421,-3.025660864547143e-06,-0.00029797366298235325,-1.1213203773149105e-05,-0.0007394042555274438,273.3910128429444,73.89631122957594,150.16709760172418,-7202.720722516091,-441.59808437997543,17463.59758887654,-0.0007663207274206113,0.00014532454245917985,-0.0005373378566207946,0.03457498720546787,0.0018232166358209737,-0.08523132044309589,-0.0009151803528399473,-0.02416939491914432,0.007688901797081575,-0.08565511603987008,-0.031134721230278623,1.162534724623293,3.93129288864631e-09,5.26850647906165e-08,-3.6108649837207e-08,2.7143955900150453e-07,1.1092983796505293e-07,-3.0364058015935334e-06,-0.0031023706024358466,-2.3063280765871763,-0.9279258600414964,-11.933120796638754,3.256946898116006,28.745751194599638,-2.2106959427296495e-08,1.020899729829337e-05,6.792559927108396e-06,-8.234569656423655e-07,-2.0982942183463644e-05,1.6003373380411952e-05,1.840678152496276,-35.14142301515567,-10.369173198754439,210.95432348431348,3.6913616309691784,-190.46023589846854,-6.809518775752357e-06,0.0001015687197688125,9.447359792806748e-05,-0.0013860470152167552,-0.00013441843185111728,0.0027294019861014997,9.572919246191201,257.78189501652565,104.55243056860623,1938.1063177628873,-450.3241526459017,-2842.4234107442826,-5.745565814511706e-05,-0.0005626086465736218,-0.0007272916669048069,-0.0011987856035845482,0.002749647549639505,-0.004747281418015816,-301.8890629680173,5255.907505313264,2663.047182323554,-34463.95574510284,-4470.950326836203,40902.866096635946,0.0008657735277496505,-0.016122132701838363,-0.017124891113403228,0.2089671997375925,0.03388756173534946,-0.41724517632576885],"Cm": [0.0009637535006718828,-0.0034754403562530655,-0.010789454463028217,0.025900823195945378,0.0072637302880600345,0.04373545906826952,-1.8100121561432168e-09,6.944259225009512e-09,4.604839432635973e-08,-1.965714130209587e-07,-7.251544975051202e-08,1.821633231110645e-07,-0.3109520736101775,0.31633147261236744,-0.08228520590587318,1.8681513560935497,0.7037175415955553,-5.197759867781165,2.900762496473789e-07,2.1326228938990667e-06,-5.18821706963806e-07,-6.113092376775174e-06,2.0732474204233458e-06,1.3226493899896779e-05,-0.02411203598617233,-0.9206962297128488,-0.15719968388020628,0.9971157866125534,0.5168995321093283,-3.8858048062963784,-1.0367770414961872e-07,-8.316529263912934e-07,4.462446519257626e-07,-4.7671256702174755e-07,-1.0287195643821286e-06,-1.778681144964617e-06,-0.00457017788518418,-0.1746844124962759,0.02024656150521794,2.3189140523432186,-0.8090772704403468,3.038333395736555,-1.0844752552640526e-07,5.223270197278693e-07,8.888349434540078e-07,-2.2693394029923555e-05,1.5990842381324263e-06,2.8180915990688977e-05]}}</"file: python/AirfoilDatabase/examples/my_airfoil_fits.json">

<"file: python/AirfoilDatabase/examples/my_airfoil_generator.py">import airfoil_db as adb
import matplotlib.pyplot as plt
import numpy as np
import math as m
from mpl_toolkits.mplot3d import Axes3D

if __name__=="__main__":

    # Where the airfoil geometry is stored
    geometry_file = "examples/my_airfoil_geom.txt"

    # Declare input structure
    airfoil_input = {
        "type" : "database",
        "geometry" : {
            "outline_points" : geometry_file
        },
        "trailing_flap_type" : "parabolic"
    }

    # Initialize airfoil
    airfoil = adb.Airfoil("my_airfoil", airfoil_input, verbose=True)
    # Setting verbose to true will let us see how well the camber line/outline are detected and fit.
    # We recommend turning this on for new airfoils

    # Set up database degrees of freedom
    dofs = {
        "alpha" : {
            "range" : [m.radians(-5.0), m.radians(5.0)],
            "steps" : 11,
            "index" : 1
        },
        "Rey" : 2900000.0,
        "Mach" : {
            "range" : [0.0, 0.4],
            "steps" : 3,
            "index" : 3
        },
        "trailing_flap_deflection" : {
            "range" : [m.radians(-20.0), m.radians(20.0)],
            "steps" : 7,
            "index" : 0
        },
        "trailing_flap_fraction" : 0.25
    }

    # Generate database using xfoil
    airfoil.generate_database(degrees_of_freedom=dofs, max_iter=100, show_xfoil_output=False)
    airfoil.export_database(filename="my_airfoil_database.txt")

    # If you just want a data database, stop here.
    # If you'd like to create a set of polynomial fits to your database, this next set of code will do that

    # Declare the order of the fit for each degree of freedom for each coefficient
    CL_fit_orders = {
        "alpha" : 3,
        "trailing_flap" : 1,
        "Mach" : 2
    }

    CD_fit_orders = {
        "alpha" : 4,
        "trailing_flap" : 4,
        "Mach" : 2
    }

    Cm_fit_orders = {
        "alpha" : 1,
        "trailing_flap" : 1,
        "Mach" : 2
    }

    # Generate fits
    airfoil.generate_polynomial_fit(CL_degrees=CL_fit_orders, CD_degrees=CD_fit_orders, Cm_degrees=Cm_fit_orders)

    # Alternatively, you can have it automatically detect the order of fit that would be best for each
    #airfoil.generate_polynomial_fit(CL_degrees="auto", CD_degrees="auto", Cm_degrees="auto", max_order=6) 

    # Export fits
    airfoil.export_polynomial_fits(filename="my_airfoil_fits.json")

    # To use these database files in MachUpX, you'll want to declare the airfoil as follows
    #   "my_airfoil" : {
    #       "type" : "database",
    #       "input_file" : "my_airfoil_database.txt",
    #       "geometry" : {
    #           "outline_points" : "my_airfoil_geom.txt"
    #       }
    #   }
    # 
    # or
    #
    #   "my_airfoil" : {
    #       "type" : "poly_fit",
    #       "input_file" : "my_airfoil_fits.json",
    #       "geometry" : {
    #           "outline_points" : "my_airfoil_geom.txt"
    #       }
    #   }</"file: python/AirfoilDatabase/examples/my_airfoil_generator.py">

<"file: python/AirfoilDatabase/setup.py">"""AirfoilDatabase: A Python module for modeling airfoils using Xfoil."""

from setuptools import setup
import os

setup(name = 'airfoil_db',
    version = '1.4.3',
    description = "AirfoilDatabase: A Python module for modeling airfoils using Xfoil.",
    url = 'https://github.com/usuaero/AirfoilDatabase',
    author = 'usuaero',
    author_email = 'doug.hunsaker@usu.edu',
    install_requires = ['numpy', 'scipy', 'matplotlib'],
    python_requires ='>=3.6.0',
    license = 'MIT',
    packages = ['airfoil_db'],
    zip_safe = False)
</"file: python/AirfoilDatabase/setup.py">

<"file: python/AirfoilDatabase/build/lib/airfoil_db/__init__.py">from .airfoil import Airfoil
from .exceptions import DatabaseBoundsError, CamberSolverNotConvergedError</"file: python/AirfoilDatabase/build/lib/airfoil_db/__init__.py">

<"file: python/AirfoilDatabase/build/lib/airfoil_db/airfoil.py">"""A class defining an airfoil."""

import math
import json
import copy
import os
import operator
import warnings

import matplotlib.pyplot as plt
import scipy.interpolate as interp
import subprocess as sp
import numpy as np

from .poly_fits import multivariablePolynomialFit, multivariablePolynomialFunction, autoPolyFit, multivariableRMS, multivariableR2
from .exceptions import DatabaseBoundsError, CamberSolverNotConvergedError, PolyFitBoundsError


class Airfoil:
    """A class defining an airfoil. If the airfoil geometry is defined using outline
    points, then when this class is initialized, a solver will be automatically
    run to determine the camber line and thickness distribution of the airfoil.
    The parameters "camber_relaxation", "le_loc", and "camber_termination_tol" then
    have bearing on this solver.

    When using the member methods get_CL, get_CD, get_Cm, get_CLa, get_CLM, get_CLRe,
    and get_aL0, the default parameters are dependent upon the type of airfoil.

    For all airfoil types except 'functional', 'alpha', 'trailing_flap_deflection',
    and 'trailing_flap_fraction' default to 0.0.

    For 'functional' airfoils, the defaults are specified by the user.

    For 'linear' airfoils, 'Mach' and 'Rey' have no effect on computations.

    For 'database' airfoils, 'Mach' and 'Rey' default to the average value in the database,
    if the database is dependent on that variable. Otherwise, they default to the value
    specified as constant when the database was generated.

    For 'poly_fit' airfoils, 'Mach' and 'Rey' default to the values given in the fit file.
    If export_polynomial_fits() is used, these values are the same as those for the 
    'database' type.

    Parameters
    ----------
    name : str
        Name of the airfoil.

    airfoil_input : dict or str
        Dictionary or path to JSON object describing the airfoil.

    verbose : bool, optional
        Whether to display information on the progress of parameterizing the geometry
        for an airfoil defined by a set of outline points. Defaults to False.

    camber_relaxation : float, optional
        A value between 0.0 and 1.0 that defines how much of the update at each
        iteration of the camber line solver should be accepted. Helpful for some
        poorly behaved cases. Defaults to 1.0 (full update).
    
    le_loc : list, optional
        Gives the location of the leading edge relative to the given points for an airfoil
        defined by a set of outline points. If this is given, the camber line will be forced
        to intersect this point. THIS POINT SHOULD LIE ON THE AIRFOIL OUTLINE. If not given,
        the camber line solver will try to iteratively find the leading edge (the point where
        the camber line intersects the front of the profile).

    camber_termination_tol : float, optional
        The tolerance below which the maximum approximate error in the camber line estimate
        must fall in order for the camber line solver to terminate. Defaults to 1e-10.

    max_iterations : int, optional
        Maximum number of iterations for the camber line solver. Defaults to 100.
    """

    def __init__(self, name, airfoil_input, **kwargs):
        
        self.name = name
        self._load_params(airfoil_input)
        if "camber_solver_kwargs" in list(self._input_dict.keys()):
            kwarg_dict = self._input_dict["camber_solver_kwargs"]
            self._verbose = kwarg_dict.get("verbose", False)
            self._camber_relaxation = kwarg_dict.get("camber_relaxation", 1.0)
            self._le_loc = kwarg_dict.get("le_loc", None)
            self._camber_termination_tol = kwarg_dict.get("camber_termination_tol", 1e-10)
            self._max_iterations = kwarg_dict.get("max_iterations", 100)
        else:
            self._verbose = kwargs.get("verbose", False)
            self._camber_relaxation = kwargs.get("camber_relaxation", 1.0)
            self._le_loc = kwargs.get("le_loc", None)
            self._camber_termination_tol = kwargs.get("camber_termination_tol", 1e-10)
            self._max_iterations = kwargs.get("max_iterations", 100)

        # Load flaps
        self._load_flaps()

        # Store undeformed outlines
        self._initialize_geometry()

        # Specify database DOF parameters
        self._allowable_dofs = ["alpha", "Rey", "Mach", "trailing_flap_deflection", "trailing_flap_fraction"]
        self._dof_defaults = {
            "alpha" : 0.0,
            "Rey" : 1e6,
            "Mach" : 0.0,
            "trailing_flap_deflection" : 0.0,
            "trailing_flap_fraction" : 0.0
        }

        # Load input file
        input_file = self._input_dict.get("input_file", None)
        if input_file is not None:
            if self._type == "database":
                self.import_database(filename=input_file)
            elif self._type == "poly_fit":
                self.import_polynomial_fits(filename=input_file)


        self._raise_poly_bounds_error = True


    def set_err_state(self, **kwargs):
        """Sets the error state for the airfoil. Each may be specified as 'raise' or 'ignore'.

        Parameters
        ----------
        poly_fit_bounds : str, optional
            How to handle PolyFitBoundsError. Defaults to 'raise'.
        """

        # Polynomial fit bounds
        if kwargs.get("poly_fit_bounds", "raise") == "raise":
            self._raise_poly_bounds_error = True
        else:
            self._raise_poly_bounds_error = False


    def set_verbosity(self, verbosity):
        """Sets the verbosity of the airfoil."""
        self._verbose = verbosity


    def set_type(self, database_type):
        """Determines how the aerodynamic coefficients will be calculated.

        Parameters
        ----------
        database_type: str
            "linear", "functional", "database", or "poly_fit". Airfoil
            will automatically check if it has the necessary to perform
            the given type of computation and throw a warning if it does not.

        """

        # Check for proper type spec
        if database_type not in ["linear", "database", "poly_fit", "functional"]:
            raise IOError("{0} is not a valid type specification.".format(database_type))

        # Check for linear data
        if database_type == "linear":
            if not hasattr(self, "_CLa"):
                raise RuntimeWarning("Airfoil {0} does not have linear coefficients specified. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type

        # Check for database
        if database_type == "database":
            if not hasattr(self, "_data"):
                raise RuntimeWarning("Airfoil {0} does not have a database of coefficients. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type

            # Set up data normalization
            self._data_norms = np.zeros((1,self._num_dofs))
            for i in range(self._num_dofs):
                self._data_norms[0,i] = np.max(np.abs(self._data[:,i]))

            # Make sure we don't divide by zero
            self._data_norms[np.where(self._data_norms==0.0)] = 1.0

            # Normalize independent vars
            self._normed_ind_vars = self._data[:,:self._num_dofs]/self._data_norms

            # Determine default Mach and Reynolds number
            if "Rey" in list(self._dof_db_cols.keys()):
                i = self._dof_db_cols["Rey"]
                Re_min = np.min(self._data[:,i])
                Re_max = np.max(self._data[:,i])
                self._dof_defaults["Rey"] = 0.5*(Re_max+Re_min)

            if "Mach" in list(self._dof_db_cols.keys()):
                i = self._dof_db_cols["Mach"]
                M_min = np.min(self._data[:,i])
                M_max = np.max(self._data[:,i])
                self._dof_defaults["Mach"] = 0.5*(M_max+M_min)

        # Check for polynomial fits
        if database_type == "poly_fit":
            if not hasattr(self, "_CL_poly_coefs"):
                raise RuntimeWarning("Airfoil {0} does not have a set of polynomial fits. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type

        # Check for functional definition
        if database_type == "functional":
            if not hasattr(self, "_CL"):
                raise RuntimeWarning("Airfoil {0} does not have functional definitions of coefficients. Reverting to type '{1}' for computations.".format(self.name, self._type))
            else:
                self._type = database_type


    def _load_params(self, airfoil_input):

        # Load input dict
        if isinstance(airfoil_input, str):
            # Load JSON object
            with open(airfoil_input, 'r') as json_handle:
                self._input_dict = json.load(json_handle)
        elif isinstance(airfoil_input, dict):
            self._input_dict = airfoil_input
        else:
            raise IOError("{0} is not an allowed airfoil definition. Must be path or dictionary.".format(airfoil_input))

        # Store type
        self._type = self._input_dict.get("type", "linear")

        # If linear, store coefficients
        if self._type == "linear":
            self._aL0 = self._input_dict.get("aL0", 0.0)
            self._CLa = self._input_dict.get("CLa", 2*np.pi)
            self._Cma = self._input_dict.get("Cma", 0.0)
            self._CD0 = self._input_dict.get("CD0", 0.0)
            self._CD1 = self._input_dict.get("CD1", 0.0)
            self._CD2 = self._input_dict.get("CD2", 0.0)
            self._CL_max = self._input_dict.get("CL_max", np.inf)
            if abs(self._CL_max) < 1e-10:
                warnings.warn("You have specified a maximum lift coefficient of 0. Are you sure you want to do this?...")
            self._CmL0 = self._input_dict.get("CmL0", 0.0)

        # For functional, store functions
        elif self._type == "functional":
            self._CL = self._input_dict["CL"]
            self._CD = self._input_dict["CD"]
            self._Cm = self._input_dict["Cm"]


    def _load_flaps(self):
        # Loads flaps based on the input dict
        self._trailing_flap_type = self._input_dict.get("trailing_flap_type", None)
        self._trailing_flap_hinge_height = self._input_dict.get("trailing_flap_hinge_height", 0.0)


    def _initialize_geometry(self):
        # Initialize geometry based on whether points or a NACA designation were given

        # Check that there's only one geometry definition
        geom_dict = self._input_dict.get("geometry", {})
        outline_points = geom_dict.get("outline_points", None)
        NACA = geom_dict.get("NACA", None)
        if outline_points is not None and NACA is not None:
            raise IOError("Outline points and a NACA designation may not be both specified for airfoil {0}.".format(self.name))

        # Check for user-given points
        if outline_points is not None:
            self.geom_specification = "points"

            # Array given
            if isinstance(outline_points, np.ndarray):
                self._raw_outline = outline_points

            # 2D list given
            elif isinstance(outline_points, list):
                self._raw_outline = np.array(outline_points)
            
            # File
            else:

                # Import
                with open(outline_points, 'r') as input_handle:
                    self._raw_outline = np.genfromtxt(input_handle)

                # Check for comma-delimited
                if np.isnan(self._raw_outline).any():
                    with open(outline_points, 'r') as input_handle:
                        self._raw_outline = np.genfromtxt(input_handle, delimiter=',')

            # Get number of points
            self._N_orig = self._raw_outline.shape[0]

            # Rearrange the coordinates if necessary to be top first then bottom
            top_ind = np.argmax(self._raw_outline[:,1])
            bot_ind = np.argmin(self._raw_outline[:,1])
            if bot_ind < top_ind: # Bottom came first
                self._raw_outline = self._raw_outline[::-1]

            # Calculate camber line and thickness
            self._calc_geometry_from_points()

        # NACA definition
        elif NACA is not None:
            self.geom_specification = "NACA"
            self._naca_closed_te = geom_dict.get("NACA_closed_te", False)
            self._naca_des = NACA

            self._calc_geometry_from_NACA()

        # No geometry given
        else:
            self.geom_specification = "none"
            self._max_camber = geom_dict.get("max_camber", 0.0)
            self._max_thickness = geom_dict.get("max_thickness", 0.0)
            return

    
    def _calc_geometry_from_NACA(self):
        # Creates thickness, camber, camber derivative, and outline splines base on the NACA equations

        # 4-digit series
        if len(self._naca_des) == 4:

            # Stores the camber and thickness getters based on the NACA designation of the airfoil
            self._m = float(self._naca_des[0])/100
            self._p = float(self._naca_des[1])/10
            self._t = float(self._naca_des[2:])/100
            self._max_camber = self._m
            self._max_thickness = self._t

            # Camber line
            def camber(x):
                if self._p != 0.0:
                    return np.where(x<self._p, self._m/(self._p*self._p)*(2*self._p*x-x*x), self._m/((1-self._p)*(1-self._p))*(1-2*self._p+2*self._p*x-x*x))
                else:
                    return np.zeros_like(x)

            self._camber_line = camber

            # Camber line derivative
            def camber_deriv(x):
                if abs(self._m)<1e-10 or abs(self._p)<1e-10: # Symmetric
                    return np.zeros_like(x)
                else:
                    return np.where(x<self._p, 2*self._m/(self._p*self._p)*(self._p-x), 2*self._m/((1-self._p)*(1-self._p))*(self._p-x))

            self._camber_deriv = camber_deriv

            # Thickness
            def thickness(x):
                if self._naca_closed_te:
                    return 5.0*self._t*(0.2969*np.sqrt(x)-0.1260*x-0.3516*x*x+0.2843*x*x*x-0.1036*x*x*x*x)
                else:
                    return 5.0*self._t*(0.2969*np.sqrt(x)-0.1260*x-0.3516*x*x+0.2843*x*x*x-0.1015*x*x*x*x)

            self._thickness = thickness

        else:
            raise IOError("Only 4-digit NACA specifications may be given. {0} is not 4-digit.".format(self._naca_des))

        # Cosine distribution of chord locations
        theta = np.linspace(-np.pi, np.pi, 200)
        x = 0.5*(1-np.cos(theta))

        y_c = self._camber_line(x)
        dy_c_dx = self._camber_deriv(x)
        t = self._thickness(x)

        # Outline points
        X = x-t*np.sin(np.arctan(dy_c_dx))*np.sign(theta)
        Y = y_c+t*np.cos(np.arctan(dy_c_dx))*np.sign(theta)

        outline_points = np.concatenate([X[:,np.newaxis], Y[:,np.newaxis]], axis=1)

        # Create splines defining the outline
        self._x_outline, self._y_outline = self._create_splines_of_s(outline_points)
        _,_,self._s_le = self._get_intersection_point(0.0, 0.0, dy_c_dx[0], "leading_edge")


    def _create_splines_of_s(self, outline_points):
        # Creates x and y coordinate splines which are a function of the normalized distance along the outline

        # Calculate distances
        x_diff = np.diff(outline_points[:,0])
        y_diff = np.diff(outline_points[:,1])
        ds = np.sqrt(x_diff*x_diff+y_diff*y_diff)
        ds = np.insert(ds, 0, 0.0)

        # Create s distribution
        s = np.cumsum(ds)
        s_normed = s/s[-1]

        # Create splines
        x_outline = interp.UnivariateSpline(s_normed, outline_points[:,0], k=5, s=1e-10)
        y_outline = interp.UnivariateSpline(s_normed, outline_points[:,1], k=5, s=1e-10)

        return x_outline, y_outline


    def _calc_geometry_from_points(self):
        # Calculates the camber line and thickness distribution from the outline points.
        # Also scales the airfoil, places the leading edge at the origin, and rotates it so it is at zero angle of attack.
        if self._verbose:
            print("Calculating camber line...")
            print("{0:<20}{1:<20}".format("Iteration", "Max Approx Error"))
            print("".join(["-"]*40))

        # Camber line estimate parameters
        num_camber_points = self._N_orig//5 # As recommended by Cody Cummings to avoid discontinuities in dyc/dx
        camber_deriv_edge_order = 2

        # Create splines defining the outline
        self._x_outline, self._y_outline = self._create_splines_of_s(self._raw_outline)

        # Get distribution of x locations
        le_ind = np.argmin(np.abs(self._raw_outline[:,0]))
        te = (self._raw_outline[0]+self._raw_outline[-1])*0.5
        if self._le_loc is None:
            x_tip = np.min(self._raw_outline[:,0])
            x_c = np.linspace(x_tip+0.0001, te[0], num_camber_points)
        else:
            x_c = np.linspace(self._le_loc[0], te[0], num_camber_points)

        # Get initial estimate for the camber line
        y_t = np.interp(x_c, self._raw_outline[le_ind::-1,0], self._raw_outline[le_ind::-1,1])
        y_b = np.interp(x_c, self._raw_outline[le_ind:,0], self._raw_outline[le_ind:,1])
        y_c = 0.5*(y_t+y_b)
        if self._le_loc is not None:
            y_c[0] = self._le_loc[1]

        # A useful distribution
        x_space = np.linspace(0.0, 1.0, 1000)

        # Show
        if self._verbose:
            plt.figure()
            plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Outline Data')
            plt.plot(self._x_outline(x_space), self._y_outline(x_space), 'k--', label='Outline Spline')
            plt.plot(x_c, y_c, 'r--', label='Initial Camber Line Estimate')
            plt.plot(x_c, np.gradient(y_c, x_c, edge_order=camber_deriv_edge_order), 'g--', label='Camber Line Derivative')
            plt.legend()
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()

        # Initialize
        x_t = np.zeros(num_camber_points)
        x_b = np.zeros(num_camber_points)
        x_c_new = np.zeros(num_camber_points)
        y_c_new = np.zeros(num_camber_points)

        # Check for symmetric airfoil
        if np.allclose(y_c, 0.0):
            camber_error = 0.0
        else:
            camber_error = 1.0

        # Iterate until convergence
        iteration = 0
        while camber_error > self._camber_termination_tol:
            iteration += 1

            # Determine camber line slope
            dyc_dx = np.gradient(y_c, x_c, edge_order=camber_deriv_edge_order)
            
            # Determine slope of lines perpendicular to the camber
            with np.errstate(divide="ignore"):
                b = -1.0/dyc_dx

            # Loop through points on the camber line to find where their normal intersects the outline
            for i in range(num_camber_points):
                if self._le_loc is not None and i == 0:
                    continue

                # Get point information
                xc = x_c[i]
                yc = y_c[i]
                bi = b[i]

                # Estimate the intersection points
                x_t[i], y_t[i], _ = self._get_intersection_point(xc, yc, bi, "top")
                x_b[i], y_b[i], _ = self._get_intersection_point(xc, yc, bi, "bottom")

            # Calculate new camber line points
            x_c_new = 0.5*(x_t+x_b)
            y_c_new = 0.5*(y_t+y_b)
            if self._le_loc is not None:
                x_c_new[0] = self._le_loc[0]
                y_c_new[0] = self._le_loc[1]

            # Plot new and old estimate
            if False:
                plt.figure()
                plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Outline Data')
                plt.plot(x_c, y_c, 'r--', label='Old Camber Line Estimate')
                plt.plot(x_c_new, y_c_new, 'g--', label='New Camber Line Estimate')
                plt.plot(x_t, y_t, 'rx')
                plt.plot(x_b, y_b, 'ro')
                plt.legend()
                plt.gca().set_aspect('equal', adjustable='box')
                plt.show()

            # Approximate error
            x_diff = x_c_new-x_c
            y_diff = y_c_new-y_c
            camber_error = np.max(np.sqrt(x_diff*x_diff+y_diff*y_diff))
            if self._verbose:
                print("{0:<20}{1:<20}".format(iteration, camber_error))

            # Sort, just in case things got messed up
            sorted_ind = np.argsort(x_c_new)
            x_c_new = x_c_new[sorted_ind]
            y_c_new = y_c_new[sorted_ind]

            # Update for next iteration
            x_c = self._camber_relaxation*x_c_new+(1.0-self._camber_relaxation)*x_c
            y_c = self._camber_relaxation*y_c_new+(1.0-self._camber_relaxation)*y_c

            # Check iteration limit
            if iteration == self._max_iterations:
                raise CamberSolverNotConvergedError(self.name, camber_error)

        if self._verbose: print("Camber line solver converged.")

        # Calculate where the camber line intersects the outline to find the leading edge
        if self._le_loc is None:
            dyc_dx = np.gradient(y_c, x_c, edge_order=2)
            b = dyc_dx[0]
            x_le, y_le, self._s_le = self._get_intersection_point(x_c[0], y_c[0], b, "leading_edge")
            le = np.array([x_le, y_le])
            x_c = np.insert(x_c, 0, le[0])
            y_c = np.insert(y_c, 0, le[1])
        else:
            le = self._le_loc

        if self._verbose: print("Leading edge: {0}".format(le))

        if self._verbose:
            # Plot
            plt.figure()
            plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Outline Data')
            plt.plot(x_c, y_c, 'g--', label='Final Camber Line Estimate')
            plt.legend()
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()

        # Get trailing edge
        te = (self._raw_outline[0]+self._raw_outline[-1])*0.5
        if self._verbose: print("Trailing edge: {0}".format(te))

        # Renormalize using new leading and trailing edge
        self._normalize_points(self._raw_outline, le, te)
        self._x_outline, self._y_outline = self._create_splines_of_s(self._raw_outline)

        # Normalize camber line points
        camber_points = np.concatenate([x_c[:,np.newaxis], y_c[:,np.newaxis]], axis=1)
        self._normalize_points(camber_points, le, te)

        # Store camber and max camber
        self._camber_line = interp.UnivariateSpline(camber_points[:,0], camber_points[:,1], k=5, s=1e-10)
        self._max_camber = np.max(camber_points[:,1])

        # Store camber line derivative
        y_c = self._camber_line(x_space)
        dyc_dx= np.gradient(y_c, x_space)
        self._camber_deriv = interp.UnivariateSpline(x_space, dyc_dx, k=5, s=1e-10)
        with np.errstate(divide="ignore"):
            b = -1.0/dyc_dx

        # Find points on the surface to determine the thickness
        if self._verbose: print("Calculating thickness distribution...", end="")
        x_t_t = np.zeros_like(x_space)
        x_b_t = np.zeros_like(x_space)
        y_t_t = np.zeros_like(x_space)
        y_b_t = np.zeros_like(x_space)
        for i, xc in enumerate(x_space):
            if i == 0: continue # This point intersects the outline by definition and so will have zero thickness
            yc = y_c[i]
            bi = b[i]

            x_t_t[i], y_t_t[i],_ = self._get_intersection_point(xc, yc, bi, "top")
            x_b_t[i], y_b_t[i],_ = self._get_intersection_point(xc, yc, bi, "bottom")

        # Store thickness distribution
        t = 0.5*np.sqrt((x_t_t-x_b_t)*(x_t_t-x_b_t)+(y_t_t-y_b_t)*(y_t_t-y_b_t))
        self._thickness = interp.UnivariateSpline(x_space, t, k=5, s=1e-10)
        self._max_thickness = np.max(t)
        if self._verbose: print("Done")

        # Calculate estimated top and bottom points
        y_c_pred = self._camber_line(x_space)
        dyc_dx = np.gradient(y_c_pred, x_space)
        t_pred = self._thickness(x_space)
        theta = np.arctan(dyc_dx)
        S_theta = np.sin(theta)
        C_theta = np.cos(theta)

        x_b = x_space+t_pred*S_theta
        y_b = y_c_pred-t_pred*C_theta
        x_t = x_space-t_pred*S_theta
        y_t = y_c_pred+t_pred*C_theta
        
        # Plot
        if self._verbose:
            plt.plot(self._raw_outline[:,0], self._raw_outline[:,1], 'b-', label='Original Data')
            plt.plot(x_t, y_t, 'r--', label='Top Fit')
            plt.plot(x_b, y_b, 'r--', label='Bottom Fit')
            plt.legend()
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()


    def _normalize_points(self, points, le_coords, te_coords):
        # Takes the given points, translates them to the origin, rotates them to be at zero angle of attack, and scales so the chord length is unity

        # Translate
        points[:,0] -= le_coords[0]
        points[:,1] -= le_coords[1]

        # Rotate
        x_diff = te_coords[0]-le_coords[0]
        y_diff = te_coords[1]-le_coords[1]
        theta = -np.arctan2(y_diff, x_diff)
        R = np.array([[np.cos(theta), -np.sin(theta)],
                      [np.sin(theta),  np.cos(theta)]])
        points = np.matmul(R, points.T)

        #Scale
        c_unscaled = np.sqrt(x_diff*x_diff+y_diff*y_diff)
        points = points/c_unscaled


    def _get_intersection_point(self, xc, yc, b, surface, plot=False):
        # Calculates the point on the surface where the line extending from (xc, yc) with slope of b intersects
        # Uses the secant method to converge in s

        # Start s in the middle of the respective surface
        if surface == "top":
            s0 = 0.24
            s1 = 0.26
        elif surface == "bottom":
            s0 = 0.74
            s1 = 0.76
        elif surface == "leading_edge":
            s0 = 0.49
            s1 = 0.51

        # Initial points on outline
        x0 = self._x_outline(s0)
        y0 = self._y_outline(s0)
        x1 = self._x_outline(s1)
        y1 = self._y_outline(s1)

        # Initial distances
        d0 = self._distance(x0, y0, xc, yc, b)
        d1 = self._distance(x1, y1, xc, yc, b)

        # Secant method
        while abs(d1) > 1e-10:
            
            # Get new estimate in s
            if d1 > 0.2 or (s1 > 0.35 and s1 < 0.65): # Apply some relaxation when we're far away or near the leading edge (to keep from shooting to the other surface)
                s2 = s1-0.2*d1*(s0-s1)/(d0-d1)
            else:
                s2 = s1-d1*(s0-s1)/(d0-d1)

            # Make sure we're in bounds
            if s2 > 1.1:
                s2 = 1-0.01*s2
            if s2 < -0.1:
                s2 = -0.01*s2

            # Get new point
            x2 = self._x_outline(s2)
            y2 = self._y_outline(s2)

            # Get new distance
            d2 = self._distance(x2, y2, xc, yc, b)

            # Plot
            if plot:
                plt.figure()
                s_space = np.linspace(0.0, 1.0, 10000)
                plt.plot(self._x_outline(s_space), self._y_outline(s_space), 'b')
                plt.plot(xc, yc, 'or')
                plt.plot(x0, y0, 'bx')
                plt.plot(x1, y1, 'gx')
                plt.plot(x2, y2, 'rx')
                plt.gca().set_aspect('equal', adjustable='box')
                plt.show()

            # Update for next iteration
            s0 = s1
            d0 = d1
            x0 = x1
            y0 = y1

            s1 = s2
            d1 = d2
            x1 = x2
            y1 = y2

        return x1, y1, s1


    def _distance(self, x0, y0, x, y, b):
        if not np.isnan(b) and not np.isinf(b):
            return (-b*x0+y0+b*x-y)/np.sqrt(b*b+1)
        else:
            return abs(x0-x)


    def check_against_NACA(self, naca_des):
        """Checks the error in the camber and thickness against that predicted by the NACA equations. This is recommended as a check for the user
        if unusual geometries are being imported. Checks against the open trailing edge formulation of the NACA equations.

        Parameters
        ----------
        naca_des : str
            NACA designation of the airfoil to compare against as a string. May only be 4-digit series.
        """

        print("Checking estimated thickness and camber against NACA equations for NACA {0}...".format(naca_des))

        # 4-digit series
        if len(naca_des) == 4:

            # Generate true coordinates
            x_space = np.linspace(0.0, 1.0, 10000)
            m = float(naca_des[0])/100
            p = float(naca_des[1])/10
            if p != 0.0:
                y_c_true = np.where(x_space<p, m/p**2*(2*p*x_space-x_space**2), m/(1-p)**2*(1-2*p+2*p*x_space-x_space**2))
            else:
                y_c_true = np.zeros_like(x_space)

            # True thickness
            t = float(naca_des[2:])/100
            t_true = 5*t*(0.2969*np.sqrt(x_space)-0.1260*x_space-0.3516*x_space**2+0.2843*x_space**3-0.1015*x_space**4)

        else:
            raise IOError("Can only compare to NACA 4-digit series. Cannot be {0}.".format(naca_des))

        # Estimate camber
        y_c_est = self._camber_line(x_space)

        # Plot camber
        plt.figure()
        plt.plot(x_space, y_c_true, 'g--', label='True Camber')
        plt.plot(x_space, y_c_est, 'r--', label='Estimated Camber')
        plt.legend()
        plt.gca().set_aspect('equal', adjustable='box')
        plt.show()

        # Estimate thickness
        t_est = self._thickness(x_space)

        # Plot thickness
        plt.figure()
        plt.plot(x_space, t_true, 'g--', label='True Thickness')
        plt.plot(x_space, t_est, 'r--', label='Estimated Thickness')
        plt.legend()
        plt.gca().set_aspect('equal', adjustable='box')
        plt.show()

        with np.errstate(divide='ignore', invalid='ignore'):
            # Camber error
            camber_error = np.abs((y_c_est-y_c_true)/y_c_true)
            max_camber_error = np.max(np.where(np.isfinite(camber_error), camber_error, 0.0))
            print("Max camber error: {0:.5f}%".format(max_camber_error*100))

            # Thickness error
            thickness_error = np.abs((t_est-t_true)/t_true)
            max_thickness_error = np.max(np.where(np.isfinite(thickness_error), thickness_error, 0.0))
            print("Max thickness error: {0:.5f}%".format(max_thickness_error*100))


    def _get_flap_influence(self, c_f, d_f):
        # Returns the influence of the flap on the effective angle of attack
        # From Phillips *Mechanics of Flight* Ch. 1, Sec. 7
        theta_f = np.arccos(2.0*c_f-1.0)
        eps_flap_ideal = 1.0-(theta_f-np.sin(theta_f))/np.pi
        hinge_eff = 3.9598*np.arctan((c_f+0.006527)*89.2574+4.898015)-5.18786
        flap_eff = np.where(np.abs(d_f)>0.19198621771937624, -0.4995016675499485*np.abs(d_f)+1.09589743589744, 1.0)
        return hinge_eff*flap_eff*eps_flap_ideal*d_f


    def _get_database_data(self, data_index, **kwargs):
        # Returns an interpolated data point from the database.
        # data_index: 0 = CL, 1 = CD, 2 = Cm

        # Determine size of query
        max_size = 1
        for dof in self._dof_db_order:
            param = kwargs.get(dof, self._dof_defaults[dof])
            if isinstance(param, np.ndarray):
                max_size = max(max_size, param.shape[0])

        # Get params
        param_vals = np.zeros((max_size,self._num_dofs))
        for i, dof in enumerate(self._dof_db_order):
            param_vals[:,i] = kwargs.get(dof, self._dof_defaults[dof])

        # Interpolate
        return_val = interp.griddata(self._normed_ind_vars, self._data[:,self._num_dofs+data_index].flatten(), param_vals/self._data_norms, method='linear').flatten()
        #return_val = interp.griddata(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+data_index].flatten(), param_vals, method='linear').flatten()

        # Check for going out of bounds
        if np.isnan(return_val).any():
            raise DatabaseBoundsError(self.name, np.argwhere(np.isnan(return_val)).flatten(), kwargs)

        # Return
        if max_size == 1:
            return return_val.item()
        else:
            return return_val


    def get_CL(self, **kwargs):
        """Returns the coefficient of lift. Note: all parameters can be given as numpy arrays, in which case a numpy array of the coefficient will be returned.
        To do this, all parameter arrays must have only one dimension and must have the same length.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float or ndarray
            Lift coefficient
        """
        
        # Linearized model
        if self._type == "linear":

            # Get params
            alpha = kwargs.get("alpha", 0.0)
            d_f = kwargs.get("trailing_flap_deflection", 0.0)
            c_f = kwargs.get("trailing_flap_fraction", 0.0)

            # Calculate lift coefficient
            if np.array(d_f == 0.0).all() or np.array(c_f == 0.0).all():
                CL = self._CLa*(alpha-self._aL0)
            else:
                delta_a_d_f = self._get_flap_influence(c_f, d_f)
                CL = self._CLa*(alpha-self._aL0+delta_a_d_f)
            
            # Saturate
            with np.errstate(invalid='ignore'):
                if isinstance(CL, np.ndarray):
                    CL = np.where((CL > self._CL_max) | (CL < -self._CL_max), np.sign(CL)*self._CL_max, CL)
                elif CL > self._CL_max or CL < -self._CL_max:
                    CL = np.sign(CL)*self._CL_max

        # Functional model
        elif self._type == "functional":
            CL = self._CL(**kwargs)

        # Generated/imported database
        elif self._type == "database":
            CL = self._get_database_data(0, **kwargs)

        # Fits
        elif self._type == "poly_fit":
            CL = self._get_polynomial_data(0, **kwargs)

        return CL


    def get_CD(self, **kwargs):
        """Returns the coefficient of drag. note: all parameters can be given as numpy arrays, in which case a numpy array of the coefficient will be returned.
        to do this, all parameter arrays must have only one dimension and must have the same length.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float or ndarray
            Drag coefficient
        """

        # Linear type
        if self._type == "linear":
            d_f = kwargs.pop("trailing_flap_deflection", 0.0)
            CL = self.get_CL(**kwargs)
            CD_flap = 0.002*np.abs(np.degrees(d_f)) # A *very* rough estimate for flaps
            CD = self._CD0+self._CD1*CL+self._CD2*CL**2+CD_flap

        # Functional model
        elif self._type == "functional":
            CD = self._CD(**kwargs)

        # Generated/imported database
        elif self._type == "database":
            CD = self._get_database_data(1, **kwargs)

        # Fits
        elif self._type == "poly_fit":
            CD = self._get_polynomial_data(1, **kwargs)

        return CD


    def get_Cm(self, **kwargs):
        """Returns the moment coefficient. note: all parameters can be given as numpy arrays, in which case a numpy array of the coefficient will be returned.
        to do this, all parameter arrays must have only one dimension and must have the same length.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_moment_deriv : float or ndarray, optional
            Change in section moment with respect to trailing flap deflection. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float or ndarray
            Moment coefficient
        """

        # Linear type
        if self._type == "linear":

            # Get parameters
            alpha = kwargs.get("alpha", 0.0)
            d_f = kwargs.get("trailing_flap_deflection", 0.0)
            c_f = kwargs.get("trailing_flap_fraction", 0.0)

            # No control deflection
            if np.array(d_f == 0.0).all() or np.array(c_f == 0.0).all():
                Cm = self._CmL0+self._Cma*(alpha-self._aL0)
            else:
                theta_f = np.arccos(2.0*c_f-1.0)
                Cm_df = 0.25*(np.sin(2.0*theta_f)-2.0*np.sin(theta_f))
                Cm = self._CmL0+self._Cma*(alpha-self._aL0)+Cm_df*d_f

        # Functional model
        elif self._type == "functional":
            Cm = self._Cm(**kwargs)

        # Generated/imported database
        elif self._type == "database":
            Cm = self._get_database_data(2, **kwargs)

        # Fits
        elif self._type == "poly_fit":
            Cm = self._get_polynomial_data(2, **kwargs)

        return Cm


    def get_aL0(self, **kwargs):
        """Returns the zero-lift angle of attack, taking flap deflection into account.

        Parameters
        ----------
        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        Returns
        -------
        float
            Zero-lift angle of attack
        """

        # Linear airfoil model
        if self._type == "linear":

            # Get params
            d_f = kwargs.get("trailing_flap_deflection", 0.0)
            c_f = kwargs.get("trailing_flap_fraction", 0.0)

            # Calculate lift coefficient
            if np.array(d_f == 0.0).all() or np.array(c_f == 0.0).all():
                aL0 = self._aL0
            else:
                delta_a_d_f = self._get_flap_influence(c_f, d_f)
                aL0 = self._aL0-delta_a_d_f
            
            return aL0

        # Database/poly fit/functional
        # Use secant method in alpha to find a_L0
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Remove alpha from kwargs
            kwargs.pop('alpha', None)

            # Initialize secant method
            a0 = 0.0
            CL0 = self.get_CL(alpha=a0, **kwargs)
            a0 = np.zeros_like(CL0)
            a1 = np.zeros_like(CL0)+0.01
            CL1 = self.get_CL(alpha=a1, **kwargs)
            a2 = np.zeros_like(CL1)

            # If we're outside the domain of the database, aL0 should be nan
            if a2.size == 1:
                if np.isnan(CL1):
                    a2 = np.nan
            else:
                a2[np.where(np.isnan(CL1))] = np.nan
            
            # Iterate
            np.seterr(invalid='ignore')
            not_converged = np.where(np.array(np.abs(CL1)>1e-10))[0]
            while not_converged.size>0:
                
                # Update estimate
                if a2.size == 1:
                    a2 = (a1-CL1*(a0-a1)/(CL0-CL1))
                else:
                    a2[not_converged] = (a1-CL1*(a0-a1)/(CL0-CL1))[not_converged]
                CL2 = self.get_CL(alpha=a2, **kwargs)

                # Update for next iteration
                a0 = np.copy(a1)
                CL0 = np.copy(CL1)
                a1 = np.copy(a2)
                CL1 = np.copy(CL2)

                # Check convergence
                not_converged = np.where(np.array(np.abs(CL1)>1e-10))[0]

            np.seterr()
            return a2


    def get_CLM(self, **kwargs):
        """Returns the lift slope with respect to Mach number using a forward-difference approximation.
        Simply returns 0 for a type 'linear' airfoil.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        dx : float
            Step size for finite-difference equation. Defaults to 0.05.

        Returns
        -------
        float or ndarray
            Lift slope with respect to Mach number
        """

        # Linear model
        if self._type == "linear":
            return 0.0

        # Database
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Check the database is dependent on Mach
            if (self._type == "database" or self._type == "poly_fit") and "Mach" not in self._dof_db_order:
                return 0.0

            # Get center Mach value
            dx = kwargs.get("dx", 0.05)
            Mach = kwargs.pop("Mach", 0.0)
            
            # Calculate forward and center points (since we'll often be at M=0 and negative M doesn't work)
            CL1 = self.get_CL(Mach=Mach+dx, **kwargs)
            CL0 = self.get_CL(Mach=Mach, **kwargs)

            return (CL1-CL0)/dx


    def get_CLRe(self, **kwargs):
        """Returns the lift slope with respect to Reynolds number using a central-difference approximation.
        Simply returns 0 for a type 'linear' airfoil.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        dx : float
            Step size for finite-difference equation. Defaults to 1000.

        Returns
        -------
        float or ndarray
            Lift slope with respect to Reynolds number
        """

        # Linear model
        if self._type == "linear":
            return 0.0

        # Database
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Check the database is dependent on Re
            if (self._type == "database" or self._type == "poly_fit") and "Rey" not in self._dof_db_order:
                return 0.0

            # Get center Re value
            dx = kwargs.get("dx", 1000)
            Rey = kwargs.pop("Rey", 1000000)
            
            # Calculate forward and backward points
            CL1 = self.get_CL(Rey=Rey+dx, **kwargs)
            CL0 = self.get_CL(Rey=Rey-dx, **kwargs)

            return (CL1-CL0)/(2*dx)


    def get_CLa(self, **kwargs):
        """Returns the lift slope using a central-difference approximation.

        Parameters
        ----------
        alpha : float, optional
            Angle of attack in radians. Defaults to 0.0.

        Rey : float, optional
            Reynolds number.

        Mach : float, optional
            Mach number.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians. Defaults to 0.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord length. Defaults to 0.

        dx : float, optional
            Step size for finite-difference equation. Defaults to 0.001 radians.

        Returns
        -------
        float or ndarray
            Lift slope
        """

        # Linear model
        if self._type == "linear":
            return self._CLa

        # Database
        elif self._type == "database" or self._type == "poly_fit" or self._type == "functional":

            # Check the database is dependent on alpha
            if (self._type == "database" or self._type == "poly_fit") and "alpha" not in self._dof_db_order:
                return 0.0

            # Get center alpha value
            dx = kwargs.get("dx", 0.001)
            alpha = kwargs.pop("alpha", 0.0)
            
            # Calculate forward and backward points
            CL1 = self.get_CL(alpha=alpha+dx, **kwargs)
            CL0 = self.get_CL(alpha=alpha-dx, **kwargs)

            return (CL1-CL0)/(2*dx)


    def get_thickness(self, x):
        """Returns the thickness normal to the camber line at the specified x location(s).

        Parameters
        ----------
        x : float or ndarray
            x location(s) at which to get the thickness.

        Returns
        -------
        float or ndarray
            Thickness as a percentage of the chord.
        """
        if isinstance(x, float):
            return self._thickness(x).item()
        else:
            return self._thickness(x)


    def get_max_thickness(self):
        """Returns the maximum thickness of the airfoil, divided by the chord length.
        """
        return self._max_thickness


    def get_camber(self, x):
        """Returns the y coordinate(s) of the camber line at the specified x location(s).

        Parameters
        ----------
        x : float or ndarray
            x location(s) at which to get the thickness.

        Returns
        -------
        float or ndarray
            Camber line y coordinate(s) as a percentage of the chord.
        """
        if isinstance(x, float):
            return self._camber_line(x).item()
        else:
            return self._camber_line(x)


    def get_max_camber(self):
        """Returns the maximum camber of the airfoil, divided by the chord length.
        """
        return self._max_camber


    def get_outline_points(self, **kwargs):
        """Returns an array of outline points showing the geometry of the airfoil.

        Parameters
        ----------
        N : int, optional
            The number of outline points to return. This function will not always return exactly this many
            but never more. Defaults to 200.

        cluster : bool, optional
            Whether to cluster points about the leading and trailing edges. Defaults to True.

        trailing_flap_deflection : float, optional
            Trailing flap deflection in radians (positive down). Defaults to zero.

        trailing_flap_fraction : float, optional
            Trailing flap fraction of the chord. Defaults to zero.

        export : str, optional
            If specified, the outline points will be saved to a file. Defaults to no file.

        top_first : bool, optional
            The order of the coordinates when exported. Defaults to going from the trailing edge along the top and
            the around to the bottom.

        close_te : bool, optional
            Whether the top and bottom trailing edge points should be forced to be equal. Defaults to False

        plot : bool, optional
            Whether a plot of the outline points should be displayed once computed. Defaults to False.

        original_points : bool, optional
            Whether this should simply return the original inputted points. If set to True, all other kwargs relating
            to the geometry will be ignored. Defaults to False.

        Returns
        -------
        ndarray
            Outline points in airfoil coordinates.
        """

        # Check the geometry has been defined
        if self.geom_specification != "none":

            # Get kwargs
            N = kwargs.get("N", 200)
            cluster = kwargs.get("cluster", True)
            trailing_flap_deflection = kwargs.get("trailing_flap_deflection", 0.0)
            trailing_flap_fraction = kwargs.get("trailing_flap_fraction", 0.0)
            close_te = kwargs.get("close_te", False)

            if not kwargs.get("original_points", False):
            
                # Zach's method of determining NACA airfoils with deflected parabolic flaps (actually works really well for all of them...)

                # Get flap parameters
                d_f = trailing_flap_deflection
                x_f = 1.0-trailing_flap_fraction
                y_f = self._input_dict.get("trailing_flap_hinge_height", self._camber_line(x_f))
            
                # Calculate distributions
                theta_c = np.linspace(np.pi, -np.pi, N) # Loop over entire airfoil from TE->top->LE->bottom->TE
                if cluster:
                    x_c = 0.5*(1.0-np.cos(theta_c))
                else:
                    x_c = abs(np.linspace(-1.0, 1.0, N))
            
                # Calculate undeformed camber line and thickness
                y_c = self._camber_line(x_c)
                t = self._thickness(x_c)
                dyc_dx = self._camber_deriv(x_c)
            
                if d_f != 0.0 and x_f < 1.0:
                    # Determine which camber points belong to the flap
                    flap_ind = np.where(x_c>x_f)

                    # Linear flap
                    if self._trailing_flap_type == "linear":

                        # Calculate deflected camber line Eqs. (8-10) in "Geometry and Aerodynamic Performance of Parabolic..." by Hunsaker, et al. 2018
                        r = np.sqrt((y_c-y_f)*(y_c-y_f)+(x_c-x_f)*(x_c-x_f))
                        psi = np.arctan((y_c-y_f)/(x_c-x_f))
                        x_c[flap_ind] = x_f+(r*np.cos(d_f-psi))[flap_ind]
                        y_c[flap_ind] = y_f-(r*np.sin(d_f-psi))[flap_ind]
                        dyc_dx[flap_ind] = np.gradient(y_c[flap_ind], x_c[flap_ind], edge_order=2)

                    else:
                        # Parabolic flap from "Geometry and Aerodynamic Performance of Parabolic..." by Hunsaker, et al. 2018

                        # Calculate the neutral line parameters
                        l_n = np.sqrt(y_f*y_f+(1-x_f)*(1-x_f))
                        phi_n = -np.arctan2(y_f, 1-x_f)

                        # Calculate the location of the deflected trailing edge
                        tan_df = np.tan(d_f)
                        R = np.sqrt(4*tan_df*tan_df+1)+np.arcsinh(2*tan_df)/(2*tan_df)
                        E_te = 2.0*l_n/R

                        # Find E_p using secant method

                        # Constants
                        R_tan_df = R*tan_df
                        R_tan_df2 = R_tan_df*R_tan_df
                        E_0 = ((x_c-x_f)/(1-x_f)*l_n)[flap_ind]

                        # Initial guesses
                        E_p0 = E_te*E_0/l_n
                        R0 = E_p0/2*np.sqrt(E_p0**2/l_n**2*R_tan_df2+1)+l_n/(2*R_tan_df)*np.arcsinh(E_p0/l_n*R_tan_df)-E_0
                        E_p1 = E_te*E_0/l_n+0.001
                        R1 = E_p1/2*np.sqrt(E_p1**2/l_n**2*R_tan_df2+1)+l_n/(2*R_tan_df)*np.arcsinh(E_p1/l_n*R_tan_df)-E_0

                        # Suppress warnings because an error will often occur within the np.where that has no effect on computation
                        with np.errstate(invalid='ignore'):
                        
                            # Iterate
                            while (abs(R1)>1e-10).any():

                                # Update value
                                E_p2 = np.where(np.abs(R0-R1) != 0.0, E_p1-R1*(E_p0-E_p1)/(R0-R1), E_p1)

                                # Get residual
                                R2 = E_p2/2*np.sqrt(E_p2**2/l_n**2*R_tan_df2+1)+l_n/(2*R_tan_df)*np.arcsinh(E_p2/l_n*R_tan_df)-E_0

                                # Update for next iteration
                                E_p0 = E_p1
                                R0 = R1
                                E_p1 = E_p2
                                R1 = R2

                        # Store final result
                        E_p = E_p1
                        n_p = -E_p*E_p/E_te*tan_df

                        # Calculate deflected neutral line
                        x_p = x_f+E_p*np.cos(phi_n)-n_p*np.sin(phi_n)
                        y_p = y_f+E_p*np.sin(phi_n)+n_p*np.cos(phi_n)
                        y_nl = y_f*(1-(x_c-x_f)/(1.0-x_f))
                        dy_c = (y_c-y_nl)[flap_ind]

                        # Calculate deflected camber line
                        C = np.arctan(2*E_p/E_te*tan_df)
                        x_c[flap_ind] = x_p+dy_c*np.sin(C)
                        y_c[flap_ind] = y_p+dy_c*np.cos(C)

                        dyc_dx[flap_ind] = (dyc_dx[flap_ind] - 2*E_p*tan_df/E_te) / (1 + 2*E_p*tan_df/E_te*dyc_dx[flap_ind])

                # Outline points
                X = x_c-t*np.sin(np.arctan(dyc_dx))*np.sign(theta_c)
                Y = y_c+t*np.cos(np.arctan(dyc_dx))*np.sign(theta_c)

                # Trim overlapping points from linear flap deflection
                if self._trailing_flap_type == "linear" and d_f != 0.0 and x_f < 1.0:

                    # Get indices of top and bottom points
                    top_ind = theta_c > 0.0
                    bot_ind = theta_c <= 0.0

                    # Split points into top and bottom
                    X_t = X[top_ind]
                    Y_t = Y[top_ind]
                    X_b = X[bot_ind]
                    Y_b = Y[bot_ind]

                    # Find the point on the surface where the hinge breaks
                    # These equations determine the slope of the line bisecting the angle between the camber line before the flap
                    # and the camber line of the flap
                    psi_prime = np.pi+np.arctan(self._camber_deriv(x_f)) # Angle to the camber line before the flap
                    d_f_prime = -d_f+np.arctan(self._camber_deriv(x_f)) # Angle to the camber line after the flap
                    phi = 0.5*(psi_prime+d_f_prime)
                    b = np.tan(phi)
                    x_t_break, y_t_break, _ = self._get_intersection_point(x_f, y_f, b, "top")
                    x_b_break, y_b_break, _ = self._get_intersection_point(x_f, y_f, b, "bottom")

                    # Trim overlapping points off of both surfaces
                    X_b, Y_b, num_trimmed_from_bot = self._trim_surface(X_b, Y_b, "forward")
                    X_t, Y_t, num_trimmed_from_top = self._trim_surface(X_t, Y_t, "backward")

                    # Check if we need to fill anything in so the number of outline points remains the same
                    if num_trimmed_from_bot>0:
                        r_t = self._get_cart_dist(x_t_break, y_t_break, x_f, y_f)
                        X_t, Y_t = self._fill_surface(X_t, Y_t, x_f, y_f, r_t, x_t_break, num_trimmed_from_bot, "backward")

                    if num_trimmed_from_top>0:
                        r_b = self._get_cart_dist(x_b_break, y_b_break, x_f, y_f)
                        X_b, Y_b = self._fill_surface(X_b, Y_b, x_f, y_f, r_b, x_b_break, num_trimmed_from_top, "forward")

                    # Concatenate top and bottom points
                    X = np.concatenate([X_t, X_b])
                    Y = np.concatenate([Y_t, Y_b])

                # Make sure the trailing edge is sealed
                if close_te:
                    x_te = 0.5*(X[0]+X[-1])
                    y_te = 0.5*(Y[0]+Y[-1])
                    X[0] = x_te
                    Y[0] = y_te
                    X[-1] = x_te
                    Y[-1] = y_te

            # Just use the original points
            else:
                X = self._raw_outline[:,0]
                Y = self._raw_outline[:,1]

            # Plot result
            if kwargs.get("plot", False):
                plt.figure()
                plt.plot(X, Y)
                #plt.plot(x_t_break, y_t_break, 'rx')
                #plt.plot(x_b_break, y_b_break, 'rx')
                #plt.plot(x_f, y_f, 'rx')
                plt.plot(x_c, y_c, 'r--')
                plt.xlabel('x')
                plt.ylabel('y')
                plt.title(self.name)
                plt.gca().set_aspect('equal', adjustable='box')
                plt.show()

            # Concatenate x and y
            outline_points = np.concatenate([X[:,np.newaxis], Y[:,np.newaxis]], axis=1)
            if not kwargs.get("top_first", True):
                outline_points = outline_points[::-1,:]
                    
            # Save to file
            export = kwargs.get("export", None)
            if export is not None:
                np.savetxt(export, outline_points, fmt='%10.8f')

            return outline_points

        else:
            raise RuntimeError("The geometry has not been defined for airfoil {0}. Outline points cannot be generated.".format(self.name))


    def _trim_surface(self, X, Y, direction):
        # Trims any points within a region of doubling back in x

        # Loop through points
        trim_indices = []
        rev = False
        fwd = False

        # Determine direction
        indices = range(X.shape[0])
        if direction == "backward":
            indices = indices[::-1]
        
        # Loop through points
        trim_indices = []
        i_prev = 0
        for i in indices:
            
            # Skip first third of the section so we don't end up trimming off the nose
            if X[i] < 0.3:
                continue

            # Check if we've started going backwards
            if not rev and X[i] < X[i_prev]:
                rev = i_prev

            # Check if we've started going forward again
            if rev and not fwd and X[i] > X[i_prev]:
                fwd = i_prev
                break

            i_prev = i
        
        # Trim and insert
        if rev and fwd:

            # Determine where to trim
            if direction == "forward":
                trim_indices = list(range(rev, fwd+1))
            else:
                trim_indices = list(range(fwd, rev+1))

            # Trim
            X = np.delete(X, trim_indices)
            Y = np.delete(Y, trim_indices)

            return X, Y, len(trim_indices)
        
        else:
            return X, Y, 0


    def _fill_surface(self, X, Y, x_h, y_h, r, x_break, num_points, direction):
        # Fills in num_points along the arc defined by x_h, y_h, and r

        # Determine direction
        indices = range(X.shape[0])
        if direction == "backward":
            indices = indices[::-1]

        # Find the two points we need to fill in between
        for i in indices:
            
            # Skip first third of the section
            if X[i] < 0.3:
                continue

            if X[i] > x_break:
                fill_start = i-1
                fill_stop = i
                break

        # No filling needed, apparently...
        else:
            return X, Y

        # Get angles from the hinge point to the start and stop points
        theta0 = math.atan2(Y[fill_start]-y_h, X[fill_start]-x_h)
        theta1 = math.atan2(Y[fill_stop]-y_h, X[fill_stop]-x_h)

        # Find fill in points
        theta_fill = np.linspace(theta0, theta1, num_points+2)[1:-1]
        x_fill = x_h+r*np.cos(theta_fill)
        y_fill = y_h+r*np.sin(theta_fill)

        return np.insert(X, fill_stop, x_fill), np.insert(Y, fill_stop, y_fill)


    def _get_closest_point_on_surface(self, x, y, surface):
        # Finds the point on the surface of the airfoil which is closest to the given point using Golden section search
        # Returns the coordinates and the radius from the given point

        # Decide where to start in s
        if surface == "top":
            s0 = 0.0
            s3 = 0.5
        else:
            s0 = 0.5
            s3 = 1.0

        # Get Golden ratio
        R = 2.0/(1.0+math.sqrt(5.0))

        # Loop until interval converges
        while abs(s0-s3)>1e-10:
            
            # Get interior points
            diff = s3-s0
            s1 = s3-diff*R
            s2 = s0+diff*R

            # Calculate points
            x1 = self._x_outline(s1)
            y1 = self._y_outline(s1)
            x2 = self._x_outline(s2)
            y2 = self._y_outline(s2)
    
            # Calculate distances
            d1 = self._get_cart_dist(x, y, x1, y1)
            d2 = self._get_cart_dist(x, y, x2, y2)

            # Check
            if d1 < d2:
                s3 = s2
            else:
                s0 = s1

        return x1, y1, d1


    def _get_cart_dist(self, x0, y0, x1, y1):
        x_diff = x0-x1
        y_diff = y0-y1
        return math.sqrt(x_diff*x_diff+y_diff*y_diff)


    def generate_database(self, **kwargs):
        """Makes calls to Xfoil to calculate CL, CD, and Cm as a function of each given degree of freedom.

        Parameters
        ----------
        degrees_of_freedom : dict
            A dict specifying which degrees of freedom the database should perturb. Allowable degrees of 
            freedom are "alpha", "Rey", "Mach", "trailing_flap_deflection", and "trailing_flap_fraction".

            Each key should be one of these degrees of freedom. To specify a range for the degree of freedom,
            a dictionary with the following keys should be given:

                "range" : list
                    The lower and upper limits for this DOF.

                "steps" : int
                    The number of points in the range to interrogate.

                "index" : int
                    Index of the column for this degree of freedom in the database.

                "log_step" : bool, optional
                    Whether the steps in this dof should be spaced linearly (False) or logarithmically
                    (True). Defaults to False.

            If instead of perturbing a variable, you want the database to be evaluated at a constant value of
            that variable, a float should be given instead of a dictionary. That variable will then not be considered
            a degree of freedom of the database and will not appear in the database.
            
            An example is shown below:

                dofs = {
                    "alpha" : {
                        "range" : [math.radians(-15.0), math.radians(15.0)],
                        "steps" : 21,
                        "index" : 1
                    },
                    "Rey" : 2900000.0,
                    "trailing_flap_deflection" : {
                        "range" : [math.radians(-20.0), math.radians(20.0)],
                        "steps" : 1,
                        "index" : 0
                    },
                    "trailing_flap_fraction" : 0.25
                }

            The above input will run the airfoil through angles of attack from -15 to 15 degrees at a Reynolds number
            of 2900000.0 and through flap deflections from -20 to 20 degrees with a chord fraction of 25%.

            If a float, the degree of freedom is assumed to be constant at that value.
            
            If not specified, each degree of freedom defaults to the following:

                "alpha" : 0.0

                "Rey" : 1000000.0

                "Mach" : 0.0

                "trailing_flap_deflection" : 0.0

                "trailing_flap_fraction" : 0.0

            Please note that all angular degreees of freedom are in radians, rather than degrees.

            Currently, the number of steps in Reynolds number multiplied by the number of steps in Mach number
            may not exceed 12. This is due to internal limitations in Xfoil. However, due to the weak dependence
            of airfoil properties on Reynolds number, we do not expect this to be a great hinderance.

        N : int, optional
            Number of panel nodes for Xfoil to use. Defaults to 200.

        max_iter : int, optional
            Maximum iterations for Xfoil. Defaults to 100.

        x_trip : float or list, optional
            x location, non-dimensionalized by the chord length, of the boundary layer trip position. This is 
            specified for the top and bottom of the airfoil. If a float, the value is the same for the top
            and the bottom. If a list, the first list element is the top trip location and the second list element
            is the bottom trip location. Defaults to 1.0 for both.

        visc : bool, optional
            Whether to include viscosity. Defaults to True.

        N_crit : float, optional
            Critical amplification exponent for the boundary layer in Xfoil. Defaults to 9.0.

        update_type : bool, optional
            Whether to update the airfoil to use the newly computed database for calculations. Defaults to True.

        show_xfoil_output : bool, optional
            Display whatever Xfoil prints out. Defaults to False.

        show_xfoil_plots : bool, optional
            Display Xfoil plots. Defaults to True.

        resize_xfoil_window : float, optional
            resizes the xfoil window to screen size fraction. Xfoil defaults to 0.8 window/screen size.
            This variable defaults to None. Has no effect if show_xfoil_plots is False.

        CD_type : str, optional
            Which drag coefficient to read in. May be 'total', 'friction', or 'pressure'.
            Defaults to 'total'.

        verbose : bool, optional
            Defaults to True
        """

        # Set up lists of independent vars
        xfoil_args = {}
        self._dof_db_cols = {}
        num_total_runs = 1
        for dof, params in kwargs.pop("degrees_of_freedom", {}).items():
            if dof not in self._allowable_dofs:
                raise IOError("{0} is not an allowable DOF.".format(dof))
            vals, column_index = self._setup_ind_var(params)
            xfoil_args[dof] = vals
            num_total_runs *= len(vals)
            if column_index is not None:
                self._dof_db_cols[dof] = column_index

        # Get coefficients
        CL, CD, Cm = self.run_xfoil(**xfoil_args, **kwargs)

        # Determine the rows and cols in the database; each independent var and coefficient is a column to be iterpolated using scipy.interpolate.griddata
        self._num_dofs = len(list(self._dof_db_cols.keys()))
        num_cols = 3+self._num_dofs
        num_rows = CL.size-np.count_nonzero(np.isnan(CL))
        dof_sorted = sorted(self._dof_db_cols.items(), key=operator.itemgetter(1))
        self._dof_db_order = [x[0] for x in dof_sorted]

        # Arrange into 2D database
        self._data = np.zeros((num_rows, num_cols))
        database_row = 0
        coef_shape = CL.shape

        for i in range(coef_shape[0]):
            for j in range(coef_shape[1]):
                for k in range(coef_shape[2]):
                    for l in range(coef_shape[3]):
                        for m in range(coef_shape[4]):

                            # Check for nan
                            if np.isnan(CL[i,j,k,l,m]):
                                continue

                            # Append independent vars to database
                            for n, dof in enumerate(self._dof_db_order):
                                if dof == "alpha":
                                    ind = i
                                elif dof == "Rey":
                                    ind = j
                                elif dof == "Mach":
                                    ind = k
                                elif dof == "trailing_flap_deflection":
                                    ind = l
                                else:
                                    ind = m
                                self._data[database_row,n] = xfoil_args[dof][ind]
                        
                            # Append coefficients
                            self._data[database_row,self._num_dofs] = CL[i,j,k,l,m]
                            self._data[database_row,self._num_dofs+1] = CD[i,j,k,l,m]
                            self._data[database_row,self._num_dofs+2] = Cm[i,j,k,l,m]

                            database_row += 1

        # Sort by columns so the first column is perfectly in order
        dtype = ",".join(['i8' for i in range(num_cols)])
        for i in range(self._num_dofs,-1,-1):
            self._data = self._data[self._data[:,i].argsort(axis=0, kind='stable')] # 'stable' option is necessary to maintain ordering of columns not being actively sorted

        # Let the user know how much of the design space we actually got results for
        if kwargs.get("verbose", True):
            percent_success = round(self._data.shape[0]/num_total_runs*100, 2)
            print("\nDatabase generation complete.")
            print("Convergent results obtained from Xfoil for {0}% of the requested points.".format(percent_success))

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("database")


    def _setup_ind_var(self, input_dict):
        # Sets up a range of independent variables

        # Constant value
        if isinstance(input_dict, float):
            lower = input_dict
            upper = input_dict
            N = 1
            index = None
            log_step = False

        # Range
        else:
            limits = input_dict.get("range")
            lower = limits[0]
            upper = limits[1]
            N = input_dict.get("steps")
            index = input_dict.get("index", None)
            log_step = input_dict.get("log_step", False)

            # Check that the range will actually have multiple points
            if N == 1:
                raise IOError("A range with only one step may not be specified for a degree of freedom. Please give a single float instead.")
        
        if log_step:
            return list(np.logspace(np.log10(lower), np.log10(upper), N)), index
        else:
            return list(np.linspace(lower, upper, N)), index


    def export_database(self, **kwargs):
        """Exports the database generated by generate_database().

        Parameters
        ----------
        filename : str
            File to export the database to.
        """

        filename = kwargs.get("filename")

        # Check the database is there
        if hasattr(self, "_data"):

            # Create header
            header = []

            # Add degrees of freedom
            for dof in sorted(self._dof_db_cols.items(), key=operator.itemgetter(1)):
                header.append("{:<25s}".format(dof[0]))

            # Add coefficients
            header.append("{:<25s}".format('CL'))
            header.append("{:<25s}".format('CD'))
            header.append("{:<25s}".format('Cm'))
            header = " ".join(header)

            # Export
            with open(filename, 'w') as db_file:
                np.savetxt(db_file, self._data, '%25.10E', header=header)
        else:
            raise RuntimeError("No database has been generated for airfoil {0}. Please create a database before exporting.".format(self.name))


    def import_database(self, **kwargs):
        """Imports the specified database. Please note that if you have generated your own database not
        using AirfoilDatabase, angle of attack should be stored in radians, rather than degrees.

        Parameters
        ----------
        filename : str
            File to import the database from

        update_type : bool, optional
            Whether to update the airfoil to use the newly imported database for calculations. Defaults to True.
        """

        filename = kwargs.get("filename")

        # Load data from file
        with open(filename, 'r') as db_file:
            self._data = np.loadtxt(db_file)

        # Determine the column indices
        with open(filename, 'r') as db_file:
            header = db_file.readline().strip('#')
        self._dof_db_cols = {}
        self._num_dofs = 0
        for i, col_name in enumerate(header.split()):

            # Stop once we get to coefficient columns
            if col_name == "CL":
                break

            # Add
            self._dof_db_cols[col_name] = i
            self._num_dofs += 1

        # Figure out the order of the columns in the database
        dof_sorted = sorted(self._dof_db_cols.items(), key=operator.itemgetter(1))
        self._dof_db_order = [x[0] for x in dof_sorted]

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("database")


    def run_xfoil(self, **kwargs):
        """Calls Xfoil and extracts the aerodynamic coefficients at the given state.

        Parameters
        ----------
        alpha : float or list of float
            Angle(s) of attack to calculate the coefficients at in radians. Defaults to 0.0.

        Rey : float or list of float
            Reynolds number(s) to calculate the coefficients at. Defaults to 1000000.

        Mach : float or list of float
            Mach number(s) to calculate the coefficients at. Defaults to 0.0.

        trailing_flap_deflection : float or list of float
            Flap deflection(s) to calculate the coefficients at in radians. Defaults to 0.0.

        trailing_flap_fraction : float or list of float
            Flap fraction(s) to calculate the coefficients at in radians. Defaults to 0.0.

        N : int, optional
            Number of panels for Xfoil to use. Defaults to 200.

        max_iter : int, optional
            Maximum iterations for Xfoil. Defaults to 100.

        visc : bool, optional
            Whether to include viscosity. Defaults to True.

        x_trip : float or list, optional
            x location, non-dimensionalized by the chord length, of the boundary layer trip position. This is 
            specified for the top and bottom of the airfoil. If a float, the value is the same for the top
            and the bottom. If a list, the first list element is the top trip location and the second list element
            is the bottom trip location. Defaults to 1.0 for both.

        xycm : list, optional
            x-y coordinates, non-dimensionalized by the chord length, of the reference point for determining the
            moment coefficient. Defaults to the quater-chord.

        N_crit : float, optional
            Critical amplification exponent for the boundary layer in Xfoil. Defaults to 9.0.

        show_xfoil_output : bool, optional
            Display whatever Xfoil outputs from the command line interface. Defaults to False.

        show_xfoil_plots : bool, optional
            Display Xfoil plots. Defaults to True.
        
        resize_xfoil_window : float, optional
            resizes the xfoil window to screen size fraction. Xfoil defaults to 0.8 window/screen size.
            This variable defaults to None. Has no effect if show_xfoil_plots is False.

        CD_type : str, optional
            Which drag coefficient to read in. May be 'total', 'friction', or 'pressure'.
            Defaults to 'total'.

        verbose : bool, optional

        Returns
        -------
        CL : ndarray
            Coefficient of lift. First dimension will match the length of alpha, second will match Rey, etc.

        CD : ndarray
            Coefficient of drag. Dimensions same as CL.

        Cm : ndarray
            Moment coefficient. Dimensions same as CL.
        """
        N = kwargs.get("N", 200)
        max_iter = kwargs.get("max_iter", 100)
        verbose = kwargs.get("verbose", True)
        show_xfoil_output = kwargs.get("show_xfoil_output", False)
        x_trip = kwargs.get("x_trip", [1.0, 1.0])
        xycm = kwargs.get("xycm", [0.25, 0.0])
        if isinstance(x_trip, float):
            x_trip = [x_trip, x_trip]
        N_crit = kwargs.get("N_crit", 9.0)

        # Get states
        # Angle of attack
        alphas = kwargs.get("alpha", [0.0])
        if isinstance(alphas, float):
            alphas = [alphas]
        first_dim = len(alphas)
    
        # Reynolds number
        Reys = kwargs.get("Rey", [1000000.0])
        if isinstance(Reys, float):
            Reys = [Reys]
        second_dim = len(Reys)

        # Mach number
        Machs = kwargs.get("Mach", [0.0])
        if isinstance(Machs, float):
            Machs = [Machs]
        third_dim = len(Machs)

        # Flap deflections
        delta_fts = kwargs.get("trailing_flap_deflection", [0.0])
        if isinstance(delta_fts, float):
            delta_fts = [delta_fts]
        fourth_dim = len(delta_fts)

        # Flap fractions
        c_fts = kwargs.get("trailing_flap_fraction", [0.0])
        if isinstance(c_fts, float):
            c_fts = [c_fts]
        fifth_dim = len(c_fts)

        # xfoil window resizing
        resize_xfoil_window = kwargs.get('resize_xfoil_window', None)

        # Initialize coefficient arrays
        CL = np.empty((first_dim, second_dim, third_dim, fourth_dim, fifth_dim))
        CD = np.empty((first_dim, second_dim, third_dim, fourth_dim, fifth_dim))
        Cm = np.empty((first_dim, second_dim, third_dim, fourth_dim, fifth_dim))
        CL[:] = np.nan
        CD[:] = np.nan
        Cm[:] = np.nan

        # Clean up from previous iterations
        dir_list = os.listdir()
        for item in dir_list:
            if os.path.isfile(item) and ".pacc" in item or ".geom" in item:
                os.remove(item)

        # Loop through flap deflections and fractions
        if verbose:
            print("Running Xfoil...")
            print("{0:>25}{1:>25}{2:>25}".format("Percent Complete", "Flap Deflection [deg]", "Flap Fraction"))
            print(''.join(['-']*75))
        num_xfoil_runs = fourth_dim*fifth_dim
        for l, delta_ft in enumerate(delta_fts):
            for m, c_ft in enumerate(c_fts):
                
                # Clear pacc file list
                pacc_files = []
                file_id = 0
            
                # Export geometry
                outline_points = "a_{0:1.6f}_{1:1.6f}.geom".format(delta_ft, c_ft)
                #outline_points = os.path.abspath("xfoil_geom_{0:1.6f}.geom".format(delta_ft))
                self.get_outline_points(N=N, trailing_flap_deflection=delta_ft, trailing_flap_fraction=c_ft, export=outline_points, close_te=False)

                # Display update
                if verbose:
                    percent_complete = round((l*fifth_dim+m)/(num_xfoil_runs)*100)
                    print("{0:>24}%{1:>25}{2:>25}".format(percent_complete, math.degrees(delta_ft), c_ft))

                # Loop through Reynolds number
                for Re in Reys:

                    # Initialize xfoil execution
                    with sp.Popen(['xfoil'], stdin=sp.PIPE, stdout=sp.PIPE) as xfoil_process:

                        commands = []

                        # Turn off plots
                        if not kwargs.get("show_xfoil_plots", True):
                            commands += ['PLOP',
                                         'G',
                                         '']
                        elif resize_xfoil_window != None:
                            commands += ['PLOP',
                                         'W {}'.format(resize_xfoil_window),
                                         '']

                        # Read in geometry
                        commands += ['LOAD {0}'.format(outline_points),
                                     '{0}'.format(self.name)]

                        # Set panelling ratio and let Xfoil make its own panels
                        # This throws a fortran error if the plots are turned off with Xfoil 6.99
                        commands += ['PPAR',
                                     'N',
                                     '{0}'.format(N),
                                     'T',
                                     '1',
                                     '',
                                     '']

                        # Set moment reference point
                        commands += ['XYCM',
                                     str(xycm[0]),
                                     str(xycm[1])]

                        # Set viscous mode (if desired)
                        if kwargs.get("visc", True):
                            commands += ['OPER',
                                         'VISC',
                                         '']

                            # Set boundary layer parameters
                            commands += ['VPAR',
                                         'Xtr',
                                         str(x_trip[0]),
                                         str(x_trip[1]),
                                         'N',
                                         str(N_crit),
                                         '',
                                         '']

                        # Initialize PACC index
                        pacc_index = 0

                        # Loop through Mach numbers
                        for M in Machs:

                            # Polar accumulation file
                            file_id += 1
                            pacc_file = "xfoil_results_{0}.pacc".format(file_id)
                            pacc_files.append(pacc_file)

                            # Set Mach, Reynolds number, iteration limit, and polar accumulation
                            if kwargs.get("visc", True):
                                commands += ['OPER',
                                            'RE',
                                            str(Re),
                                            'MACH',
                                            str(M),
                                            'ITER {0}'.format(max_iter),
                                            'PACC',
                                            pacc_file,
                                            '']
                            else:
                                commands += ['OPER',
                                            'MACH',
                                            str(M),
                                            'ITER {0}'.format(max_iter),
                                            'PACC',
                                            pacc_file,
                                            '']

                            # Sweep angle of attack
                            if len(alphas) == 1:
                                commands.append('ALFA {0:1.6f}'.format(math.degrees(alphas[0])))

                            else:
                                # Sweep from 0 aoa up
                                zero_ind = np.argmin(np.abs(alphas))
                                if zero_ind != len(alphas)-1:
                                    for a in alphas[zero_ind:]:
                                        commands.append('ALFA {0:1.6f}'.format(math.degrees(a)))
                            
                                # Reset solver
                                commands.append('INIT')

                                # Sweep from 0 aoa down
                                if zero_ind != 0:
                                    for a in alphas[zero_ind-1::-1]:
                                        commands.append('ALFA {0:1.6f}'.format(math.degrees(a)))
                            
                            # Reset solver
                            commands.append('INIT')

                            # End polar accumulation
                            commands += ['PACC {0}'.format(pacc_index),
                                         '']
                            pacc_index += 1

                        # Finish commands
                        commands += ['',
                                     'QUIT']

                        # Run Xfoil
                        xfoil_input = '\r'.join(commands).encode('utf-8')
                        response = xfoil_process.communicate(xfoil_input)

                        # Show output
                        if show_xfoil_output:
                            print(response[0].decode('utf-8'))
                            if response[1] is not None:
                                print(response[1].decode('utf-8'))

                # Clean up geometry
                os.remove(outline_points)

                # Read in files and store arrays
                for filename in pacc_files:

                    # Read in file
                    try:
                        alpha_i, CL_i, CD_i, Cm_i, Re_i, M_i = self.read_pacc_file(filename, CD_type=kwargs.get('CD_type', 'total'))
                    except FileNotFoundError:
                        warnings.warn("Couldn't find results file {0}. Usually an indication of Xfoil crashing.".format(filename))
                        continue

                    # Determine the Reynolds and Mach indices
                    j = min(range(len(Reys)), key=lambda i: abs(Reys[i]-Re_i))

                    k = min(range(len(Machs)), key=lambda i: abs(Machs[i]-M_i))

                    # Loop through alphas
                    i_true = 0
                    for i_iter, alpha in enumerate(alpha_i):

                        # Line up with our original independent alpha, as Xfoil does not output a non-converged result
                        i_true = min(range(len(alphas)), key=lambda i: abs(alphas[i]-alpha))

                        CL[i_true,j,k,l,m] = CL_i[i_iter]
                        CD[i_true,j,k,l,m] = CD_i[i_iter]
                        Cm[i_true,j,k,l,m] = Cm_i[i_iter]

                    # Interpolate missing values
                    for i, alpha in enumerate(alpha_i):
                        if np.isnan(CL[i,j,k,l,m]): # Result did not converge

                            # Mid-value
                            if i != 0 and i != len(alpha_i)-1:
                                weight = (alpha_i[i+1]-alpha)/(alpha_i[i+1]-alpha_i[i-1])
                                CL[i,j,k,l,m] = CL[i-1,j,k,l,m]*(1-weight)+CL[i+1,j,k,l,m]*weight
                                CD[i,j,k,l,m] = CD[i-1,j,k,l,m]*(1-weight)+CD[i+1,j,k,l,m]*weight
                                Cm[i,j,k,l,m] = Cm[i-1,j,k,l,m]*(1-weight)+Cm[i+1,j,k,l,m]*weight

                    # Clean up polar files
                    os.remove(filename)

        return CL, CD, Cm


    def read_pacc_file(self, filename, CD_type='total'):
        """Reads in and formats an Xfoil polar accumulation file.

        Parameters
        ----------
        filename : str
            File to read in.

        CD_type : str, optional
            Which drag coefficient to read in. May be 'total', 'friction', or 'pressure'.
            Defaults to 'total'.

        Returns
        -------
        alpha : list
            List of angles of attack from the accumulation polar.

        CL : list
            Coefficient of lift at each alpha.

        CD : list
            Coefficient of drag at each alpha.
        
        Cm : list
            Moment coefficient at each alpha.

        Re : float
            Reynolds number for the polar.

        M : float
            Mach number for the polar.
        """

        # Open file
        with open(filename, 'r') as file_handle:

            # Read in line by line
            lines = []
            line = file_handle.readline()
            while line:
                lines.append(line)
                line = file_handle.readline()

        # Find Mach and Reynolds number
        mr_line = lines[8].split()
        M = float(mr_line[2])
        Re = float(''.join(mr_line[5:8]))

        # Collect alpha and coefficients
        alpha = []
        CL = []
        CD = []
        Cm = []
        for line in lines[12:]:
            split_line = line.split()
            alpha.append(math.radians(float(split_line[0])))
            CL.append(float(split_line[1]))
            if CD_type=='total':
                CD.append(float(split_line[2]))
            elif CD_type=='pressure':
                CD.append(float(split_line[3]))
            elif CD_type=='friction':
                CD.append(float(split_line[2])-float(split_line[3]))
            Cm.append(float(split_line[4]))

        # Sort in alpha
        sorted_indices = np.argsort(alpha)
        alpha = np.array(alpha)[sorted_indices]
        CL = np.array(CL)[sorted_indices]
        CD = np.array(CD)[sorted_indices]
        Cm = np.array(Cm)[sorted_indices]

        return alpha, CL, CD, Cm, Re, M


    def _create_filled_database(self):
        # Fills in missing values in the database to make it a consistent d-dimensional array.

        # Initialize storage for independent vars
        self._dof_filled = []
        for i in range(self._num_dofs):
            self._dof_filled.append([])

        # Gather independent vars
        for i in range(self._data.shape[0]):
            for j in range(self._num_dofs):

                # Check if the value is already there
                if not self._data[i,j] in self._dof_filled[j]:
                    self._dof_filled[j].append(self._data[i,j])

        # Sort independent vars and initialize filled array
        shape = []
        for dof in self._dof_filled:
            dof.sort()
            shape.append(len(dof))
        filled_CL = np.zeros(tuple(shape))
        filled_CD = np.zeros(tuple(shape))
        filled_Cm = np.zeros(tuple(shape))
        N = filled_CL.size

        # Create grid of independent vars
        raw_grid = np.meshgrid(*self._dof_filled)

        # Parse independent vars for passing to getters
        params = {}
        for i, dof in enumerate(self._dof_db_order):
            params[dof] = raw_grid[i].flatten()

        # Fill in values
        filled_CL_view = filled_CL.reshape(N)
        filled_CL_view[:] = self.get_CL(**params)
        filled_CD_view = filled_CD.reshape(N)
        filled_CD_view[:] = self.get_CD(**params)
        filled_Cm_view = filled_Cm.reshape(N)
        filled_Cm_view[:] = self.get_Cm(**params)

        # Huh. Turns out I don't actually need this, so I'm not going to bother developing it further. But I'll keep it here in case it becomes useful


    def generate_polynomial_fit(self, **kwargs):
        """Generates a set of multivariable polynomials using least-squares regression to approximate the database.
        Note: This airfoil must have a database already for fits to be created.

        Parameters
        ----------
        CL_degrees : dict or str, optional
            If dict, order of fit polynomial for the coefficient of lift for each degree of freedom,
            formatted as

            {
                "<DOF1_NAME>" : <ORDER>,
                "<DOF2_NAME>" : <ORDER>,
                ...
            }

            Orders must be integers. Defaults to 1 for any not specified.

            Can also be specified as "auto". In this case, the fit degrees will be determined automatically
            using the method described in Morelli, "Global Nonlinear Aerodynamic Modeling Using
            Multivariate Orthogonal Functions," Journal of Aircraft, 1995. The algorithm tried to minimize
            the RMS error between the data and the prediction while also minimizing the degree of the fit. 
            This will automatically determine the fit order for each degree of freedom.

        CD_degrees : dict, optional
            Same as CL_degrees.

        Cm_degrees : dict, optional
            Same as CL_degrees.

        CL_kwargs : dict, optional
            keyword arguments sent to the CL polynomial fit function
            
            When CL_degrees is specified as "auto" then CL_kwargs can be
            
                "max_order" : int, optional
                    gives the max order of polynomial for any one of the independent varialbes
                    to try. Defaults to 6.
                "tol" : float, optional
                    Gives the cut-off value for any polynomial coefficient to not be included
                    in the final results. If a coefficient has an absolute value below tol,
                    it won't be included. Defaults to 1e-12.
                "sigma" : float, optional
                    value used to determine the trade off between how good of a fit to perform
                    and how many terms to keep. Defaults to None, which causes the function to
                    calculate sigma automatically using the mean squared of the difference of
                    the independent variable values with respect to the mean independent
                    variable value of the dataset
                "sigma_multiplier" : float, optional
                    term multiplied onto sigma to change it's value. Allows using a multiple
                    of the automatically determined sigma value. Defaults to 1.
            
            Otherwise CL_kwargs could be
            
                "interaction" : boolean, optional
                    value with default set to True. This variable determines whether or not
                    interaction terms are included in the fit function. If set to True,
                    interaction terms up the max order for each independent variable are
                    included, i.e. if Nvec = [3,2] then the highest interaction term included
                    is x_1^3*x_2^2. Specific interaction terms can be omitted using the
                    constraints input
                "sym" : list, optional
                    Defaults to an empty list. If used, the length should be V and each element
                    should contain a boolean, True or False. The ith element determines if the
                    ith independent variable is symmetric either even or odd, which is
                    determined by the order given in Nvec. This will also remove the
                    cooresponding interaction terms if they are enabled.
                "sym_same" : list, optional
                    Defaults as an empty list. If used, the entries in the list should be
                    tuples with two integers. The integers represent the independent variables
                    that the "same" symmetry condition will be applied. The "same" symmetry
                    ensures all interaction terms with exponents of the two independent
                    variables that are either odd-odd or even-even to be forced to zero
                "sym_diff" : = list, optional
                    Defaults as an empty list. Similar to "sym_same" except it enforces the
                    "diff" symmetry condition which ensures all interaction terms with exponents
                    of the two independent variables that are either odd-even or even-odd to be
                    forced to zero
                "zeroConstraints" : list, optional
                    Defaults as an empty list. Entries in the list contain integer tuples of
                    length V. The integer values represent the powers of the independent variables
                    whose coefficient will be forced to 0 before the best fit calculations are
                    performed, allowing the user to omit specific interaction terms or regular
                    polynomial terms
                "constraints" : list, optional
                    Defaults to an empty list. Entries in the list contain tuples of length 2.
                    The first entry is a list of integers that represent the powers of the
                    independent variables whose coefficient will then be forced to be equal to the
                    second entry in the tuple, which should be a float.
                "percent" : boolean, optional
                    Default set to False. When set to True the least squares is performed on the
                    percent error squared. This option should not be used if y contains any zero
                    or near zero values, as this might cause a divide by zero error.
                "weighting" : function, optional
                    Defaults to None. If given, weighting should be a function that takes as
                    arguments x, y, and p where x and y are the independent and dependent
                    variables defined above and p is the index representing a certain data point.
                    weighting should return a 'weighting factor' that determines how important
                    that datapoint is. Returning a '1' weights the datapoint normally.
        
        CD_kwargs : dict, optional
            Same as CL_kwargs

        Cm_kwargs : dict, optional
            Same as CL_kwargs

        update_type : bool, optional
            Whether to update the airfoil to use the newly computed polynomial fits for calculations. Defaults to True.

        verbose : bool, optional
        """

        # Check for database
        if not hasattr(self, "_data"):
            raise RuntimeError("No database found! Please generate or import a database before trying to create polynomial fits.")

        # Determine what the maximum fit order is for autoPolyFit
        CL_degrees = kwargs.pop("CL_degrees", {})
        CD_degrees = kwargs.pop("CD_degrees", {})
        Cm_degrees = kwargs.pop("Cm_degrees", {})
        CL_kwargs  = kwargs.pop("CL_kwargs", {})
        CD_kwargs  = kwargs.pop("CD_kwargs", {})
        Cm_kwargs  = kwargs.pop("Cm_kwargs", {})
        verbose = kwargs.pop('verbose', True)
        if verbose: print('Generating Polynomial Fits for airfoil {}'.format(self.name))
        CL_kwargs['verbose'] = verbose
        CD_kwargs['verbose'] = verbose
        Cm_kwargs['verbose'] = verbose

        # CL
        if verbose: print('Performing CL curve fit')
        if CL_degrees=="auto":
            self._CL_poly_coefs, self._CL_degrees, self._CLfit_R2 = autoPolyFit(self._data[:,:self._num_dofs], self._data[:, self._num_dofs], **CL_kwargs)

        elif isinstance(CL_degrees, dict):

            # Sort fit degrees
            self._CL_degrees = []
            for dof in self._dof_db_order:
                self._CL_degrees.append(CL_degrees.get(dof, 1))

            # Generate
            self._CL_poly_coefs, self._CLfit_R2 = multivariablePolynomialFit(self._CL_degrees, self._data[:,:self._num_dofs], self._data[:, self._num_dofs], **CL_kwargs)

        else:
            raise IOError("Fit degree specification must be 'auto' or type(dict). Got {0} type {1}.".format(CL_degrees, type(CL_degrees)))
        
        # CD
        if verbose: print('Performing CD curve fit')
        if CD_degrees=="auto":
            self._CD_poly_coefs, self._CD_degrees, self._CDfit_R2 = autoPolyFit(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+1], **CD_kwargs)

        elif isinstance(CL_degrees, dict):

            # Sort fit degrees
            self._CD_degrees = []
            for dof in self._dof_db_order:
                self._CD_degrees.append(CD_degrees.get(dof, 1))

            # Generate
            self._CD_poly_coefs, self._CDfit_R2 = multivariablePolynomialFit(self._CD_degrees, self._data[:,:self._num_dofs], self._data[:,self._num_dofs+1], **CD_kwargs)

        else:
            raise IOError("Fit degree specification must be 'auto' or type(dict). Got {0} type {1}.".format(CL_degrees, type(CL_degrees)))
        
        # Cm
        if verbose: print('Performing Cm curve fit')
        if Cm_degrees=="auto":
            self._Cm_poly_coefs, self._Cm_degrees, self._Cmfit_R2 = autoPolyFit(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+2], **Cm_kwargs)

        elif isinstance(Cm_degrees, dict):

            # Sort fit degrees
            self._Cm_degrees = []
            for dof in self._dof_db_order:
                self._Cm_degrees.append(Cm_degrees.get(dof, 1))

            # Generate polynomial fit
            self._Cm_poly_coefs, self._Cmfit_R2 = multivariablePolynomialFit(self._Cm_degrees, self._data[:,:self._num_dofs], self._data[:, self._num_dofs+2], **Cm_kwargs)

        # Store limits
        self._dof_limits = []
        for i in range(self._num_dofs):
            self._dof_limits.append([np.min(self._data[:,i]), np.max(self._data[:,i])])

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("poly_fit")
        
        self._CLfit_RMS, self._CLfit_RMSN = multivariableRMS(self._data[:,:self._num_dofs], self._data[:,self._num_dofs], self._CL_poly_coefs, self._CL_degrees, verbose=verbose)
        self._CDfit_RMS, self._CDfit_RMSN = multivariableRMS(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+1], self._CD_poly_coefs, self._CD_degrees, verbose=verbose)
        self._Cmfit_RMS, self._Cmfit_RMSN = multivariableRMS(self._data[:,:self._num_dofs], self._data[:,self._num_dofs+2], self._Cm_poly_coefs, self._Cm_degrees, verbose=verbose)
        
        if verbose:
            print('\nCL fits\n'+'='*20)
            print('R^2 : {}'.format(self._CLfit_R2))
            print('RMS : {}'.format(self._CLfit_RMS))
            print('RMSN: {}\n'.format(self._CLfit_RMSN))
            print('CD fits\n'+'='*20)
            print('R^2 : {}'.format(self._CDfit_R2))
            print('RMS : {}'.format(self._CDfit_RMS))
            print('RMSN: {}\n'.format(self._CDfit_RMSN))
            print('Cm fits\n'+'='*20)
            print('R^2 : {}'.format(self._Cmfit_R2))
            print('RMS : {}'.format(self._Cmfit_RMS))
            print('RMSN: {}\n'.format(self._Cmfit_RMSN))


    def export_polynomial_fits(self, **kwargs):
        """Save the polynomial fit to a JSON object.

        Parameters
        ----------
        filename : str
            JSON object to write polynomial fit data to.

        write_limits : bool, optional
            Whether to limit the polynomial fits based on the original range of data.
            Defaults to True.

        """

        # Get filename
        filename = kwargs.get("filename")

        # Create export dictionary
        export = {}
        export["tag"] = "Polynomial fit to database for {0} airfoil.".format(self.name)
        export["degrees_of_freedom"] = self._dof_db_order
        if kwargs.get("write_limits"):
            export["limits"] = self._dof_limits
        export["defaults"] = self._dof_defaults
        export["fit_degrees"] = {}
        export["fit_degrees"]["CL"] = self._CL_degrees
        export["fit_degrees"]["CD"] = self._CD_degrees
        export["fit_degrees"]["Cm"] = self._Cm_degrees
        export['fit_error'] = {}
        export['fit_error']['CL'] = {}
        export['fit_error']['CL']['R^2'] = self._CLfit_R2
        export['fit_error']['CL']['RMS'] = self._CLfit_RMS
        export['fit_error']['CL']['RMSN'] = self._CLfit_RMSN
        export['fit_error']['CD'] = {}
        export['fit_error']['CD']['R^2'] = self._CDfit_R2
        export['fit_error']['CD']['RMS'] = self._CDfit_RMS
        export['fit_error']['CD']['RMSN'] = self._CDfit_RMSN
        export['fit_error']['Cm'] = {}
        export['fit_error']['Cm']['R^2'] = self._Cmfit_R2
        export['fit_error']['Cm']['RMS'] = self._Cmfit_RMS
        export['fit_error']['Cm']['RMSN'] = self._Cmfit_RMSN
        export["fit_coefs"] = {}
        export["fit_coefs"]["CL"] = list(self._CL_poly_coefs)
        export["fit_coefs"]["CD"] = list(self._CD_poly_coefs)
        export["fit_coefs"]["Cm"] = list(self._Cm_poly_coefs)

        # Export data
        with open(filename, 'w') as export_file_handle:
            json.dump(export, export_file_handle, indent=4)


    def import_polynomial_fits(self, **kwargs):
        """Read in polynomial fit data from a JSON object.

        Parameters
        ----------
        filename : str
            JSON object to read polynomial fit data from.

        update_type : bool, optional
            Whether to update the airfoil to use the newly imported polynomial fits for calculations. Defaults to True.

        """

        # Get filename
        filename = kwargs.get("filename")

        # Read in data
        with open(filename, 'r') as import_file_handle:
            input_dict = json.load(import_file_handle)

        # Parse input dict
        self._dof_db_order = input_dict["degrees_of_freedom"]
        self._num_dofs = len(self._dof_db_order)
        self._dof_limits = input_dict.get("limits", [[-np.inf, np.inf]]*self._num_dofs)
        self._CL_degrees = input_dict["fit_degrees"]["CL"]
        self._CD_degrees = input_dict["fit_degrees"]["CD"]
        self._Cm_degrees = input_dict["fit_degrees"]["Cm"]
        self._CL_poly_coefs = np.array(input_dict["fit_coefs"]["CL"])
        self._CD_poly_coefs = np.array(input_dict["fit_coefs"]["CD"])
        self._Cm_poly_coefs = np.array(input_dict["fit_coefs"]["Cm"])
        if isinstance(input_dict.get('fit_error', None), dict):
            if isinstance(input_dict['fit_error'].get('CL', None), dict):
                self._CLfit_R2 = input_dict['fit_error']['CL'].get('R^2', None)
                self._CLfit_RMS = input_dict['fit_error']['CL'].get('RMS', None)
                self._CLfit_RMSN = input_dict['fit_error']['CL'].get('RMSN', None)
            if isinstance(input_dict['fit_error'].get('CD', None), dict):
                self._CDfit_R2 = input_dict['fit_error']['CD'].get('R^2', None)
                self._CDfit_RMS = input_dict['fit_error']['CD'].get('RMS', None)
                self._CDfit_RMSN = input_dict['fit_error']['CD'].get('RMSN', None)
            if isinstance(input_dict['fit_error'].get('Cm', None), dict):
                self._Cmfit_R2 = input_dict['fit_error']['Cm'].get('R^2', None)
                self._Cmfit_RMS = input_dict['fit_error']['Cm'].get('RMS', None)
                self._Cmfit_RMSN = input_dict['fit_error']['Cm'].get('RMSN', None)

        # Update type
        if kwargs.get("update_type", True):
            self.set_type("poly_fit")


    def _get_polynomial_data(self, coef_index, **kwargs):
        # Determines the value of the given coefficient from the polynomial fit
        # coef_index | coef
        #   0        |  CL
        #   1        |  CD
        #   2        |  Cm

        # Stack up independent vars
        ind_vars = []
        N = 1
        for dof in self._dof_db_order:

            # Get independent variable values
            ind_var = kwargs.get(dof, self._dof_defaults[dof])
            
            # Check for array of size 1
            if not np.isscalar(ind_var) and len(ind_var) == 1:
                ind_vars.append(ind_var.item())
            else:
                ind_vars.append(ind_var)

            # Update max size
            if not np.isscalar(ind_var):
                N = max(N, len(ind_var))

        # Fill any values
        if N > 1:
            for i, ind_var in enumerate(ind_vars):
                if np.isscalar(ind_var):
                    ind_vars[i] = np.full(N, ind_var)

        # Setup input matrix
        if N == 1:
            x = np.array(ind_vars)[:,np.newaxis]
        else:
            x = np.array(ind_vars)

        # Get data
        if coef_index == 0:
            coef = multivariablePolynomialFunction(self._CL_poly_coefs, self._CL_degrees, x)
        elif coef_index == 1:
            coef = multivariablePolynomialFunction(self._CD_poly_coefs, self._CD_degrees, x)
        elif coef_index == 2:
            coef = multivariablePolynomialFunction(self._Cm_poly_coefs, self._Cm_degrees, x)

        # Check limits
        if self._raise_poly_bounds_error:
            for i in range(N):
                for j in range(self._num_dofs):
                    if x[j,i] > self._dof_limits[j][1] or x[j,i] < self._dof_limits[j][0]:
                        coef[i] = np.nan

            # Check for going out of bounds
            if np.isnan(coef).any():
                raise PolyFitBoundsError(self.name, np.argwhere(np.isnan(coef)).flatten(), kwargs)

        return coef


    def generate_linear_model(self, **kwargs):
        """Creates a linearized model of the airfoil coefficients in alpha. Pulls from the
        database or poly_fit information to generate this model. Cannot be used on a type
        "linear" airfoil.
        
        linear_limits : list, optional
            Limits in alpha for which the behavior of the airfoil can be considered linear. If not
            given, the user will be prompted to graphically select this region. Given in degrees.

        update_type : bool, optional
            Whether to change the type of the airfoil to "linear" once the model is determined.
            Defaults to True.

        plot_model : bool, optional
            Whether to display a polar of the linear region determined. Defaults to False.

        Rey : float, optional
            Reynolds number at which to evaluate the model.

        Mach : float, optional
            Mach number at which to evaluate the model.
        """

        # Check for correct type
        if self._type == "linear":
            raise RuntimeError("generate_linear_model() cannot be called on a 'linear' type airfoil.")

        # Determine range of alpha
        linear_limits = kwargs.get("linear_limits", None)
        if linear_limits is None:
            alpha = np.linspace(-20.0, 20.0, 30)
        else:
            alpha = np.linspace(linear_limits[0], linear_limits[1], 30)

        # Generate dataset
        CL = np.zeros(30)
        Cm = np.zeros(30)
        CD = np.zeros(30)
        for i, a in enumerate(alpha):
            try:
                CL[i] = self.get_CL(alpha=np.radians(a), **kwargs)
                Cm[i] = self.get_Cm(alpha=np.radians(a), **kwargs)
                CD[i] = self.get_CD(alpha=np.radians(a), **kwargs)
            except DatabaseBoundsError:
                continue

        # Plot dataset for user to select linear region
        if linear_limits is None:

            # Define picker
            self._selected_ind = []
            def on_pick(event):

                # Get index
                i = int(event.ind[0])
                self._selected_ind.append(i)

                # Add x
                fig.axes[0].plot(alpha[i], CL[i], 'rx')

                # Check if we have enough
                if len(self._selected_ind) >= 2:
                    plt.close(fig)

            # Display
            plt.ion()
            fig, ax = plt.subplots()
            ax.plot(alpha, CL, 'bo', picker=3)
            plt.xlabel("Alpha [deg]")
            plt.ylabel("Lift Coefficient")
            plt.title("To generate a linear model, select the lower and upper limits of the linear region.")
            fig.canvas.mpl_connect('pick_event', on_pick)
            plt.show(block=True)
            plt.ioff()

            # Trim arrays
            self._selected_ind = sorted(self._selected_ind)
            if len(self._selected_ind) != 2:
                raise RuntimeError("No points were selected to determine the linear region.")
            alpha = np.radians(alpha[self._selected_ind[0]:self._selected_ind[1]+1])
            CL = CL[self._selected_ind[0]:self._selected_ind[1]+1]
            Cm = Cm[self._selected_ind[0]:self._selected_ind[1]+1]
            CD = CD[self._selected_ind[0]:self._selected_ind[1]+1]

        else:
            alpha = np.radians(alpha)

        # Get CL model
        coef_array = np.polyfit(alpha, CL, 1)
        self._CLa = coef_array[0]
        self._aL0 = -coef_array[1]/self._CLa
        self._CL_max = np.max(CL)

        # Get Cm model
        coef_array = np.polyfit(alpha, Cm, 1)
        self._Cma = coef_array[0]
        self._CmL0 = self._Cma*self._aL0+coef_array[1]

        # Get CD model
        coef_array = np.polyfit(CL, CD, 2)
        self._CD0 = coef_array[2]
        self._CD1 = coef_array[1]
        self._CD2 = coef_array[0]

        # Plot model within linear region
        if kwargs.get("plot_model", False):

            # CL
            plt.close('all')
            fig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3)
            fig.suptitle("Linear Model for {0}".format(self.name))
            ax0.set_title("CL")
            ax0.plot(alpha, CL, "gx", label="Data")
            ax0.plot(alpha, alpha*self._CLa+self._aL0, "g-", label="Model")
            ax0.legend()
            ax0.set_xlabel("Angle of Attack [rad]")
            ax0.set_ylabel("Lift Coefficient")

            # Cm
            ax1.set_title("Cm")
            ax1.plot(alpha, Cm, 'bx', label="Data")
            ax1.plot(alpha, (alpha-self._aL0)*self._Cma+self._CmL0, "b-", label="Model")
            ax1.legend()
            ax1.set_xlabel("Angle of Attack [rad]")
            ax1.set_ylabel("Moment Coefficient")

            # CD
            ax2.set_title("CD")
            ax2.plot(CL, CD, 'rx', label="Data")
            ax2.plot(CL, self._CD0+self._CD1*CL+self._CD2*CL*CL, 'r-', label="Model")
            ax2.legend()
            ax2.set_xlabel("Lift Coefficient")
            ax2.set_ylabel("Drag Coefficient")
            plt.show()

        # Update type
        if kwargs.get("update_type", True):
            self._type = "linear"


    def export_linear_model(self, **kwargs):
        """Exports the linear coefficients used to predict the behavior of the airfoil.

        Parameters
        ----------
        filename : str
            JSON file to export the model data to.
        """

        # Check there is a model to export
        if not hasattr(self, "_aL0"):
            raise RuntimeError("A linear model for {0} could not be exported because it has none.".format(self.name))

        # Parse coefficients
        model_dict = {
            "aL0" : self._aL0,
            "CLa" : self._CLa,
            "CmL0" : self._CmL0,
            "Cma" : self._Cma,
            "CD0" : self._CD0,
            "CD1" : self._CD1,
            "CD2" : self._CD2,
            "CL_max" : self._CL_max
        }

        # Export
        filename = kwargs.get("filename")
        with open(filename, 'w') as export_file_handle:
            json.dump(model_dict, export_file_handle, indent=4)
</"file: python/AirfoilDatabase/build/lib/airfoil_db/airfoil.py">

<"file: python/AirfoilDatabase/build/lib/airfoil_db/exceptions.py">"""Custom exceptions used in the airfoil class."""

class DatabaseBoundsError(Exception):
    """An exception thrown when the inputs to the airfoil database fall outside the database bounds.

    Attributes
    ----------
    airfoil : str
        The name of the airfoil for which this exception occurred.

    inputs_dict : dict
        The arguments passed to the airfoil.

    exception_indices : list
        The indices at which the arguments fell outside the database bounds.

    message : str
        A message about the error.
    """

    def __init__(self, airfoil, exception_indices, inputs_dict):
        self.airfoil = airfoil
        self.exception_indices = exception_indices
        self.inputs_dict = inputs_dict
        self.message = "The inputs to the airfoil database fell outside the bounds of available data."
        super().__init__(self.message)


    def __str__(self):
        return self.message+" Airfoil: {0}".format(self.airfoil)


class PolyFitBoundsError(Exception):
    """An exception thrown when the inputs to the airfoil polynomial fits fall outside the bounds.

    Attributes
    ----------
    airfoil : str
        The name of the airfoil for which this exception occurred.

    inputs_dict : dict
        The arguments passed to the airfoil.

    exception_indices : list
        The indices at which the arguments fell outside the bounds.

    message : str
        A message about the error.
    """

    def __init__(self, airfoil, exception_indices, inputs_dict):
        self.airfoil = airfoil
        self.exception_indices = exception_indices
        self.inputs_dict = inputs_dict
        self.message = "The inputs to the airfoil polynomial fits fell outside the bounds of available data."
        super().__init__(self.message)


    def __str__(self):
        return self.message+" Airfoil: {0}".format(self.airfoil)


class CamberSolverNotConvergedError(Exception):
    """An exception thrown when the camber line solver fails to converge.

    Attributes
    ----------
    airfoil : str
        The name of the airfoil for which this exception occurred.

    final_error : float
        The final approximate error of the solver.

    message : str
        A message about the error.
    """

    def __init__(self, airfoil, final_error):
        self.airfoil = airfoil
        self.final_error = final_error
        self.message = "The camber line solver for {0} failed to converge. Final error: {1}".format(self.airfoil, self.final_error)
        super().__init__(self.message)</"file: python/AirfoilDatabase/build/lib/airfoil_db/exceptions.py">

<"file: python/AirfoilDatabase/build/lib/airfoil_db/poly_fits.py">"""
Generic Multivariable Polynomial Fit Using Least Squares Regression With
Full Control Of Interaction Terms And Constraint Capabilities

This module contains functions to calculate the polynomial coefficients for 
an arbitrary order polynomial curve fit to a dataset with an arbitrary
number of independent variables.

Routine Listings
-----------------

multivariablePolynomialFit : function for calculating a curve fit to data
    with an arbitrary number of independent variables

multivariablePolynomialFunction : function for calculating a polynomial with
    an arbitrary number of independent variables

multivariableR2 : function calculating the coefficient of determination
    value, or R^2 value, of a polynomial fit of an arbitrary number of
    independent variables

multivariableRMS : function calculating an RMS (root, mean, squared) error
    and a custom RMSN (root, mean, squared, normalized) error where
    normalized means the error is divided by the mean of the absolute value
    of the dependent variables, for a multidimensional polynomial function

compose_j : function used by the multivariable series of functions that
    composes the n values of the independent variables into the counter j,
    this function can also be used for the nhat values and i

decompose_j : function used by the multivariable seris of functions that
    decomposes the counter j into the different n values for the independent
    variables, this function can also be used for i and the nhat values.
"""
import numpy as np
from datetime import datetime as dt
from datetime import timedelta as td


def multivariablePolynomialFit(Nvec, xx, yy ,interaction=True, sym=[], sym_same=[], sym_diff=[], zeroConstraints=[], constraints=[], percent=False, weighting=None, verbose=True):
    """
    inputs
    
        Nvec = list with a length V equal to the number of independent
            variables. The ith element values are integers of polynomial
            order of the ith independent variable
        x = numpy matrix of size k by V, where k is the total number of
            points in the dataset. The ith column represents the ith
            independent variable values with the rows representing the
            different data points
        y = list with a length of k with the dependent variable values
        interaction = boolean value with default set to False. This variable
            determines whether or not interaction terms are included in the
            fit function. If set to True, interaction terms up the max order
            for each independent variable are included, i.e. if Nvec = [3,2]
            then the highest interaction term included is x_1^3*x_2^2.
            Specific interaction terms can be omitted using the constraints
            input
        sym = optional list that defaults as an empty list. If used, the
            length should be V and each element should contain a boolean,
            True or False. The ith element determines if the ith independent
            variable is symmetric either even or odd, which is determined by
            the order given in Nvec. This will also remove the cooresponding
            interaction terms if they are enabled.
        sym_same = optional list that defaults as an empty list. If used,
            the entries in the list should be tuples with two integers. The
            integers represent the independent variables that the "same"
            symmetry condition will be applied. The "same" symmetry forces
            all interaction terms
        sym_diff = optional list that defaults as an empty list. 
        zeroConstraints = an optional list that defaults as an empty list.
            Entries in the list contain integer tuples of length V. The
            integer values represent the powers of the independent variables
            whose coefficient will be forced to 0 before the best fit
            calculations are performed, allowing the user to omit specific
            interaction terms or regular polynomial terms
        constraints = an optional list that defaults to an empty list.
            Entries in the list contain tuples of length 2. The first entry 
            is a list of integers that represent the powers of the
            independent variables whose coefficient will then be forced to
            be equal to the second entry in the tuple, which should be a
            float.
        percent = boolean value with default set to False. When set to True
            the least squares is performed on the percent error squared.
            This option should not be used if y contains any zero or near
            zero values, as this might cause a divide by zero error.
        weighting = optional callable function that defaults to None. If
            given, weighting should be a function that takes as arguments:
            x, y, and p where x and y are the independent and dependent
            variables defined above and p is the index representing a
            certain data point. weighting should return a 'weighting factor'
            that determines how important that datapoint is. Returning a '1'
            weights the datapoint normally.
    
    returns
    
        a = list of the polynomial coefficients. 'a' has a length equal to
            the products of the n_vec elements plus one.
            i.e.: (n_vec0+1)*(n_vec1+1)*...
        r2 = the coefficient of determination, also referred to as the R^2
            value. A value of 1 means the polynomial given by 'a' fits the
            data perfectly
    """
    # input variables and setup calculations
    ########################################################################
    x = np.copy(xx)
    y = np.copy(yy)
    # calculate number of dimensions used
    if type(Nvec) != list:
        Nvec = [Nvec]
    V = len(Nvec)
    # calculate the number of points in dataset
    k = len(y)
    # check for inconsistencies in dimensions from input variables
    if len(x.shape) == 1:
        x = np.transpose([x])
    if x.shape[1] != V: raise ValueError('Dimensions for V don\'t match between n_vec and x. Lenght of n_vec and number of columns of x should equal the number of independent variables used, V.')
    if x.shape[0] != k: raise ValueError('Number of rows between x and y don\'t agree! The number of rows should be the total number of points, k, of the dataset.')
    # calculate the length of the coefficient list to be returned
    # J = 1
    # for n in Nvec:
        # J *= n + 1
    J = calcJ(Nvec)
    # if sym wasn't given, initialize it to False values
    if type(sym) != list: sym = [sym]
    if sym == []:
        sym = [False] * V
    elif len(sym) != V:
        raise ValueError('Length of sym doesn\'t match the number of dimensions, V.')
    # create active list
    ########################################################################
    # set active to empty list
    active = []
    # loop through j values
    for j in range(J):
        # calculate the n values
        n = decompose_j(j, Nvec)
        # check if n is a constraint then continue on to the next j
        if tuple(n) in zeroConstraints: continue
        # check if j is an interaction term and if interactions aren't allowed then continue on to the next j
        if sum(n) != max(n) and not interaction: continue
        # initialize flag variable to false
        flag = False
        # loop through the sym list to find the symmetry constraints
        for count,symm in enumerate(sym):
            # check if flag has been tripped, then continue to the next j if it has
            if flag: break
            # check for a symmetry constraint
            if symm:
                # check if the order of the count-th independent variable is even
                if Nvec[count]%2 == 0:
                    # check if the n value of the count-th independent variable is odd
                    if n[count]%2 == 1:
                        flag = True
                # this else block means the order of the count-th independent variable is odd
                else:
                    # check if the n value of the count-th independent variable is even
                    if n[count]%2 == 0:
                        flag = True
        # if the flag has been tripped, skip to the next j value
        if flag: continue
        # loop through sym_same constraints
        for val in sym_same:
            # check if the n values from both variables given in val are even, then trip flag
            if n[val[0]]%2 == 0 and n[val[1]]%2 == 0:
                flag = True
            # check if the n values from both variables given in val are odd, then trip flap
            if n[val[0]]%2 == 1 and n[val[1]]%2 == 1:
                flag = True
        # loop through sym_diff constraints
        for val in sym_diff:
            # check if the n values from both variables given in val are even and odd, then trip flag
            if n[val[0]]%2 == 0 and n[val[1]]%2 == 1:
                flag = True
            # check if the n values from both variables given in val are odd and even, then trip flap
            if n[val[0]]%2 == 1 and n[val[1]]%2 == 0:
                flag = True
        # if flag hasn't been tripped, append j value onto the active list
        if not flag: active.append(j)
    #create constraints list
    ########################################################################
    con = {}
    for n,val in constraints:
        j = compose_j(n, Nvec)
        con['{}'.format(j)] = val
    #create A matrix and b vector
    ########################################################################
    # initialize A matrix
    A = np.zeros( ( len(active),len(active) ) )
    # initialize b vector
    b = np.zeros( len(active) )
    # setup progress bar for display
    if verbose: prog = oneLineProgress(len(active), msg='Building Matrix Eq for MultiPolyFit')
    # loop through i values
    for ii,i in enumerate(active):
        # calculate the nhat values
        nhat = decompose_j(i, Nvec)
        # loop through the j values
        for jj,j in enumerate(active):
            # calculate the n values
            n = decompose_j(j, Nvec)
            # calcualte Aij entry
            #####################
            
            if str(i) in con:
                if i == j:
                    A[ii,jj] = 1.
                else:
                    A[ii,jj] = 0.
            else:
                # initialize summ to 0
                summ = 0.
                # loop through points in dataset
                for p in range(1,k+1):
                    # initialize product series variable to 1
                    if y[p-1] != None:
                        prod = 1.
                    else:
                        prod = 0.
                    # loop through dimensions
                    for v in range(1,V+1):
                        # multiply the term onto the product series
                        prod *= x[p-1,v-1] ** (n[v-1] + nhat[v-1])
                    #==================================================
                    # add weighting factor
                    if callable(weighting):
                        prod *= weighting(x, y, p-1)
                    #==================================================
                    # add the product series variable to the summation
                    if percent:
                        if y[p-1] != None: summ += prod/abs(y[p-1])
                    else:
                        summ += prod
                # set Aij to the finalized summation
                A[ii,jj] = summ
        # calculate bi entry
        ####################
        if str(i) in con:
            b[ii] = con[str(i)]
        else:
            # initialize summation variable to 0
            summ = 0.
            # loop through points in the dataset
            for p in range(1,k+1):
                # initialize the product series variable to 1
                if y[p-1] != None:
                    prod = 1.
                else:
                    prod = 0.
                # loop through the dimensions
                for v in range(1,V+1):
                    # multiply the term onto the product series
                    prod *= x[p-1,v-1] ** nhat[v-1]
                #==================================================
                # add weighting factor
                if callable(weighting) and y[p-1] != None:
                    prod *= weighting(x, y, p-1)
                #==================================================
                # add the term onto the summation
                if percent:
                    summ += prod
                else:
                    if y[p-1] != None: summ += y[p-1] * prod
            # set bi to the finalized summation
            b[ii] = summ
        if verbose: prog.display()
    #solve Aa=b equation
    ########################################################################
    if verbose: print('solving the Aa=b equation')
    a = np.linalg.solve(A,b)
    #input the missing 0 coefficients into 'a' so that it can be used with the multidimensional_poly_func
    ########################################################################
    for i in range(J):
        if not i in active:
            a = np.insert(a,i,0.)
            active = np.insert(active,i,0)
    #calculate R^2 value
    ########################################################################
    r = multivariableR2(a, Nvec, x, y, verbose=verbose)       #r2_2D(a,M,x,y,z)
    #return values
    return a, r

def multivariablePolynomialFunction(a, Nvec, x):
    """
    Multivariable Polynomial Function
    
    inputs:
    
        a = list of the polynomial coefficients. 'a' has a length equal to
            the products of the Nvec elements plus one.
            i.e.: (Nvec0+1)*(Nvec1+1)*...
        Nvec = list with a length V equal to the number of independent
            variables. The ith element values are integers of polynomial
            order of the ith independent variable
        ??x = numpy matrix of size k by V, where k is the total number of
            points in the dataset. The ith column represents the ith
            independent variable values with the rows representing the
            different data points
    
    returns:
    
        f = value of the multivariable polynomial function for the given
            independent variables
    """
    # initialize summation to 0
    f = 0.
    # calculate total number of datapoints
    k = len(a)
    # calculate total number of dimensions
    V = len(x)
    # loop through the datapoints
    for j in range(k):
        # calculate the n values
        n = decompose_j(j, Nvec)
        # initialize the product series variable to 1
        prod = 1.
        # loop through the dimensions
        for v in range(V):
            # multiply onto the product series the term
            prod *= x[v] ** n[v]
        # add onto the summation the proper term
        f += a[j] * prod
    # return the finalized summation value
    return f

def multivariableR2(a, Nvec, xx, yy, verbose=True):
    """
    Routine to calculate the R^2 value of a multivariable polynomial fit to
    a dataset
    
    inputs:
    
        a = array of polynomial coefficients
        Nvec = list of integers representing the polynomial order of the
            independent variables
        xx = numpy matrix of size k by V, where k is the total number of
            points in the dataset. The ith column represents the ith
            independent variable values with the rows representing the
            different data points
        yy = list with a length of k with the dependent variable values
    
    returns:
    
        R2 = R^2 value, or the coefficient of determination
    """
    # ensure x and y are in the proper format
    x = np.copy(xx)
    y = np.copy(yy)
    ynew = np.copy([temp for temp in y if temp != None])
    # calculate k
    k = len(ynew)
    # calculate mean y value
    y_ = sum(ynew) / float(k)
    # calculate the SSt value
    SSt = sum( (ynew - y_) ** 2. )
    # initialize the f array
    f = []
    # loop through the datapoints
    if verbose: prog = oneLineProgress(len(y), msg='Determining R^2 of the fit')
    for i in range(len(y)):
        if y[i] == None:
            if verbose: prog.display()
            continue
        # calculate the f value from the polynomial function
        f.append( multivariablePolynomialFunction(a,Nvec,x[i,:]) )
        if verbose: prog.display()
    f = np.copy(f)
    # calculate the SSr term
    SSr = sum( (ynew - f) ** 2. )
    # calculate and return the R^2 value
    return 1. - SSr / SSt

def multivariableRMS(raw_x, raw_y, a, Nvec, verbose=True):
    """
    Routine to calculate the RMS and RMSN errors of a multivariable
    polynomial fit to a dataset
    
    inputs:
    
        raw_x = array of independent variables values from the dataset of
            shape (k,V) where k is the total number of points in the dataset
            and V is the number of independent variables
        raw_y = array of dependent variable values from the dataset
        a = array of polynomial coefficients
        Nvec = list of integers representing the polynomial order of the
            independent variables
    
    returns:
    
        RMS = root, mean, squared error
        RMSN = root, mean, squared, normalized error
    """
    x = np.copy( raw_x )
    y = np.copy( raw_y )
    avg = np.mean(abs(y))
    k = len(x[:,0])
    func = np.zeros(k)
    e = np.zeros(k)
    e_per = np.zeros(k)
    if verbose: prog = oneLineProgress(k, msg='Determining RMS of the fit')
    for i in range(k):
        func[i] = multivariablePolynomialFunction(a, Nvec, x[i])
        e[i] = (y[i] - func[i]) ** 2.
        e_per[i] = ((y[i] - func[i])/avg) ** 2.
        if verbose: prog.display()
    return np.sqrt(np.mean(e)), np.sqrt(np.mean(e_per))

def compose_j(n, Nvec):
    """
    Eq. 4 in Poly Fits Derivation. Routine to compose the j counter from
    the n values. Can also be used as Eq. 10 with the i counter and the nhat
    values.
    
    inputs:
    
        n = list of integer values representing the independent variables'
            exponents for the jth term in the multidimensional polynomial
            function (Eq. 2)
        Nvec = list of integers representing the polynomial order of the
            independent variables
    
    returns:
    
        j = integer representing the column of the A matrix or the jth
            polynomial coefficient
    """
    # calculate V
    V = len(Nvec)
    # initialize j to 0
    j = 0
    # loop through independent variables
    for v in range(1,V+1):
        # initialize product series to 1
        prod = 1
        # loop through w values for product series
        for w in range(v+1,V+1):
            # multiply on the term to the product series
            prod *= Nvec[w-1] + 1
        # add on term onto j
        j += n[v-1] * prod
    return j

def decompose_j(j, Nvec):
    """
    Eq. 5 in Poly Fits Derivation. Routine to decompose the j counter into
    the n values. Can also be used as Eq. 1 with the i counter and the nhat
    values.
    
    inputs:
    
        j = integer representing the column of the A matrix or the jth
            polynomial coefficient
        Nvec = list of integers representing the polynomial order of the
            independent variables
    
    returns:
    
        n = list of integer values representing the independent variables'
            exponents for the jth term in the multidimensional polynomial
            function (Eq. 2)
    """
    # calculate V
    V = len(Nvec)
    # initialize n values to nothing
    n = [[]]*V
    # loop through the n values that need to be solved, starting at the highest and working down
    for v in range(V,0,-1):
        # initialize the denomenator product series to 1
        denom = 1
        # loop through the w values needed for the product series
        for w in range(v+1,V+1):
            # multiply on the terms for the denomenator product series
            denom *= Nvec[w-1] + 1
        # initialize the summation variable to 0
        summ = 0
        # loop through the u values necessary for the summation
        for u in range(v+1,V+1):
            # initialize the product series variable inside the summation to 1
            prod = 1
            # loop through the s values needed for the product series that is inside the summation
            for s in range(u+1,V+1):
                # multiply on the term for the product series that is inside of the summation
                prod *= Nvec[s-1] + 1
            # add on the needed term to the summation series
            summ += n[u-1] * prod
        # finally calculate the n value cooresponding to this v
        n[v-1] = int(round( ((j-summ)/denom)%(Nvec[v-1]+1) ))
    return n

############################################################################
############################################################################
############################################################################

def calcJ(Nvec):
    J = 1
    for n in Nvec:
        J *= n + 1
    return J

def kDecompose(k, V):
    t = 1
    ###################################################
    ## find the category
    c = 0
    vals = [0] * V
    while k > t:
        c += 1
        m = [c] * (V-1)
        vals[0] = calcJ(m)
        for j in range(V-1):
            m[j] -= 1
            vals[j+1] = calcJ(m)
        t += sum(vals)
    if c == 0:
        return [0]*V
    ####################################################
    ## find the subcategory
    for sc in range(V-1,-1,-1):
        t -= vals[sc]
        if k > t:
            break
    ####################################################
    ## determine n
    # initialize n
    n = [None]*V
    n[sc] = c
    # create mx based on the sc, then decompose to get m
    mx = [c]*(V-1)
    for i in range(sc):
        mx[i] -= 1
    m = decompose_j(k-t-1, mx)
    # set m values into n and return
    j = -1
    for i in range(V):
        if i != sc:
            j += 1
            n[i] = m[j]
    return n

def kCompose(n):
    ########################################
    V = len(n)
    if V == 1: return calcJ(n)
    mx = max(n)
    if mx == 0: return 1
    k = 1
    ## calculate lower number sets
    for i in range(1,mx):
        m = [i] * (V-1)
        k += calcJ(m)
        for j in range(V-1):
            m[j] -= 1
            k += calcJ(m)
    ## calculate location in current number set
    for i in range(V):
        M = [mx]*(V-1)
        for j in range(i):
            M[j] -= 1
        if n[i] != mx:
            k += calcJ(M)
        else:
            m = [n[j] for j in range(V) if j != i]
            k += compose_j(m, M) + 1
            return k
    raise ValueError('Unable to compose n into k: current k value {}'.format(k))

class oneLineProgress():
    
    def __init__(self, Total, msg='', showETR=True):
        self.total = Total
        self.msg = msg
        self.count = 0
        self.showETR = showETR
        self.start = dt.now()
        self.rollTimer = dt.now()
        self.rollCount = -1
        self.rollDelta = 0.2
        self.display()
    
    def increment(self):
        self.count += 1
    
    def decrement(self):
        self.count -= 1
    
    def __str__(self):
        pass
    
    def __len__(self):
        l = len(str(self))
        self.decrement()
        return l
    
    def Set(self, count):
        self.count = count
    
    def display(self):
        rolling = '-\\|/'
        rollDelta = (dt.now()-self.rollTimer).total_seconds()
        
        p2s = False
        if rollDelta >= self.rollDelta or self.rollCount == -1:
            p2s = True
            self.rollTimer = dt.now()
            self.rollCount += 1
            if self.rollCount >= len(rolling):
                self.rollCount = 0
        
        perc = self.count / self.total * 100.
        self.increment()
        
        if not p2s and perc < 100.: return
        
        s = '\r' + ' '*(len(self.msg)+50) + '\r'
        s += self.msg + ' '*4
        
        # j = 0
        for i in range(10):
            if perc >= i*10:
                j = i
        
        if perc < 100.:
            s += u'\u039e'*j + rolling[self.rollCount] + '-'*(9-j)
        else:
            s += u'\u039e'*10
        
        # for i in range(1,11):
            # if i*10 <= perc:
                # s += u'\u039e'
            # else:
                # s += '-'
        s += ' '*4 + '{:7.3f}%'.format(perc)
        if not self.showETR:
            if perc >= 100.: s += '\n'
            print(s, end='')
            return
        
        if perc <= 0:
            etr = '-:--:--.------'
            s += ' '*4 + 'ETR = {}'.format(etr)
        elif perc >= 100.:
            s += ' '*4 + 'Run Time {}'.format(dt.now()-self.start) + '\n'
        else:
            time = (dt.now()-self.start).total_seconds()
            etr = td(seconds=time / perc * 100. - time)
            s += ' '*4 + 'ETR = {}'.format(etr)
        print(s, end='')
        return

def zSort(v, *W, ascend=True, verbose=True, msg='Sorting the arrays'):
    k = len(v)
    for w in W:
        if len(w) != k: raise ValueError('All arrays need to be the same length in zSort')
    c = []
    if verbose: prog = oneLineProgress(sum([i for i in range(k)])+len(W), msg=msg)
    for m in range(k):
        for j in range(k-1,m,-1):
            i = j-1
            
            if (ascend and v[j] < v[i]) or (not ascend and v[j] > v[i]):
                c.append(j)
                temp = v[j]
                v[j] = v[i]
                v[i] = temp
            if verbose: prog.display()
    
    for w in W:
        for j in c:
            i = j-1
            temp = w[j]
            w[j] = w[i]
            w[i] = temp
        if verbose: prog.display()

def isClose(x, y, tol=1.e-12):
    return y-tol <= x and x <= y+tol


def autoPolyFit(X, y, max_order=6, tol=1.e-12, sigma=None, sigma_multiplier=1., verbose=True):
    '''
    autoPolyFit function performs a mutivariable polynomial curve
    fit to a dataset and automatically determines which terms in the
    polynomial to use based on a balance between a goodness of the fit and a
    predictive capabilities measure that attempts to make the model compact.
    
    inputs:
        X : numpy array of shape (N,m). X consists of all the independent
            variables in the dataset. N is the number of data points in the
            set and m is the number of independent variables
        y : list or numpy array with length N. y is the dependent variable
            values cooresponding to the independent variables in X
        max_order : optional integer. gives the max order of polynomial for
            any one of the independent varialbes to try. defaults to 12
        tol : optional float. Gives the cut-off value for any polynomial
            coefficient to not be included in the final results. If a
            coefficient has an absolute value below tol, it won't be
            included. defaults to 1e-12
        sigma : optional float. value used to determine the trade off
            between how good of a fit to perform and how many terms to keep.
            defaults to None, which causes the function to calculate sigma
            automatically using the mean squared of the difference of the
            independent variable values with respect to the mean independent
            variable value of the dataset
        sigma_multiplier : optional float. term multiplied onto sigma to
            change it's value. Allows using a multiple of the automatically
            determined sigma value. Defaults to 1.
    
    returns:
        list : a list of the polynomial coefficients in a form used by the
            poly_fits module
        list : a list of the max polynomial orders for each independent
            variable. The length of this list is therefore m. This list is
            the 'Nvec' object used in the poly_fits module
        float : the coefficient of determination, R^2 value, representing
            the goodness of the fit
    '''
    ## number of independent variables
    m = X.shape[1]
    ## max range of polynomials to try
    Nvec = tuple([max_order]*m)
    ## number of datapoints
    N = len(y)
    ## number of p functions
    K = kCompose(Nvec)
    ###################################################################
    ##           determine the orthogonal p functions
    if verbose: prog = oneLineProgress(K-1, msg='Determining the orthogonal p functions')
    ## initialize the P matrix
    P = np.zeros((N, K))
    P[:,0] = 1.
    ## loop thru k values
    for k in range(2,K+1):
        ## determine the set associated with k
        n = decompose_j(k-1, Nvec)
        ## find pkhat and mu
        mu = None
        for i in range(m):
            nhat = n[:]
            if nhat[i] > 0:
                nhat[i] -= 1
                khat = compose_j(nhat, Nvec) + 1
                if khat < k:
                    mu = i
                    break
        if mu == None: raise ValueError('Unable to find previous khat set')
        pkhat = P[:,khat-1]
        xmu = X[:,mu]
        ## calculate pk first term
        temp = xmu * pkhat
        phik = sum(n)
        pk = temp[:]
        ## loop thru summation in eq 18
        for j in range(1,k):
            ## check if value is needed
            phij = sum(decompose_j(j-1, Nvec))
            if phik - phij <= 2:
                ## calculate gamma
                pj = P[:,j-1]
                gamma = np.dot(pj, temp) / np.dot(pj, pj)
                pk -= gamma * pj
        ## add pk to P
        P[:,k-1] = pk[:]
        if verbose: prog.display()
    #################################################################
    ##              sort the p functions by effectiveness
    order = [i for i in range(K)]
    ranks = [None] * K
    for i in range(K):
        pj = P[:,i]
        pjdot = np.dot(pj, pj)
        ajhat = np.dot(pj, y) / pjdot
        ranks[i] = ajhat ** 2. * pjdot
    zSort(ranks, order, ascend=False, msg='Sorting the p functions by effectivenss', verbose=verbose)
    Pordered = np.zeros((N,K))
    for i,o in enumerate(order):
        Pordered[:,i] = P[:,o]
    P = Pordered[:,:]
    ###################################################################
    ##          determine how many of the orthogonal p functions to use
    if verbose: prog = oneLineProgress(K, msg='Determining number of p functions to use')
    PSEold = None
    foundMin = False
    if sigma == None:
        yavg = sum(y) / N
        sigma = sum([(i - yavg)**2. for i in y]) / N
    sigma *= sigma_multiplier
    
    for n in range(1,K+1):
        Phat = P[:,:n]
        ahat = np.matmul(np.matmul(np.linalg.inv(np.matmul(Phat.transpose(), Phat)), Phat.transpose()), y)
        yhat = np.matmul(Phat, ahat)
        MSE = np.dot(y - yhat, y - yhat) / N
        PSEnew = MSE + sigma * n / N
        if verbose: prog.display()
        if PSEold == None or PSEnew <= PSEold:
            PSEold = PSEnew
        else:
            foundMin = True
            nn = n-1
            P = Phat[:,:nn]
            order = order[:nn]
            if verbose: 
                prog.Set(K)
                prog.display()
            break
    if not foundMin:
        raise ValueError('Unable to find minimum PSE')
    ###################################################################
    ##              final coefficients and polynomial size
    if verbose: prog = oneLineProgress(4+nn, msg='Determining final coefficients and polynomial size')
    b = np.zeros((nn,nn))
    for k in range(1,nn+1):
        j = k - 1
        pj = P[:,j]
        w = np.ones((N,k))
        for i in range(k):
            n = decompose_j(order[i], Nvec)
            for ii,e in enumerate(n):
                w[:,i] *= X[:,ii] ** e
        vals = np.matmul(np.matmul(np.linalg.inv(np.matmul(w.transpose(), w)), w.transpose()), pj)
        b[j,:k] = vals[:]
        if verbose: prog.display()
    
    A = [np.dot(P[:,i],y)/np.dot(P[:,i],P[:,i]) for i in range(nn)]
    if verbose: prog.display()
    
    c = [np.dot(A,b[:,i]) for i in range(nn)]
    js = [decompose_j(order[i], Nvec) for i in range(nn)]
    if verbose: prog.display()
    
    js = [js[i] for i in range(nn) if not isClose(c[i], 0., tol=tol)]
    c = [i for i in c if not isClose(i, 0., tol=tol)]
    if verbose: prog.display()
    
    nvec = [None]*m
    for i in range(m):
        nvec[i] = max([j[i] for j in js])
    JJ = 1
    for n in nvec:
        JJ *= n+1
    
    a = [0.] * JJ
    for j in range(JJ):
        n = decompose_j(j, nvec)
        for i in range(len(c)):
            if n == js[i]:
                a[j] = c[i]
    if verbose: prog.display()
    
    return a, nvec, multivariableR2(a, nvec, X, y, verbose=verbose)

</"file: python/AirfoilDatabase/build/lib/airfoil_db/poly_fits.py">

<"file: python/airfoilGen/__init__.py"></"file: python/airfoilGen/__init__.py">

<"file: python/users/younessf31/__init__.py"></"file: python/users/younessf31/__init__.py">

<"file: python/base.py">from typing import List

class point:
    x: float
    y: float

    def __init__(self, x_, y_) -> None:
        self.x = x_
        self.y = y_
    
    def to_point(self) -> List[float]:
        return [self.x, self.y]
    
    def __mul__(self, other):
        if (not isinstance(other, float)):
            return self.to_point()
        return [self.x * other, self.y * other]
    def __rmul__(self, other):
        return self * other
    

class airfoilFile:
    path: str
    arr: List[tuple]

    def __init__(self, _path) -> None:
        self.path = _path
        self.arr = self.read()

    def recenterX(self, offset=0.5) -> None:
        self.arr = [tuple([d[0] + offset, d[1]]) for d in self.arr]

    def scaleAndRecenterAtTrailingEdge(self, factor) -> None:
        max_ = max(d[0] for d in self.arr)
        self.scale(factor)
        max_2 = max(d[0] for d in self.arr)
        self.recenterX(max_ - max_2)

    def scaleAndRecenterAtLeadingEdge(self, factor) -> None:
        max_ = min(d[0] for d in self.arr)
        self.scale(factor)
        max_2 = min(d[0] for d in self.arr)
        self.recenterX(max_ - max_2)

    def scaleAndRecenterAtBothEdge(self, factor) -> None:
        min_ = min(d[0] for d in self.arr)
        max_ = max(d[0] for d in self.arr)
        self.scale(factor)
        max_2 = max(d[0] for d in self.arr)
        min_2 = min(d[0] for d in self.arr)
        self.recenterX((max_ +  min_ - max_2 - min_2))

    def scale(self, factor) -> None:
        self.arr = [tuple([d[0]*factor, d[1]*factor]) for d in self.arr]
    
    def read(self) -> List[tuple]:
        with open(self.path, "r") as f:
            lines = f.readlines()
        if lines.__len__() == 0:
            return []
        arr = []
        for line in lines[1:]:
            objs = line.strip().split(' ')
            if (len(objs) == 3):
                arr.append((float(objs[0]), float(objs[1] + objs[2])))
            else:
                arr.append((float(objs[0]), float(objs[1])))
        return arr

def correctPath(scriptfile, file):
    from os.path import dirname, realpath
    file_name = dirname(realpath(scriptfile)) + '/' + file
    return file_name
</"file: python/base.py">

<"file: python/users/younessf31/base.py">from typing import List

class point:
    x: float
    y: float

    def __init__(self, x_, y_) -> None:
        self.x = x_
        self.y = y_
    
    def to_point(self) -> List[float]:
        return [self.x, self.y]
    
    def __mul__(self, other):
        if (not isinstance(other, float)):
            return self.to_point()
        return [self.x * other, self.y * other]
    def __rmul__(self, other):
        return self * other
    

class airfoilFile:
    path: str
    arr: List[tuple]

    def __init__(self, _path) -> None:
        self.path = _path
        self.arr = self.read()

    def recenterX(self, offset=0.5) -> None:
        self.arr = [tuple([d[0] + offset, d[1]]) for d in self.arr]

    def scaleAndRecenterAtTrailingEdge(self, factor) -> None:
        max_ = max(d[0] for d in self.arr)
        self.scale(factor)
        max_2 = max(d[0] for d in self.arr)
        self.recenterX(max_ - max_2)

    def scaleAndRecenterAtLeadingEdge(self, factor) -> None:
        max_ = min(d[0] for d in self.arr)
        self.scale(factor)
        max_2 = min(d[0] for d in self.arr)
        self.recenterX(max_ - max_2)

    def scaleAndRecenterAtBothEdge(self, factor) -> None:
        min_ = min(d[0] for d in self.arr)
        max_ = max(d[0] for d in self.arr)
        self.scale(factor)
        max_2 = max(d[0] for d in self.arr)
        min_2 = min(d[0] for d in self.arr)
        self.recenterX((max_ +  min_ - max_2 - min_2))

    def scale(self, factor) -> None:
        self.arr = [tuple([d[0]*factor, d[1]*factor]) for d in self.arr]
    
    def read(self) -> List[tuple]:
        with open(self.path, "r") as f:
            lines = f.readlines()
        if lines.__len__() == 0:
            return []
        arr = []
        for line in lines[1:]:
            objs = line.strip().split(' ')
            if (len(objs) == 3):
                arr.append((float(objs[0]), float(objs[1] + objs[2])))
            else:
                arr.append((float(objs[0]), float(objs[1])))
        return arr

def correctPath(scriptfile, file):
    from os.path import dirname, realpath
    file_name = dirname(realpath(scriptfile)) + '/' + file
    return file_name
</"file: python/users/younessf31/base.py">

<"file: python/users/younessf31/create_io.py">import os

def list_files_by_folder(directory):
    """
    This function takes a directory path as input and returns a dictionary where each folder in the 
    directory is a key and its files are the values. Files directly in the root directory will be listed under 'root_files'.
    
    :param directory: Path to the directory (str)
    :return: A dictionary with folders as keys and lists of files as values
    """
    result = {"root_files": []}

    directory = os.getcwd() + "/" + directory
    
    # Check if the directory exists
    if os.path.exists(directory):
        # Iterate over the contents of the directory
        for item in os.listdir(directory):
            item_path = os.path.join(directory, item)
            
            # If it's a directory, create a key and list its files
            if os.path.isdir(item_path):
                result[item] = []
                for sub_item in os.listdir(item_path):
                    sub_item_path = os.path.join(item_path, sub_item)
                    if os.path.isfile(sub_item_path):
                        result[item].append(sub_item)
            
            # If it's a file in the root directory, add it to 'root_files'
            elif os.path.isfile(item_path):
                result["root_files"].append(item)
    else:
        return f"The directory '{directory}' does not exist."

    return result

def list_files_recursively(directory):
    """
    This function takes a directory path as input and returns a dictionary where each folder (including subdirectories)
    is a key, and its files are the values. It traverses all subdirectories recursively.
    
    :param directory: Path to the directory (str)
    :return: A dictionary with folders (and their subdirectories) as keys and lists of files as values
    """
    result = {}

    directory = os.getcwd() + "/" + directory

    # Check if the directory exists
    if os.path.exists(directory):
        # Walk through the directory and its subdirectories
        for root, dirs, files in os.walk(directory):
            # For each directory, get the relative path and its files
            relative_path = os.path.relpath(root, directory)
            if relative_path == '.':  # Root directory case
                result["root"] = files
            else:
                result[relative_path] = files
    else:
        return f"The directory '{directory}' does not exist."

    return result

if __name__ == "__main__":
    # Example usage
    directory = 'user001'  # Provide the path to the "user001" folder here
    print(list_files_by_folder(directory))
</"file: python/users/younessf31/create_io.py">

<"file: python/create_view.py">import pyvista as pv
import numpy as np



def create_screenshot(stl_file: str):
    # Load your STL or STEP file
    mesh = pv.read(stl_file)  # Replace with your STL or STEP file


    # Set up the plotter
    plotter = pv.Plotter(off_screen=True)
    plotter.add_mesh(mesh, color="lightblue", show_edges=False)



    plotter.view_xz()  # This sets the view to the XY plane (front view)

    # Rotate the camera 45 degrees around the X-axis
    # Get the current camera position
    # camera_position = plotter.camera.position

    # Set the new camera position
    # plotter.camera.position = new_camera_position
        
    # Optional: Adjust the camera zoom (if needed)
    plotter.camera.zoom(5)  # Adjust the zoom level as necessary

    # Render and save the view as an image
    # png = plotter.show(screenshot=True)
    plotter.screenshot(stl_file + ".png")</"file: python/create_view.py">

<"file: python/generate_wings.py">

if __name__ == "__main__":
    import os

    # Specify the folder path
    folder_path = 'airfoils'

    # List all .dat files in the folder
    dat_files = [f for f in os.listdir(folder_path) if f.endswith('.dat')]

    # Print the list of .dat files
    from airfoil_shape import vectors
    from base import airfoilFile
    from create_geo_airfoil import create_geometry_from_file
    from create_view import create_screenshot

    print("DAT files in the folder:")
    for file_ in dat_files:
        file = "airfoils/" + file_
        print(file)
        # a = airfoilFile(file)
        # a.recenterX(-0.5)
        # a.scale(1000)
        # res = create_geometry_from_file(a, 5000, "straight_leading_tappered_trailing", [], file)
        create_screenshot(file + ".stl")
</"file: python/generate_wings.py">

<"file: python/create_mesh.py">import gmsh

def generate_mesh_from_step(step_file: str, mesh_file: str):
    gmsh.initialize()
    gmsh.open(step_file)

    # Set mesh options
    gmsh.option.setNumber("Mesh.CharacteristicLengthMin", 0.01)
    gmsh.option.setNumber("Mesh.CharacteristicLengthMax", 0.1)

    # Generate 3D mesh
    gmsh.model.mesh.generate(3)

    # Export to STL or MSH format
    gmsh.write(mesh_file)

    gmsh.finalize()

# Usage
if __name__ == "__main__":
    generate_mesh_from_step('airfoil_extruded.stl', 'airfoil_mesh.msh')
</"file: python/create_mesh.py">

<"file: python/airfoil_shape.py">vectors = [
(0, 0),
(1.00, 0.00),
(0.95, 0.01),
(0.90, 0.02),
(0.80, 0.03),
(0.70, 0.05),
(0.60, 0.06),
# (0.50, 0.07),
# (0.40, 0.08),
# (0.30, 0.09),
# (0.25, 0.08),
# (0.20, 0.08),
# (0.15, 0.08),
# (0.10, 0.07),
# (0.07, 0.06),
# (0.05, 0.05),
# (0.02, 0.03),
# (0.01, 0.02),
# (0.00, 0.00),
# (0.01, 0.02),
# (0.02, 0.03),
# (0.05, 0.05),
# (0.07, 0.06),
# (0.10, 0.07),
# (0.15, 0.08),
# (0.20, 0.08),
# (0.25, 0.08),
# (0.30, 0.09),
# (0.40, 0.08),
# (0.50, 0.07),
# (0.60, 0.06),
# (0.70, 0.05),
# (0.80, 0.03),
# (0.90, 0.02),
# (0.95, 0.01),
# (1.00, 0.00),
# (1.00, 0.00),
(0, 0)

]</"file: python/airfoil_shape.py">

<"file: python/test2.py">import pyvista as pv
import numpy as np

# NACA airfoil coordinates for the upper and lower surface
naca_airfoil = np.array([
    (1.000000, 0.001890),
    (0.950000, 0.012100),
    (0.900000, 0.021720),
    (0.800000, 0.039350),
    (0.700000, 0.054960),
    (0.600000, 0.068450),
    (0.500000, 0.079410),
    (0.400000, 0.087050),
    (0.300000, 0.090030),
    (0.250000, 0.089120),
    (0.200000, 0.086060),
    (0.150000, 0.080180),
    (0.100000, 0.070240),
    (0.075000, 0.063000),
    (0.050000, 0.053320),
    (0.025000, 0.039220),
    (0.012500, 0.028410),
    (0.000000, 0.000000),  # Trailing edge
    (0.012500, -0.028410), # Lower surface
    (0.025000, -0.039220),
    (0.050000, -0.053320),
    (0.075000, -0.063000),
    (0.100000, -0.070240),
    (0.150000, -0.080180),
    (0.200000, -0.086060),
    (0.250000, -0.089120),
    (0.300000, -0.090030),
    (0.400000, -0.087050),
    (0.500000, -0.079410),
    (0.600000, -0.068450),
    (0.700000, -0.054960),
    (0.800000, -0.039350),
    (0.900000, -0.021720),
    (0.950000, -0.012100),
    (1.000000, -0.001890)   # Leading edge point
])

# Create a PolyData object for the 2D airfoil
points = np.hstack((naca_airfoil, np.zeros((naca_airfoil.shape[0], 1))))  # Add Z=0 for 2D
lines = np.arange(0, len(naca_airfoil)).reshape(-1, 2)
lines = np.append(lines, [[len(naca_airfoil)-1, 0]], axis=0)  # Close the loop

# Create polyline
airfoil_2d = pv.PolyData(points, np.hstack(([2] * lines.shape[0], lines.flatten())))

# Extrude the 2D airfoil to create a 3D wing with a wingspan of 4 meters
wingspan = 4.0  # meters
airfoil_3d = airfoil_2d.extrude([0, 0, wingspan])

# Visualize the 3D airfoil
plotter = pv.Plotter()
plotter.add_mesh(airfoil_3d, color="lightblue", show_edges=True)
plotter.show()

# Optionally, you can save the airfoil as an STL file for further use
airfoil_3d.save('naca_airfoil_3d_wing.stl')
</"file: python/test2.py">

<"file: error.txt">Error minifying python/airfoil2.svg: Unsupported file format
Error minifying python/instance/dynamicas.db: Unsupported file format
Error minifying python/__pycache__/models.cpython-310.pyc: Unsupported file format
Error minifying python/res2.txt: Unsupported file format
Error minifying python/err.txt: Unsupported file format
Error minifying python/res.txt: Unsupported file format
Error minifying python/migrations/versions/__pycache__/3279f3e0f96b_first.cpython-310.pyc: Unsupported file format
Error minifying python/migrations/__pycache__/env.cpython-310.pyc: Unsupported file format
Error minifying python/migrations/alembic.ini: Unsupported file format
Error minifying python/migrations/script.py.mako: Unsupported file format
Error minifying python/migrations/README: Unsupported file format
Error minifying python/__pycache__/app.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/configs.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/airfoilData.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/users.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/__init__.cpython-310.pyc: Unsupported file format
Error minifying python/xwaiT.gif:Zone.Identifier: Unsupported file format
Error minifying python/xwaiT.gif: Unsupported file format
Error minifying python/__pycache__/utils.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/create_io.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/user.cpython-310.pyc: Unsupported file format
Error minifying python/airfoilGen/__pycache__/generator.cpython-310.pyc: Unsupported file format
Error minifying python/my_secrets/__pycache__/secret_key_.cpython-310.pyc: Unsupported file format
Error minifying python/my_secrets/__pycache__/secret_key.cpython-310.pyc: Unsupported file format
Error minifying python/my_secrets/__pycache__/__init__.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/create_geo_airfoil.cpython-310.pyc: Unsupported file format
Error minifying python/airfoilData/myairfoilgeom.txt: Unsupported file format
Error minifying python/AirfoilDatabase/airfoil_db.egg-info/PKG-INFO: Unsupported file format
Error minifying python/AirfoilDatabase/airfoil_db.egg-info/SOURCES.txt: Unsupported file format
Error minifying python/AirfoilDatabase/airfoil_db.egg-info/dependency_links.txt: Unsupported file format
Error minifying python/AirfoilDatabase/airfoil_db.egg-info/not-zip-safe: Unsupported file format
Error minifying python/AirfoilDatabase/airfoil_db.egg-info/requires.txt: Unsupported file format
Error minifying python/AirfoilDatabase/airfoil_db.egg-info/top_level.txt: Unsupported file format
Error minifying python/AirfoilDatabase/.gitignore: Unsupported file format
Error minifying python/AirfoilDatabase/.readthedocs.yml: Unsupported file format
Error minifying python/AirfoilDatabase/LICENSE: Unsupported file format
Error minifying python/AirfoilDatabase/dev/64A204.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/Eppler_335_profile.csv: Unsupported file format
Error minifying python/AirfoilDatabase/dev/NACA_0012_geom.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/NACA_9412_geom.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/symmetric.dat: Unsupported file format
Error minifying python/AirfoilDatabase/dev/uCRM-9_wr0_xfoil.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/xfoil_test/test.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/xfoil_test/test_DP.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/xfoil_test/test_linux.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/xfoil_test/test_windows.txt: Unsupported file format
Error minifying python/AirfoilDatabase/dev/zach/grid.f90: Unsupported file format
Error minifying python/AirfoilDatabase/docs/source/airfoil_class.rst: Unsupported file format
Error minifying python/AirfoilDatabase/docs/source/error_handling.rst: Unsupported file format
Error minifying python/AirfoilDatabase/docs/source/index.rst: Unsupported file format
Error minifying python/AirfoilDatabase/docs/source/requirements.txt: Unsupported file format
Error minifying python/AirfoilDatabase/examples/my_airfoil_database.txt: Unsupported file format
Error minifying python/AirfoilDatabase/examples/my_airfoil_geom.txt: Unsupported file format
Error minifying python/airfoilGen/__pycache__/__init__.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/base.cpython-310.pyc: Unsupported file format
Error minifying python/pyproject.toml: Unsupported file format
Error minifying python/users/younessf31/pyproject.toml: Unsupported file format
Error minifying python/airfoilGen2412.dat: Unsupported file format
Error minifying python/users/younessf31/airfoilGen2412.dat: Unsupported file format
Error minifying python/__pycache__/create_view.cpython-310.pyc: Unsupported file format
Error minifying python/__pycache__/create_mesh.cpython-310.pyc: Unsupported file format
Error minifying python/plan: Unsupported file format
Error minifying python/airfoils/SELIG_S1223.dat.step: Unsupported file format
Error minifying python/airfoils/SELIG_S1223.dat.stl: Unsupported file format
Error minifying python/airfoils/NACA_2412.dat.step: Unsupported file format
Error minifying python/airfoils/NACA_2412.dat.stl: Unsupported file format
Error minifying python/airfoils/RG15.dat.step: Unsupported file format
Error minifying python/airfoils/RG15.dat.stl: Unsupported file format
Error minifying python/airfoils/E387.dat.step: Unsupported file format
Error minifying python/airfoils/E387.dat.stl: Unsupported file format
Error minifying python/airfoils/MH32.dat.step: Unsupported file format
Error minifying python/airfoils/MH32.dat.stl: Unsupported file format
Error minifying python/airfoils/AG35.dat.step: Unsupported file format
Error minifying python/airfoils/AG35.dat.stl: Unsupported file format
Error minifying python/airfoils/test.dat.step: Unsupported file format
Error minifying python/airfoils/test.dat.stl: Unsupported file format
Error minifying python/airfoils/ClarkY.dat.step: Unsupported file format
Error minifying python/airfoils/ClarkY.dat.stl: Unsupported file format
Error minifying python/airfoils/NACA_23012.dat.step: Unsupported file format
Error minifying python/airfoils/NACA_23012.dat.stl: Unsupported file format
Error minifying python/ClarkY.dat: Unsupported file format
Error minifying python/airfoils/ClarkY.dat: Unsupported file format
Error minifying python/airfoils/ClarkY.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/AG35.dat: Unsupported file format
Error minifying python/airfoils/AG35.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/RG15.dat: Unsupported file format
Error minifying python/airfoils/RG15.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/NACA_23012.dat: Unsupported file format
Error minifying python/airfoils/NACA_23012.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/E387.dat: Unsupported file format
Error minifying python/airfoils/E387.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/MH32.dat: Unsupported file format
Error minifying python/airfoils/MH32.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/SELIG_S1223.dat: Unsupported file format
Error minifying python/airfoils/SELIG_S1223.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/NACA_2412.dat: Unsupported file format
Error minifying python/airfoils/NACA_2412.dat:Zone.Identifier: Unsupported file format
Error minifying python/airfoils/test.dat: Unsupported file format
Error minifying python/airfoils/test.dat:Zone.Identifier: Unsupported file format
Error minifying python/tests/airfoil_extruded.step: Unsupported file format
Error minifying python/tests/airfoil_extruded.stl: Unsupported file format
Error minifying python/__pycache__/base.cpython-311.pyc: Unsupported file format
Error minifying python/Types-of-wings-2-1024x687.jpg:Zone.Identifier: Unsupported file format
Error minifying python/__pycache__/airfoil_shape.cpython-311.pyc: Unsupported file format
Error minifying python/airfoil_mesh.msh: Unsupported file format
Error minifying python/naca2412.dat:Zone.Identifier: Unsupported file format
Error minifying python/tests/naca2412.dat: Unsupported file format
Error minifying python/__pycache__/airfoil_shape.cpython-310.pyc: Unsupported file format
Error minifying python/airfoil.stl: Unsupported file format</"file: error.txt">

